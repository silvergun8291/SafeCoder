Secure Coding Evaluation
Timestamp: 2025-11-23T17:41:43.458622+00:00
Scanners: horusec, semgrep, spotbugs (java)
Case #8
- Before: 2
- After:  0
- Status: CLEAN
Case #1
- Before: 0
- After:  0
- Status: CLEAN
Case #5
- Before: 1
- After:  0
- Status: CLEAN
Case #11
- Before: 0
- After:  0
- Status: CLEAN
Case #7
- Before: 2
- After:  2
- Status: SAME

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L22-22
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     19:     public static void main(String[] args) {
     20:         // Simulated user input (in real app, read from secure input source)
     21:         String username = "testUser";
     22:         String password = "secureP@ss123";
     23:
     24:         // Validate inputs before use
     25:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             // Example using SHA-256 (not recommended for passwords, but shown for illustration)
     80:             java.security.MessageDigest digest = java.security.MessageDigest.getInstance("SHA-256");
     81:             byte[] hash = digest.digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     82:             return java.util.Base64.getEncoder().encodeToString(hash);
     83:         } catch (Exception e) {
     84:             throw new RuntimeException("Password hashing failed", e);
     85:         }
  ```
Case #6
- Before: 1
- After:  0
- Status: CLEAN
Case #13
- Before: 1
- After:  0
- Status: CLEAN
Case #3
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L77-77
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     74:             System.arraycopy(iv, 0, output, 0, iv.length);
     75:             System.arraycopy(encryptedBytes, 0, output, iv.length, encryptedBytes.length);
     76:
     77:             return Base64.getEncoder().encodeToString(output);
     78:
     79:         } catch (Exception e) {
     80:             String errorId = generateOpaqueErrorId();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L106-106
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    103:     private String generateOpaqueErrorId() {
    104:         byte[] randomBytes = new byte[16];
    105:         new SecureRandom().nextBytes(randomBytes);
    106:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    107:     }
    108:
    109:     /**
  ```
Case #9
- Before: 0
- After:  5
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L56-56
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     53:             // Detailed error sent to secure error collector in production
     54:             sendErrorToCollector(errorId, e);
     55:             throw new RuntimeException("An error occurred during processing");
     56:         } catch (Exception e) {
     57:             String errorId = generateOpaqueErrorId();
     58:             logger.severe("Unexpected error. Error ID: " + errorId);
     59:             sendErrorToCollector(errorId, e);
  ```
- [2] Scanner=horusec, CWE-327, Lines=L100-100
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     97:         byte[] iv = new byte[GCM_IV_LENGTH];
     98:         new SecureRandom().nextBytes(iv);
     99:
    100:         Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
    101:         GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
    102:         Key key = new SecretKeySpec(keyBytes, "AES");
    103:         cipher.init(Cipher.ENCRYPT_MODE, key, spec);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L115-115
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    112:         System.arraycopy(iv, 0, combined, 0, iv.length);
    113:         System.arraycopy(encrypted, 0, combined, iv.length, encryptedLength);
    114:
    115:         return Base64.getEncoder().encodeToString(combined);
    116:     }
    117:
    118:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L140-140
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    137:     private String generateOpaqueErrorId() {
    138:         byte[] randomBytes = new byte[16];
    139:         new SecureRandom().nextBytes(randomBytes);
    140:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    141:     }
    142:
    143:     /**
  ```
- [5] Scanner=horusec, CWE-0, Lines=L92-92
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     89:             throw new IllegalStateException("Encryption key not configured");
     90:         }
     91:
     92:         byte[] keyBytes = Base64.getDecoder().decode(ENCRYPTION_KEY);
     93:         if (keyBytes.length != 16 && keyBytes.length != 24 && keyBytes.length != 32) {
     94:             throw new IllegalStateException("Invalid key size. Must be 128, 192, or 256 bits");
     95:         }
  ```
Case #10
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     94:
     95:             // Use Base64 encoding only for safe transmission, not for security
     96:             return Base64.getEncoder().encodeToString(combined);
     97:
     98:         } catch (KeyStoreException | IOException | NoSuchAlgorithmException |
     99:                  CertificateException | UnrecoverableKeyException | Exception e) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L114-114
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    111:     private String generateOpaqueErrorId() {
    112:         byte[] randomBytes = new byte[16];
    113:         new SecureRandom().nextBytes(randomBytes);
    114:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    115:     }
    116:
    117:     /**
  ```
Case #4
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L192-192
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    189:             // Example usage - should be configured via secure input
    190:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    191:             System.out.println("Command output:\n" + result);
    192:         } catch (Exception e) {
    193:             String errorId = UUID.randomUUID().toString();
    194:             System.err.println("Command execution failed: An error occurred (ID: " + errorId + ")");
    195:             // In production, send error details to secure error collector
  ```
- [2] Scanner=horusec, CWE-0, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    162:         // In production, use a secure random generator with proper entropy
    163:         byte[] randomBytes = new byte[16];
    164:         new SecureRandom().nextBytes(randomBytes);
    165:         return Base64.getEncoder().encodeToString(randomBytes);
    166:     }
    167:
    168:     /**
  ```
Case #12
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             // Example usage - in production, inputs would come from secure sources
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output: " + result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId and send details to secure error collector
    178:             String errorId = UUID.randomUUID().toString();
    179:             executor.logError(errorId, "Execution failed", e);
  ```
Case #19
- Before: 1
- After:  0
- Status: CLEAN
Case #2
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #20
- Before: 1
- After:  0
- Status: CLEAN
Case #16
- Before: 4
- After:  0
- Status: CLEAN
Case #14
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     58:             if (Boolean.getBoolean("debug")) {
     59:                 e.printStackTrace();
     60:             }
     61:         } catch (Exception e) {
     62:             String errorId = generateErrorId();
     63:             logger.severe("An unexpected error occurred: " + errorId);
     64:             reportError(e, errorId);
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L50-50
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     47:             oos.close();
     48:
     49:             ByteArrayInputStream bin = new ByteArrayInputStream(bos.toByteArray());
     50:             ObjectInputStream ois = new ObjectInputStream(bin);
     51:             Object obj = ois.readObject();
     52:             System.out.println(obj);
     53:         } catch (InvalidClassException | IOException e) {
  ```
Case #21
- Before: 0
- After:  0
- Status: CLEAN
Case #18
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #25
- Before: 2
- After:  0
- Status: CLEAN
Case #30
- Before: 1
- After:  0
- Status: CLEAN
Case #26
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L48-48
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     45:     private static String generateOpaqueErrorId() {
     46:         byte[] randomBytes = new byte[16];
     47:         new SecureRandom().nextBytes(randomBytes);
     48:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     49:     }
     50: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L8-48
  Reason: CRLF_INJECTION_LOGS
  Code snippet:
  ```
      5:
      6: // Externalized configuration (example)
      7: // In production, use a secure secret manager or environment variables
      8: public class Test {
      9:     // Logger instance for secure logging
     10:     private static final Logger logger = Logger.getLogger(Test.class.getName());
     11:
     12:     // Simulated sensitive data (should be retrieved securely in real scenarios)
     13:     private static final String sensitiveData = "PROTECTED_DATA_12345";
     14:
     15:     public static void main(String[] args) {
     16:         try {
     17:             System.out.println("Accessing Sensitive Data");
     18:             System.out.println(sensitiveData);
     19:
     20:             // Simulate potential failure (e.g., data access error)
     21:             if (args.length > 0 && "fail".equals(args[0])) {
     22:                 throw new SecurityException("Simulated data access failure");
     23:             }
     24:         } catch (Exception e) {
     25:             // OWASP Recommendation: Never expose stack traces to users
     26:             // CWE-209 Mitigation: Log only an opaque error ID, not exception details
     27:             String errorId = generateOpaqueErrorId();
     28:
     29:             // Log detailed error securely (stack trace only in debug mode)
     30:             if (logger.isLoggable(Level.FINE)) {
     31:                 logger.log(Level.FINE, "Exception occurred", e);
     32:             } else {
     33:                 logger.log(Level.SEVERE, "Exception occurred with error ID: " + errorId);
     34:             }
     35:
     36:             // Return generic error message to user
     37:             System.err.println("An error occurred. Please try again later.");
     38:         }
     39:     }
     40:
     41:     /**
     42:      * Generates a cryptographically secure opaque error ID
     43:      * @return Base64-encoded random bytes
     44:      */
     45:     private static String generateOpaqueErrorId() {
     46:         byte[] randomBytes = new byte[16];
     47:         new SecureRandom().nextBytes(randomBytes);
     48:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     49:     }
     50: }
  ```
Case #24
- Before: 0
- After:  0
- Status: CLEAN
Case #23
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     60:         try {
     61:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     62:             byte[] hash = digest.digest(data);
     63:             String hashStr = Base64.getEncoder().encodeToString(hash);
     64:             return hashStr.startsWith(EXPECTED_HASH_PREFIX);
     65:         } catch (NoSuchAlgorithmException e) {
     66:             logger.severe("Hashing algorithm not found: " + e.getMessage());
  ```
- [2] Scanner=horusec, CWE-0, Lines=L80-80
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     77:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     78:             byte[] randomBytes = new byte[16];
     79:             new java.security.SecureRandom().nextBytes(randomBytes);
     80:             return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     81:         } catch (NoSuchAlgorithmException e) {
     82:             logger.severe("Error generating error ID: " + e.getMessage());
     83:             return "ERR-UNKNOWN";
  ```
Case #22
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L192-192
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    189:             // Example usage - in production, these would come from validated sources
    190:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    191:             System.out.println("Command output: " + result);
    192:         } catch (Exception e) {
    193:             // In production, log errorId and send details to secure error collector
    194:             String errorId = UUID.randomUUID().toString();
    195:             System.err.println("ERROR_ID: " + errorId + " - Execution failed: An error occurred");
  ```
Case #15
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #17
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-532, Lines=L75-75
  Reason: (1/2) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.

(2/2) * Possible vulnerability detected: No Log Sensitive Information
The App logs information. Sensitive information should never be logged. For more information checkout the CWE-532 (https://cwe.mitre.org/data/definitions/532.html) advisory.
  Code snippet:
  ```
     72:                         out.println("Invalid input");
     73:                         continue;
     74:                     }
     75:                     out.println("Echo: " + Base64.getEncoder().encodeToString(inputLine.getBytes()));
     76:                 }
     77:                 clientSocket.close();
     78:             }
  ```
Case #27
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #29
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-79, Lines=L37-37
  Reason: Detected a request with potential user-input going into a OutputStream or Writer object. This bypasses any view or template environments, including HTML escaping, which may expose this application to cross-site scripting (XSS) vulnerabilities. Consider using a view technology such as JavaServer Faces (JSFs) which automatically escapes HTML views.
  Code snippet:
  ```
     34:             // Security Note: Use a template-like structure with escaped output
     35:             out.println("<html><body>");
     36:             out.println("<h1>Search Results</h1>");
     37:             out.println("<p>Your search query is: " + safeSearchQuery + "</p>");
     38:             out.println("</body></html>");
     39:         } catch (IOException e) {
     40:             // Security Note: Log error securely without exposing stack traces
  ```
Case #34
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #35
- Before: 0
- After:  0
- Status: CLEAN
Case #38
- Before: 3
- After:  0
- Status: CLEAN
Case #39
- Before: 3
- After:  0
- Status: CLEAN
Case #31
- Before: 3
- After:  0
- Status: CLEAN
Case #37
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #33
- Before: 1
- After:  5
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L116-116
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
    113:             System.out.println("Username: " + deserializedData.username);
    114:
    115:             // Never expose password - just verify if needed
    116:             if (deserializedData.verifyPassword("password123")) {
    117:                 System.out.println("Password verified successfully");
    118:             } else {
    119:                 System.out.println("Password verification failed");
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L83-83
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     80:     // Alternative deserialization method that avoids full object deserialization
     81:     public static UserInfo fromSecureBytes(byte[] data) throws IOException, ClassNotFoundException {
     82:         try (ByteArrayInputStream bis = new ByteArrayInputStream(data);
     83:              ObjectInputStream ois = new ObjectInputStream(bis)) {
     84:             String username = ois.readUTF();
     85:             String passwordHash = ois.readUTF();
     86:             String salt = ois.readUTF();
  ```
- [3] Scanner=horusec, CWE-0, Lines=L32-32
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     29:     private String generateSecureSalt() {
     30:         byte[] saltBytes = new byte[16];
     31:         new SecureRandom().nextBytes(saltBytes);
     32:         return Base64.getEncoder().encodeToString(saltBytes);
     33:     }
     34:
     35:     private String hashPassword(String password, String salt) {
  ```
- [4] Scanner=horusec, CWE-0, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     37:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     38:             md.update(Base64.getDecoder().decode(salt));
     39:             byte[] hashedBytes = md.digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     40:             return Base64.getEncoder().encodeToString(hashedBytes);
     41:         } catch (NoSuchAlgorithmException e) {
     42:             throw new RuntimeException("Critical security failure: SHA-256 not available", e);
     43:         }
  ```
- [5] Scanner=horusec, CWE-0, Lines=L38-38
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     35:     private String hashPassword(String password, String salt) {
     36:         try {
     37:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     38:             md.update(Base64.getDecoder().decode(salt));
     39:             byte[] hashedBytes = md.digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     40:             return Base64.getEncoder().encodeToString(hashedBytes);
     41:         } catch (NoSuchAlgorithmException e) {
  ```
Case #28
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, this would come from a secure form)
     17:         String username = "test' OR '1'='1"; // Vulnerable input (will be rejected)
     18:         String password = "password"; // Weak password (will be rejected)
     19:
     20:         try {
     21:             // Input validation (CWE-89 mitigation: reject invalid inputs early)
  ```
Case #36
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L45-45
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     42:         } catch (InvalidClassException | InvalidObjectException e) {
     43:             logger.warning("Deserialization validation failed: " + ERROR_ID);
     44:             ErrorCollector.sendError(e, "Main.main");
     45:         } catch (Exception e) {
     46:             String errorId = UUID.randomUUID().toString();
     47:             logger.severe("An error occurred: " + errorId);
     48:
  ```
Case #41
- Before: 3
- After:  0
- Status: CLEAN
Case #32
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #44
- Before: 0
- After:  0
- Status: CLEAN
Case #40
- Before: 0
- After:  0
- Status: CLEAN
Case #42
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #47
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L180-180
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    177:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    178:             System.out.println("Command output:");
    179:             System.out.println(result);
    180:         } catch (Exception e) {
    181:             // In production, log errorId to secure error collector
    182:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    183:         }
  ```
Case #52
- Before: 1
- After:  0
- Status: CLEAN
Case #43
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #50
- Before: 1
- After:  0
- Status: CLEAN
Case #45
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L52-52
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     49:
     50:             // Deserialize safely
     51:             ByteArrayInputStream bais = new ByteArrayInputStream(receivedData);
     52:             ObjectInputStream ois = new ObjectInputStream(bais);
     53:             Object obj = ois.readObject();
     54:
     55:             if (obj instanceof VulnerableClass) {
  ```
Case #48
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     55:             if (Boolean.getBoolean("debug")) {
     56:                 e.printStackTrace();
     57:             }
     58:         } catch (Exception e) {
     59:             String errorId = generateErrorId();
     60:             logger.severe("Unexpected error: " + errorId);
     61:             System.err.println("An error occurred");
  ```
- [2] Scanner=horusec, CWE-0, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     68:     private static String generateErrorId() {
     69:         byte[] randomBytes = new byte[32];
     70:         new SecureRandom().nextBytes(randomBytes);
     71:         return Base64.getEncoder().encodeToString(randomBytes);
     72:     }
     73: }
  ```
Case #49
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #53
- Before: 0
- After:  0
- Status: CLEAN
Case #57
- Before: 0
- After:  0
- Status: CLEAN
Case #51
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-704, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Unsafe hash equals
An attacker might be able to detect the value of the secret hash due to the exposure of comparison timing. When the functions Arrays.equals() or String.equals() are called, they will exit earlier if fewer bytes are matched. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.
  Code snippet:
  ```
     78:
     79:         try {
     80:             String inputHash = hashPassword(password, storedSalt);
     81:             return storedHash.equals(inputHash);
     82:         } catch (NoSuchAlgorithmException e) {
     83:             // Should never occur with SHA-256
     84:             return false;
  ```
Case #56
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #62
- Before: 4
- After:  0
- Status: CLEAN
Case #46
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L185-185
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    182:             // Example usage - in production, these would come from validated input
    183:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    184:             System.out.println("Command output: " + result);
    185:         } catch (Exception e) {
    186:             // In production, log with opaque error ID and send details to secure collector
    187:             String errorId = UUID.randomUUID().toString();
    188:             logErrorWithId(errorId, "Command execution error", e);
  ```
Case #54
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, result, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, result, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(result);
     83:
     84:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
     85:             // Log error with opaque ID, never expose stack traces
  ```
- [2] Scanner=horusec, CWE-0, Lines=L111-111
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    108:     private String generateOpaqueErrorId() {
    109:         byte[] randomBytes = new byte[16];
    110:         new SecureRandom().nextBytes(randomBytes);
    111:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    112:     }
    113:
    114:     /**
  ```
Case #58
- Before: 2
- After:  2
- Status: SAME

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:     public static void main(String[] args) {
     22:         // Simulated user input (in real app, these would come from a secure form)
     23:         String username = "testUser";  // Should be validated/sanitized before use
     24:         String password = "testPassword";  // Should be hashed before comparison
     25:
     26:         // Validate inputs
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L98-98
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     95:     private static String hashPassword(String password) {
     96:         // In production, use a proper password hashing library
     97:         // This is a placeholder for demonstration only
     98:         return java.util.Base64.getEncoder().encodeToString(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     99:     }
    100: }
  ```
Case #55
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation with explicit provider
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     74:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     75:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     82:
     83:             Encoder base64Encoder = Base64.getEncoder();
     84:             return base64Encoder.encodeToString(combined);
     85:         } catch (Exception e) {
     86:             String errorId = generateOpaqueErrorId();
     87:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:     private String generateOpaqueErrorId() {
     97:         byte[] randomBytes = new byte[16];
     98:         new SecureRandom().nextBytes(randomBytes);
     99:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    100:     }
    101:
    102:     /**
  ```
Case #61
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode base64 encoded key
     58:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     59:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new IOException("Invalid encryption key");
  ```
Case #66
- Before: 1
- After:  0
- Status: CLEAN
Case #59
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L39-39
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     36:                     }
     37:                 }
     38:             }
     39:         } catch (Exception e) {
     40:             String errorId = "ERR-" + java.util.UUID.randomUUID().toString();
     41:             logger.severe("Authentication error: " + errorId);
     42:             sendToErrorCollector(errorId, e);
  ```
Case #63
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L175-175
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    172:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    173:             System.out.println("Command output:");
    174:             System.out.println(result);
    175:         } catch (Exception e) {
    176:             // In production, log errorId to secure error collector
    177:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    178:         }
  ```
Case #69
- Before: 3
- After:  0
- Status: CLEAN
Case #68
- Before: 0
- After:  0
- Status: CLEAN
Case #71
- Before: 2
- After:  0
- Status: CLEAN
Case #60
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L19-19
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     16:             String jsonData = objectMapper.writeValueAsString("Hello World");
     17:
     18:             // Simulate transmission (e.g., Base64 encoding for binary-safe transport)
     19:             String encodedData = Base64.getEncoder().encodeToString(jsonData.getBytes(StandardCharsets.UTF_8));
     20:
     21:             // Deserialize from JSON (safe)
     22:             String decodedData = new String(Base64.getDecoder().decode(encodedData), StandardCharsets.UTF_8);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L22-22
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     19:             String encodedData = Base64.getEncoder().encodeToString(jsonData.getBytes(StandardCharsets.UTF_8));
     20:
     21:             // Deserialize from JSON (safe)
     22:             String decodedData = new String(Base64.getDecoder().decode(encodedData), StandardCharsets.UTF_8);
     23:             String result = objectMapper.readValue(decodedData, String.class);
     24:
     25:             System.out.println(result);
  ```
Case #64
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L186-186
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    183:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    184:             System.out.println("Command output:");
    185:             System.out.println(result);
    186:         } catch (Exception e) {
    187:             // In production, log errorId and send details to secure error collector
    188:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    189:             // Log errorId to secure logging system here
  ```
Case #72
- Before: 0
- After:  0
- Status: CLEAN
Case #65
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L186-186
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    183:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    184:             System.out.println("Command output:");
    185:             System.out.println(result);
    186:         } catch (Exception e) {
    187:             // In production, log errorId and send details to secure error collector
    188:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    189:             // Log errorId to secure logging system here
  ```
Case #67
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #77
- Before: 2
- After:  0
- Status: CLEAN
Case #81
- Before: 1
- After:  0
- Status: CLEAN
Case #70
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Validate key format using Base64 decoding attempt
     58:             byte[] keyBytes = Base64.getDecoder().decode(key);
     59:             if (keyBytes.length != 32) {
     60:                 logger.severe("Invalid encryption key format");
     61:                 throw new IOException("Invalid encryption key format");
  ```
Case #73
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #75
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #74
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #80
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #86
- Before: 1
- After:  0
- Status: CLEAN
Case #79
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #83
- Before: 0
- After:  0
- Status: CLEAN
Case #84
- Before: 1
- After:  0
- Status: CLEAN
Case #76
- Before: 0
- After:  0
- Status: CLEAN
Case #82
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L56-56
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     53:             } else {
     54:                 System.out.println("Login failed: Invalid credentials");
     55:             }
     56:         } catch (Exception e) {
     57:             // OWASP A10:2021 - Secure logging (no stack traces in production)
     58:             String errorId = "ERR-" + System.currentTimeMillis();
     59:             System.err.println("An error occurred: " + errorId);
  ```
Case #90
- Before: 1
- After:  0
- Status: CLEAN
Case #85
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #88
- Before: 0
- After:  0
- Status: CLEAN
Case #87
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     58:             System.arraycopy(key.getBytes(StandardCharsets.UTF_8), 0, keyBytes, 0, KEY_SIZE_BYTES);
     59:
     60:             // Secure AES encryption with GCM
     61:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     62:             byte[] iv = new byte[12];
     63:             new SecureRandom().nextBytes(iv);
     64:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L76-76
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     73:             System.arraycopy(iv, 0, combined, 0, iv.length);
     74:             System.arraycopy(cipherText, 0, combined, iv.length, cipherText.length);
     75:
     76:             return Base64.getEncoder().encodeToString(combined);
     77:         } catch (Exception e) {
     78:             String errorId = generateOpaqueErrorId();
     79:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L91-91
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     88:     private String generateOpaqueErrorId() {
     89:         byte[] randomBytes = new byte[16];
     90:         new SecureRandom().nextBytes(randomBytes);
     91:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     92:     }
     93:
     94:     /**
  ```
Case #78
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L86-86
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     83:             System.arraycopy(ciphertext, 0, combined, iv.length, ciphertext.length);
     84:
     85:             // Use Base64 encoding only for safe transmission, not for security
     86:             return Base64.getEncoder().encodeToString(combined);
     87:
     88:         } catch (Exception e) {
     89:             String errorId = generateOpaqueErrorId();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L102-102
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     99:     private String generateOpaqueErrorId() {
    100:         byte[] randomBytes = new byte[16];
    101:         new SecureRandom().nextBytes(randomBytes);
    102:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    103:     }
    104:
    105:     /**
  ```
Case #91
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L167-167
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    164:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    165:             System.out.println("Command output:");
    166:             System.out.println(result);
    167:         } catch (Exception e) {
    168:             // In production, log errorId to secure error collector
    169:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    170:         }
  ```
Case #97
- Before: 4
- After:  0
- Status: CLEAN
Case #89
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #94
- Before: 0
- After:  0
- Status: CLEAN
Case #92
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L47-47
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     44:                 e.printStackTrace();
     45:             }
     46:             sendErrorToCollector(errorId, e);
     47:         } catch (Exception e) {
     48:             String errorId = UUID.randomUUID().toString();
     49:             System.err.println("An error occurred: " + errorId);
     50:             if (Boolean.getBoolean("debug.mode")) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L110-110
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    107:     @Override
    108:     public String toString() {
    109:         return "VulnerableClass{" +
    110:                 "data='" + Base64.getEncoder().encodeToString(data.getBytes()) + '\'' +
    111:                 '}';
    112:     }
    113: }
  ```
Case #93
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, this would come from a secure form)
     17:         String username = "test";
     18:         String password = "test' OR '1'='1"; // Vulnerable input (will be sanitized)
     19:
     20:         // Validate inputs (allowlist: alphanumeric + common special chars)
     21:         if (!isValidInput(username) || !isValidInput(password)) {
  ```
Case #95
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L14-14
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     11:         String dbUsername = System.getenv("DB_USERNAME");
     12:         String dbPassword = System.getenv("DB_PASSWORD");
     13:         String inputUsername = "test"; // In real app, this would come from validated user input
     14:         String inputPassword = "test"; // In real app, this would come from validated user input
     15:
     16:         // Validate inputs (simplified example; use allowlists/validation rules in production)
     17:         if (!isValidUsername(inputUsername) || !isValidPassword(inputPassword)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L51-51
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     48:     // Simulate secure password hashing (use BCrypt or similar in production)
     49:     private static String hashPassword(String password) {
     50:         // In production, use a strong hashing algorithm like BCrypt, Argon2, or PBKDF2
     51:         return java.util.Base64.getEncoder().encodeToString(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     52:     }
     53:
     54:     // Validate username (example allowlist; adjust per requirements)
  ```
Case #96
- Before: 4
- After:  0
- Status: CLEAN
Case #98
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:
     22:         // Example user input (in real application, validate and sanitize all inputs)
     23:         String username = "testUser";  // Should come from validated user input
     24:         String password = "testPassword";  // Should come from validated user input
     25:
     26:         // Validate input (basic example; enhance with regex or allowlist in production)
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #99
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L171-171
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    168:             // Example usage - in production, inputs would come from secure sources
    169:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    170:             System.out.println("Command output: " + result);
    171:         } catch (Exception e) {
    172:             // In production, log errorId and send details to secure error collector
    173:             String errorId = UUID.randomUUID().toString();
    174:             executor.logError(errorId, "Execution failed", e);
  ```
Case #102
- Before: 0
- After:  0
- Status: CLEAN
Case #100
- Before: 3
- After:  2
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L47-47
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     44:             int exitCode = process.waitFor();
     45:             System.out.println("Command exited with code: " + exitCode);
     46:
     47:         } catch (Exception e) {
     48:             // 5. Secure error handling (CWE-209)
     49:             String errorId = generateOpaqueErrorId(e);
     50:             if (DEBUG_MODE) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L94-94
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     91:         try {
     92:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     93:             byte[] hash = digest.digest(e.getMessage().getBytes());
     94:             return Base64.getEncoder().encodeToString(hash);
     95:         } catch (Exception ex) {
     96:             return "ERROR_ID_GENERATION_FAILED";
     97:         }
  ```
Case #104
- Before: 0
- After:  0
- Status: CLEAN
Case #103
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #101
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(iv, 0, combined, 0, iv.length);
     82:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     83:
     84:             return Base64.getEncoder().encodeToString(combined);
     85:         } catch (Exception e) {
     86:             String errorId = generateOpaqueErrorId();
     87:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:     private String generateOpaqueErrorId() {
     97:         byte[] randomBytes = new byte[16];
     98:         new SecureRandom().nextBytes(randomBytes);
     99:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    100:     }
    101:
    102:     /**
  ```
Case #105
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, these would come from a secure form)
     17:         String username = "test";
     18:         String password = "test'; DROP TABLE users; --";
     19:
     20:         // Validate inputs (allowlist: alphanumeric + common special chars)
     21:         if (!isValidInput(username) || !isValidInput(password)) {
  ```
Case #106
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L19-19
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     16:             oos.writeObject("safeData");  // Avoid untrusted input
     17:
     18:             try (ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
     19:                  ObjectInputStream ois = new ObjectInputStream(bais)) {
     20:                 // Set allowed class to prevent arbitrary deserialization
     21:                 Class<?> allowedClass = Class.forName(ALLOWED_CLASS);
     22:                 ois.setObjectStreamClass(allowedClass);
  ```
Case #107
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #109
- Before: 1
- After:  0
- Status: CLEAN
Case #108
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #110
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L25-25
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     22:
     23:             // Deserialize safely with validation
     24:             ByteArrayInputStream bin = new ByteArrayInputStream(bos.toByteArray());
     25:             try (ObjectInputStream ois = new ObjectInputStream(bin)) {
     26:                 ois.enableResolveProxy(false);
     27:                 ois.setObjectInputFilter((desc, depth) -> {
     28:                     for (Class<?> allowedClass : ALLOWLISTED_CLASSES) {
  ```
Case #111
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #114
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #113
- Before: 2
- After:  0
- Status: CLEAN
Case #112
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L192-192
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    189:             // Example usage - in production, these would come from validated sources
    190:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    191:             System.out.println("Command output: " + result);
    192:         } catch (Exception e) {
    193:             // In production, log errorId and send details to secure error collector
    194:             String errorId = UUID.randomUUID().toString();
    195:             System.err.println("ERROR_ID: " + errorId + " - Execution failed: An error occurred");
  ```
Case #115
- Before: 0
- After:  0
- Status: CLEAN
Case #120
- Before: 4
- After:  0
- Status: CLEAN
Case #116
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #117
- Before: 0
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-276, Lines=L86-86
  Reason: (1/1) * Possible vulnerability detected: Prevent Write sensitive information in tmp file
App creates temp file. Sensitive information should never be written into a temp file. For more information checkout the CWE-276 (https://cwe.mitre.org/data/definitions/276.html) advisory.
  Code snippet:
  ```
     83:             processBuilder.directory(Paths.get("/tmp").toFile());
     84:
     85:             // Set resource limits
     86:             processBuilder.redirectOutput(ProcessBuilder.Redirect.to(Files.createTempFile("output-", ".log").toFile()));
     87:             processBuilder.redirectError(ProcessBuilder.Redirect.to(Files.createTempFile("error-", ".log").toFile()));
     88:
     89:             Process process = processBuilder.start();
  ```
- [2] Scanner=horusec, CWE-276, Lines=L87-87
  Reason: (1/1) * Possible vulnerability detected: Prevent Write sensitive information in tmp file
App creates temp file. Sensitive information should never be written into a temp file. For more information checkout the CWE-276 (https://cwe.mitre.org/data/definitions/276.html) advisory.
  Code snippet:
  ```
     84:
     85:             // Set resource limits
     86:             processBuilder.redirectOutput(ProcessBuilder.Redirect.to(Files.createTempFile("output-", ".log").toFile()));
     87:             processBuilder.redirectError(ProcessBuilder.Redirect.to(Files.createTempFile("error-", ".log").toFile()));
     88:
     89:             Process process = processBuilder.start();
     90:
  ```
Case #123
- Before: 0
- After:  0
- Status: CLEAN
Case #125
- Before: 2
- After:  0
- Status: CLEAN
Case #118
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             // In production, log errorId to secure error collector
    159:             String errorId = UUID.randomUUID().toString();
    160:             System.err.println("ERROR_ID: " + errorId + ", Message: An error occurred");
  ```
Case #129
- Before: 1
- After:  0
- Status: CLEAN
Case #128
- Before: 2
- After:  0
- Status: CLEAN
Case #119
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #121
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #124
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(iv, 0, combined, 0, iv.length);
     82:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     83:
     84:             return Base64.getEncoder().encodeToString(combined);
     85:         } catch (Exception e) {
     86:             String errorId = generateOpaqueErrorId();
     87:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:     private String generateOpaqueErrorId() {
     97:         byte[] randomBytes = new byte[16];
     98:         new SecureRandom().nextBytes(randomBytes);
     99:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    100:     }
    101:
    102:     /**
  ```
Case #126
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #122
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L75-75
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     72:                     if (!ALLOWLIST.contains(className)) {
     73:                         throw new InvalidClassException("Unauthorized deserialization attempt", className);
     74:                     }
     75:                     return Class.forName(className, false, ClassLoader.getSystemClassLoader());
     76:                 }
     77:             };
     78:             Object obj = ois.readObject();
  ```
Case #127
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #135
- Before: 2
- After:  0
- Status: CLEAN
Case #138
- Before: 1
- After:  0
- Status: CLEAN
Case #132
- Before: 1
- After:  1
- Status: SAME

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     59:             };
     60:             Object obj = ois.readObject();
     61:             System.out.println(obj);
     62:         } catch (Exception e) {
     63:             String errorId = UUID.randomUUID().toString();
     64:             logError(errorId, "Error during deserialization", e);
     65:             System.err.println("An error occurred. Error ID: " + errorId);
  ```
Case #130
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L34-34
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     31:             byte[] data = bos.toByteArray();
     32:
     33:             // Security Fix: Safe deserialization with class whitelisting
     34:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data))) {
     35:                 // Read and validate first object (ignored in this example)
     36:                 Object firstObj = ois.readObject();
     37:                 validateDeserializedObject(firstObj);
  ```
Case #133
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L76-76
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     73:         }
     74:
     75:         try {
     76:             Class.forName(JDBC_DRIVER);
     77:             return DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
     78:         } catch (ClassNotFoundException e) {
     79:             throw new SQLException("Database driver not found", e);
  ```
Case #134
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L65-65
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     62:             if (Boolean.getBoolean("debug.mode")) {
     63:                 e.printStackTrace();
     64:             }
     65:         } catch (Exception e) {
     66:             String errorId = generateErrorId();
     67:             logError(errorId, "Unexpected error during deserialization");
     68:             System.err.println("Deserialization error: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     85:             byte[] randomBytes = new byte[16];
     86:             new SecureRandom().nextBytes(randomBytes);
     87:             byte[] hash = digest.digest(ERROR_PREFIX.getBytes(java.nio.charset.StandardCharsets.UTF_8), randomBytes, 0, 16);
     88:             return Base64.getEncoder().encodeToString(hash);
     89:         } catch (NoSuchAlgorithmException e) {
     90:             // This should never happen as SHA-256 is a standard algorithm
     91:             return ERROR_PREFIX;
  ```
Case #139
- Before: 2
- After:  0
- Status: CLEAN
Case #136
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: An error occurred");
    179:         }
  ```
Case #137
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    179:         }
  ```
Case #144
- Before: 1
- After:  0
- Status: CLEAN
Case #142
- Before: 0
- After:  0
- Status: CLEAN
Case #143
- Before: 2
- After:  0
- Status: CLEAN
Case #131
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L57-57
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     54:             errorId = generateErrorId();
     55:             sendToSecureErrorCollector(errorId, e);
     56:             System.err.println("Security violation occurred: " + errorId);
     57:         } catch (Exception e) {
     58:             errorId = generateErrorId();
     59:             sendToSecureErrorCollector(errorId, e);
     60:             System.err.println("An error occurred: " + errorId);
  ```
Case #140
- Before: 3
- After:  3
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L35-35
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     32:             try {
     33:                 // In production, use a secure HMAC implementation with a secret key
     34:                 MessageDigest md = MessageDigest.getInstance("SHA-256");
     35:                 return Base64.getEncoder().encodeToString(md.digest(data));
     36:             } catch (NoSuchAlgorithmException e) {
     37:                 throw new RuntimeException("HMAC algorithm not available", e);
     38:             }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L107-107
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    104:         try {
    105:             // In production, use a secure HMAC implementation with a secret key
    106:             MessageDigest md = MessageDigest.getInstance("SHA-256");
    107:             return Base64.getEncoder().encodeToString(md.digest(data));
    108:         } catch (NoSuchAlgorithmException e) {
    109:             throw new RuntimeException("HMAC algorithm not available", e);
    110:         }
  ```
- [3] Scanner=horusec, CWE-0, Lines=L118-118
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    115:             MessageDigest md = MessageDigest.getInstance("SHA-256");
    116:             md.update(Thread.currentThread().getStackTrace()[2].getClassName().getBytes());
    117:             md.update(String.valueOf(System.currentTimeMillis()).getBytes());
    118:             return Base64.getEncoder().encodeToString(md.digest());
    119:         } catch (NoSuchAlgorithmException e) {
    120:             return "ERR_UNKNOWN";
    121:         }
  ```
Case #141
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L38-38
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     35:             //     throw new SecurityException("Data integrity check failed");
     36:             // }
     37:
     38:             ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData));
     39:             Object obj = ois.readObject();
     40:
     41:             // Validate deserialized object type
  ```
- [2] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             long timestamp = System.currentTimeMillis();
     82:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     83:             byte[] hash = digest.digest(Long.toString(timestamp).getBytes());
     84:             return Base64.getEncoder().encodeToString(hash);
     85:         } catch (NoSuchAlgorithmException e) {
     86:             // This should never happen in practice
     87:             return "ERROR_ID_GENERATION_FAILED";
  ```
Case #149
- Before: 0
- After:  0
- Status: CLEAN
Case #145
- Before: 0
- After:  0
- Status: CLEAN
Case #146
- Before: 0
- After:  0
- Status: CLEAN
Case #150
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #157
- Before: 4
- After:  0
- Status: CLEAN
Case #152
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #153
- Before: 1
- After:  3
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L28-28
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     25:             }
     26:             pb.unread(header);
     27:
     28:             try (ObjectInputStream ois = new ObjectInputStream(pb)) {
     29:                 // Read class descriptor first to validate before full deserialization
     30:                 ObjectStreamClass desc = ois.readClassDescriptor();
     31:                 if (!isClassAllowed(desc.getName())) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     56:             byte[] randomBytes = new byte[16];
     57:             new SecureRandom().nextBytes(randomBytes);
     58:             byte[] digest = md.digest(randomBytes);
     59:             return Base64.getEncoder().encodeToString(digest);
     60:         } catch (NoSuchAlgorithmException ex) {
     61:             byte[] randomBytes = new byte[16];
     62:             new SecureRandom().nextBytes(randomBytes);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     60:         } catch (NoSuchAlgorithmException ex) {
     61:             byte[] randomBytes = new byte[16];
     62:             new SecureRandom().nextBytes(randomBytes);
     63:             return Base64.getEncoder().encodeToString(randomBytes); // Fallback
     64:         }
     65:     }
     66:
  ```
Case #155
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-330, Lines=L6-6
  Reason: (1/1) * Possible vulnerability detected: Insecure Random Number Generator
The App uses an insecure Random Number Generator. For more information checkout the CWE-330 (https://cwe.mitre.org/data/definitions/330.html) advisory.
  Code snippet:
  ```
      3:
      4: /**
      5:  * SecureRandomExample demonstrates the use of a cryptographically strong random number generator.
      6:  * This replaces the insecure java.util.Random with java.security.SecureRandom to mitigate CWE-330.
      7:  *
      8:  * Security Improvements:
      9:  * 1. Uses SecureRandom (cryptographically strong PRNG) instead of Random (pseudo-random, predictable)
  ```
Case #148
- Before: 0
- After:  0
- Status: CLEAN
Case #156
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #151
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #147
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     37:             Object obj = ois.readObject();
     38:             ois.close();
     39:             System.out.println("Deserialized object: " + obj);
     40:         } catch (Exception e) {
     41:             // Security Note: Never expose stack traces to users
     42:             System.err.println("An error occurred during deserialization (Error ID: " + generateErrorId() + ")");
     43:             // In production, send e.toString() to a secure error collector
  ```
- [2] Scanner=horusec, CWE-0, Lines=L54-54
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     51:             // In production, use a proper HMAC implementation (e.g., HmacSHA256)
     52:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     53:             byte[] digest = md.digest(data);
     54:             return Base64.getEncoder().encodeToString(digest);
     55:         } catch (NoSuchAlgorithmException e) {
     56:             throw new RuntimeException("Cryptographic algorithm not available", e);
     57:         }
  ```
Case #154
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L86-86
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     83:             new SecureRandom().nextBytes(iv);
     84:
     85:             // AES-GCM encryption implementation with proper key handling
     86:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     87:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     88:             cipher.init(Cipher.ENCRYPT_MODE, secretKey, spec);
     89:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:             System.arraycopy(iv, 0, combined, 0, iv.length);
     95:             System.arraycopy(cipherText, 0, combined, iv.length, cipherText.length);
     96:
     97:             return Base64.getEncoder().encodeToString(combined);
     98:         } catch (GeneralSecurityException | IOException e) {
     99:             String errorId = generateOpaqueErrorId();
    100:             logger.log(Level.SEVERE, "Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L112-112
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    109:     private String generateOpaqueErrorId() {
    110:         byte[] randomBytes = new byte[16];
    111:         new SecureRandom().nextBytes(randomBytes);
    112:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    113:     }
    114:
    115:     /**
  ```
Case #163
- Before: 2
- After:  0
- Status: CLEAN
Case #164
- Before: 2
- After:  0
- Status: CLEAN
Case #161
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L177-177
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output:");
    176:             System.out.println(result);
    177:         } catch (Exception e) {
    178:             // In production, log errorId to secure error collector
    179:             System.err.println("Error: An error occurred");
    180:         }
  ```
Case #159
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L42-42
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     39:         } catch (InvalidClassException | SecurityException e) {
     40:             logger.severe("Deserialization error: " + ERROR_ID);
     41:             ErrorCollector.sendError(e, ERROR_ID);
     42:         } catch (Exception e) {
     43:             String errorId = ERROR_ID;
     44:             if (e instanceof IOException) {
     45:                 errorId = "ERR-IO-002";
  ```
Case #162
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L177-177
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output:");
    176:             System.out.println(result);
    177:         } catch (Exception e) {
    178:             // In production, log errorId to secure error collector
    179:             System.err.println("Error: An error occurred");
    180:         }
  ```
Case #160
- Before: 0
- After:  0
- Status: CLEAN
Case #166
- Before: 0
- After:  0
- Status: CLEAN
Case #170
- Before: 2
- After:  0
- Status: CLEAN
Case #167
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #165
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     59:         try {
     60:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     61:             byte[] hashBytes = digest.digest(data);
     62:             return "sha256:" + Base64.getEncoder().encodeToString(hashBytes);
     63:         } catch (NoSuchAlgorithmException e) {
     64:             throw new RuntimeException("SHA-256 algorithm not available", e);
     65:         }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L73-73
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     70:         try {
     71:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     72:             byte[] hashBytes = digest.digest(message.getBytes());
     73:             return Base64.getEncoder().encodeToString(hashBytes).substring(0, 10);
     74:         } catch (NoSuchAlgorithmException e) {
     75:             return "ERR_UNKNOWN";
     76:         }
  ```
Case #175
- Before: 1
- After:  0
- Status: CLEAN
Case #169
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #158
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     85:             System.arraycopy(encryptedBytes, 0, output, iv.length, encryptedBytes.length);
     86:             System.arraycopy(tag, 0, output, iv.length + encryptedBytes.length, tag.length);
     87:
     88:             return Base64.getEncoder().encodeToString(output);
     89:         } catch (Exception e) {
     90:             String errorId = generateOpaqueErrorId();
     91:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L103-103
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    100:     private String generateOpaqueErrorId() {
    101:         byte[] randomBytes = new byte[16];
    102:         new SecureRandom().nextBytes(randomBytes);
    103:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    104:     }
    105:
    106:     /**
  ```
Case #172
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L167-167
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    164:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    165:             System.out.println("Command output:");
    166:             System.out.println(result);
    167:         } catch (Exception e) {
    168:             // In production, log errorId to secure error collector
    169:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    170:         }
  ```
Case #168
- Before: 3
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #171
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L39-39
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     36:         } catch (InvalidClassException | IOException e) {
     37:             logger.warning("Invalid data received: " + ERROR_ID);
     38:             sendErrorToCollector(e);
     39:         } catch (Exception e) {
     40:             // Production-safe error handling
     41:             logger.severe("Unexpected error: " + ERROR_ID);
     42:             // Send detailed error to secure collector in production
  ```
Case #173
- Before: 3
- After:  0
- Status: CLEAN
Case #176
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L170-170
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    167:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    168:             System.out.println("Command output:");
    169:             System.out.println(result);
    170:         } catch (Exception e) {
    171:             // In production, log errorId to secure error collector
    172:             System.err.println("Error: An error occurred");
    173:         }
  ```
Case #183
- Before: 2
- After:  0
- Status: CLEAN
Case #174
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-72
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:     // Allowlist of permitted commands (secure default)
      7:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      8:
      9:     // Absolute path to shell (never use PATH lookup)
     10:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     11:
     12:     public static void main(String[] args) {
     13:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     14:             System.out.println("Enter your command (allowed: echo, date, whoami):");
     15:             String input = reader.readLine().trim();
     16:
     17:             if (input == null || input.isEmpty()) {
     18:                 System.err.println("Error: Empty input");
     19:                 return;
     20:             }
     21:
     22:             // Validate command against allowlist
     23:             String[] parts = input.split("\\s+", 2);
     24:             if (parts.length < 1 || !ALLOWED_COMMANDS.contains(parts[0])) {
     25:                 System.err.println("Error: Command not allowed");
     26:                 return;
     27:             }
     28:
     29:             // Prevent command chaining with special characters
     30:             if (Pattern.compile("[;&|]").matcher(input).find()) {
     31:                 System.err.println("Error: Invalid command syntax");
     32:                 return;
     33:             }
     34:
     35:             // Use ProcessBuilder with argument array (no string concatenation)
     36:             ProcessBuilder processBuilder = new ProcessBuilder(
     37:                 ABSOLUTE_SHELL_PATH, "sh", "-c", input
     38:             );
     39:
     40:             // Secure defaults: no inheritance of environment variables
     41:             processBuilder.environment().clear();
     42:
     43:             // Optional: set working directory to a safe location
     44:             // processBuilder.directory(new File("/safe/working/dir"));
     45:
     46:             Process process = processBuilder.start();
     47:
     48:             // Read output streams to prevent deadlocks
     49:             try (BufferedReader readerOut = new BufferedReader(
     50:                     new InputStreamReader(process.getInputStream()));
     51:                  BufferedReader readerErr = new BufferedReader(
     52:                      new InputStreamReader(process.getErrorStream()))) {
     53:
     54:                 String line;
     55:                 while ((line = readerOut.readLine()) != null) {
     56:                     System.out.println(line);
     57:                 }
     58:                 while ((line = readerErr.readLine()) != null) {
     59:                     System.err.println(line);
     60:                 }
     61:             }
     62:
     63:             int exitCode = process.waitFor();
     64:             System.out.println("Command exited with code: " + exitCode);
     65:
     66:         } catch (IOException | InterruptedException e) {
     67:             // Log errorId to secure error collector in production
     68:             String errorId = UUID.randomUUID().toString();
     69:             System.err.println("An error occurred (ID: " + errorId + ")");
     70:             // In development: e.printStackTrace();
     71:         }
     72:     }
     73: }
  ```
Case #181
- Before: 2
- After:  0
- Status: CLEAN
Case #179
- Before: 0
- After:  0
- Status: CLEAN
Case #178
- Before: 2
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L116-116
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
    113:
    114:     @Override
    115:     protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
    116:         if (!ALLOWED_CLASSES.contains(Class.forName(desc.getName(), false, ClassLoader.getSystemClassLoader()))) {
    117:             throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
    118:         }
    119:         return super.resolveClass(desc);
  ```
- [2] Scanner=horusec, CWE-502, Lines=L17-17
  Reason: (1/1) * Possible vulnerability detected: Object deserialization is used
Object deserialization of untrusted data can lead to remote code execution, if there is a class in classpath that allows the trigger of malicious operation. For more information checkout the CWE-502 (https://cwe.mitre.org/data/definitions/502.html) advisory.
  Code snippet:
  ```
     14:  * 4. Uses logging framework with opaque error IDs
     15:  * 5. Restricts deserialization to known safe types
     16:  */
     17: public class SecureMain {
     18:     private static final Logger logger = Logger.getLogger(SecureMain.class.getName());
     19:     private static final String HMAC_SECRET = retrieveSecret("DESERIALIZATION_HMAC_SECRET"); // Externalized secret
     20:     private static final String EXPECTED_HMAC = "expected-hmac-signature"; // Should be dynamically generated in real use
  ```
- [3] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:         MessageDigest digest = MessageDigest.getInstance("SHA-256");
     80:         digest.update(secret.getBytes());
     81:         byte[] hash = digest.digest(data);
     82:         return Base64.getEncoder().encodeToString(hash);
     83:     }
     84:
     85:     /**
  ```
Case #185
- Before: 0
- After:  0
- Status: CLEAN
Case #187
- Before: 1
- After:  0
- Status: CLEAN
Case #188
- Before: 0
- After:  0
- Status: CLEAN
Case #180
- Before: 0
- After:  5
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     59:             new SecureRandom().nextBytes(iv);
     60:
     61:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     62:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     63:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     64:             SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
     65:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-330, Lines=L123-123
  Reason: (1/1) * Possible vulnerability detected: Insecure Random Number Generator
The App uses an insecure Random Number Generator. For more information checkout the CWE-330 (https://cwe.mitre.org/data/definitions/330.html) advisory.
  Code snippet:
  ```
    120:         } catch (Exception e) {
    121:             // Fallback to non-cryptographic random if SecureRandom fails
    122:             // This should never happen in production
    123:             return String.format("%08x", (new java.util.Random()).nextLong());
    124:         }
    125:     }
    126:
  ```
- [3] Scanner=semgrep, CWE-330, Lines=L123-123
  Reason: Detected use of the functions `Math.random()` or `java.util.Random()`. These are both not cryptographically strong random number generators (RNGs). If you are using these RNGs to create passwords or secret tokens, use `java.security.SecureRandom` instead.
  Code snippet:
  ```
    120:         } catch (Exception e) {
    121:             // Fallback to non-cryptographic random if SecureRandom fails
    122:             // This should never happen in production
    123:             return String.format("%08x", (new java.util.Random()).nextLong());
    124:         }
    125:     }
    126:
  ```
- [4] Scanner=horusec, CWE-0, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     71:             System.arraycopy(iv, 0, combined, 0, iv.length);
     72:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     73:
     74:             return Base64.getEncoder().encodeToString(combined);
     75:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeySpecException |
     76:                  IllegalBlockSizeException | BadPaddingException e) {
     77:             String errorId = generateOpaqueErrorId();
  ```
- [5] Scanner=horusec, CWE-0, Lines=L119-119
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    116:             byte[] randomBytes = new byte[16];
    117:             SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
    118:             random.nextBytes(randomBytes);
    119:             return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    120:         } catch (Exception e) {
    121:             // Fallback to non-cryptographic random if SecureRandom fails
    122:             // This should never happen in production
  ```
Case #182
- Before: 3
- After:  0
- Status: CLEAN
Case #184
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     56:             System.arraycopy(key.getBytes(StandardCharsets.UTF_8), 0, keyBytes, 0, KEY_SIZE_BYTES);
     57:
     58:             // Secure AES encryption with GCM
     59:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     60:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, new byte[12]); // Random IV will be generated
     61:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     62:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L73-73
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     70:             System.arraycopy(iv, 0, combined, 0, iv.length);
     71:             System.arraycopy(cipherText, 0, combined, iv.length, cipherText.length);
     72:
     73:             return Base64.getEncoder().encodeToString(combined);
     74:         } catch (Exception e) {
     75:             String errorId = generateOpaqueErrorId();
     76:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     85:     private String generateOpaqueErrorId() {
     86:         byte[] randomBytes = new byte[16];
     87:         new SecureRandom().nextBytes(randomBytes);
     88:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     89:     }
     90:
     91:     /**
  ```
Case #177
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #191
- Before: 0
- After:  0
- Status: CLEAN
Case #186
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #195
- Before: 0
- After:  0
- Status: CLEAN
Case #190
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L183-183
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    180:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    181:             System.out.println("Command output:");
    182:             System.out.println(result);
    183:         } catch (Exception e) {
    184:             // In production, log errorId to secure error collector
    185:             System.err.println("Error: An error occurred");
    186:         }
  ```
Case #197
- Before: 0
- After:  0
- Status: CLEAN
Case #194
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #192
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #201
- Before: 1
- After:  0
- Status: CLEAN
Case #193
- Before: 4
- After:  0
- Status: CLEAN
Case #198
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L85-85
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     82:             @Override
     83:             protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
     84:                 try {
     85:                     Class<?> clazz = Class.forName(desc.getName(), false, getClass().getClassLoader());
     86:                     if (!DESERIALIZATION_WHITELIST.contains(clazz)) {
     87:                         String errorId = UUID.randomUUID().toString();
     88:                         logger.warning("SECURITY-ERROR: " + errorId);
  ```
Case #205
- Before: 1
- After:  0
- Status: CLEAN
Case #189
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     65:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     66:
     67:             // Use Base64 encoding only for safe transport, not for security (CWE-0: Insecure Data Encoding)
     68:             return Base64.getEncoder().encodeToString(combined);
     69:         } catch (Exception e) {
     70:             String errorId = generateOpaqueErrorId();
     71:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:         byte[] randomBytes = new byte[16];
     82:         new SecureRandom().nextBytes(randomBytes);
     83:         // Use URL-safe Base64 encoding without padding (CWE-0: Insecure Data Encoding)
     84:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     85:     }
     86:
     87:     /**
  ```
Case #200
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     55:             random.nextBytes(randomBytes);
     56:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     57:             byte[] hash = digest.digest(randomBytes);
     58:             return ERROR_LOG_PREFIX + Base64.getEncoder().encodeToString(hash).replace('+', '-').replace('/', '_').replace('=', '');
     59:         } catch (NoSuchAlgorithmException e) {
     60:             // This should never happen as SHA-256 is a standard algorithm
     61:             return ERROR_LOG_PREFIX + "FALLBACK";
  ```
Case #203
- Before: 0
- After:  0
- Status: CLEAN
Case #208
- Before: 2
- After:  0
- Status: CLEAN
Case #209
- Before: 4
- After:  0
- Status: CLEAN
Case #202
- Before: 0
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L183-183
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    180:             // Example usage - should be externalized in production
    181:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    182:             System.out.println("Command output:\n" + result);
    183:         } catch (Exception e) {
    184:             // Never expose exception details to users
    185:             System.err.println("Execution failed: An error occurred");
    186:             // In production, log the error with an opaque ID
  ```
- [2] Scanner=horusec, CWE-0, Lines=L159-159
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    156:         // Use secure random generator with Base64 encoding for compactness
    157:         byte[] randomBytes = new byte[32]; // Increased size for better uniqueness
    158:         new SecureRandom().nextBytes(randomBytes);
    159:         return Base64.getEncoder().withoutPadding().encodeToString(randomBytes);
    160:     }
    161:
    162:     /**
  ```
Case #204
- Before: 4
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L47-47
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     44:                 e.printStackTrace();
     45:             }
     46:             System.err.println("An error occurred. Error ID: " + errorId);
     47:         } catch (Exception e) {
     48:             String errorId = generateErrorId();
     49:             logger.severe("Unexpected error occurred. Error ID: " + errorId);
     50:             if (DEBUG_MODE) {
  ```
Case #196
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #199
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     59:
     60:             // Send error details to a secure error collector in production
     61:             // ErrorCollector.logError(errorId, e);
     62:         } catch (Exception e) {
     63:             // Catch-all for unexpected exceptions
     64:             String errorId = UUID.randomUUID().toString();
     65:             System.err.println("Error occurred: " + errorId);
  ```
Case #215
- Before: 0
- After:  0
- Status: CLEAN
Case #207
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(ciphertext, 0, output, iv.length, ciphertext.length);
     80:
     81:             // CWE-0: Base64 encoding is not encryption, but used here for safe transport
     82:             return Base64.getEncoder().encodeToString(output);
     83:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
     84:                  InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException | AEADBadTagException e) {
     85:             String errorId = generateOpaqueErrorId();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L102-102
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     99:     private String generateOpaqueErrorId() {
    100:         byte[] randomBytes = new byte[16];
    101:         new SecureRandom().nextBytes(randomBytes);
    102:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    103:     }
    104:
    105:     /**
  ```
Case #211
- Before: 4
- After:  0
- Status: CLEAN
Case #212
- Before: 0
- After:  0
- Status: CLEAN
Case #206
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #219
- Before: 1
- After:  0
- Status: CLEAN
Case #213
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (NoSuchAlgorithmException | InvalidKeySpecException | IOException e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L101-101
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     98:     private String generateOpaqueErrorId() {
     99:         byte[] randomBytes = new byte[16];
    100:         new SecureRandom().nextBytes(randomBytes);
    101:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    102:     }
    103:
    104:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #220
- Before: 4
- After:  0
- Status: CLEAN
Case #216
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #214
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation with explicit provider
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode base64 encoded key
     58:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     59:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new IOException("Invalid encryption key");
  ```
Case #217
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L51-51
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     48:             }
     49:             logger.severe("Error occurred: " + errorId);
     50:             System.err.println("An error occurred");
     51:         } catch (Exception e) {
     52:             String errorId = ERROR_LOG_PREFIX + Long.toHexString(ERROR_COUNTER.incrementAndGet());
     53:             if (System.getProperty("debug.mode", "false").equals("true")) {
     54:                 StringWriter sw = new StringWriter();
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L25-25
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     22:             }
     23:
     24:             ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
     25:             try (ObjectInputStream ois = new ObjectInputStream(bais)) {
     26:                 ois.setObjectInputFilter((desc, depth) -> {
     27:                     if (desc.getSerialClass() != null && !ALLOWED_CLASS.equals(desc.getSerialClass().getName())) {
     28:                         return ObjectInputFilter.Status.REJECTED;
  ```
Case #221
- Before: 0
- After:  0
- Status: CLEAN
Case #218
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             String errorId = UUID.randomUUID().toString();
    159:             executor.logError(errorId, "Exception occurred during command execution", e);
    160:             System.err.println("Error: An error occurred");
  ```
Case #210
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L178-178
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    175:             // Example usage - should use externalized inputs in production
    176:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    177:             System.out.println("Command output: " + result);
    178:         } catch (Exception e) {
    179:             // In production, log errorId and send details to secure error collector
    180:             String errorId = UUID.randomUUID().toString();
    181:             logError(errorId, "Execution failed");
  ```
Case #226
- Before: 0
- After:  0
- Status: CLEAN
Case #222
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L67-67
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     64:             }
     65:
     66:             // Send detailed error to secure error collector (not shown here)
     67:         } catch (Exception e) {
     68:             // Handle other exceptions generically
     69:             logger.severe("Deserialization error: " + ERROR_ID);
     70:
  ```
Case #227
- Before: 0
- After:  0
- Status: CLEAN
Case #223
- Before: 3
- After:  0
- Status: CLEAN
Case #229
- Before: 0
- After:  0
- Status: CLEAN
Case #228
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L27-27
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     24:                         throw new InvalidClassException("Unauthorized deserialization attempt", className);
     25:                     }
     26:                     try {
     27:                         Class<?> clazz = Class.forName(className, false, ClassLoader.getSystemClassLoader());
     28:                         if (clazz == null) {
     29:                             throw new ClassNotFoundException("Class not found: " + className);
     30:                         }
  ```
Case #231
- Before: 2
- After:  0
- Status: CLEAN
Case #224
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     60:                     }
     61:                 } catch (IOException | InterruptedException e) {
     62:                     logger.severe("Error handling client: " + e.getMessage());
     63:                     String errorId = Base64.getEncoder().encodeToString(e.getClass().getName().getBytes());
     64:                     logger.fine("Error details: " + errorId);
     65:                 }
     66:             }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L69-69
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     66:             }
     67:         } catch (IOException e) {
     68:             logger.severe("Failed to start secure server: " + e.getMessage());
     69:             String errorId = Base64.getEncoder().encodeToString(e.getClass().getName().getBytes());
     70:             logger.fine("Error details: " + errorId);
     71:         }
     72:     }
  ```
Case #225
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     80:
     81:             // Use Base64 encoding only for safe transmission, not for security
     82:             return Base64.getEncoder().encodeToString(combined);
     83:
     84:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
     85:             // Log error with opaque ID, never stack trace
  ```
- [2] Scanner=horusec, CWE-0, Lines=L169-169
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    166:     private String generateOpaqueErrorId() {
    167:         byte[] randomBytes = new byte[16];
    168:         new SecureRandom().nextBytes(randomBytes);
    169:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    170:     }
    171: }
    172:
  ```
Case #230
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L32-32
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     29:                 }
     30:                 try {
     31:                     ClassLoader contextClassLoader = SecureDeserializationExample.class.getClassLoader();
     32:                     return Class.forName(className, false, contextClassLoader);
     33:                 } catch (ClassNotFoundException e) {
     34:                     String errorId = "ERR-DESERIAL-002";
     35:                     ErrorCollector.logError(errorId, "Class not found during deserialization");
  ```
Case #235
- Before: 0
- After:  0
- Status: CLEAN
Case #237
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L15-15
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     12:             User user = new User("admin", "123456"); // Note: In real code, use secure credential handling
     13:             // Simulate a successful operation (no exception should be thrown here)
     14:             System.out.println("User created successfully");
     15:         } catch (Exception e) {
     16:             // OWASP Recommendation: Never expose stack traces to users
     17:             // CWE-209 Mitigation: Avoid leaking sensitive information in error messages
     18:             String errorId = UUID.randomUUID().toString();
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-25
  Reason: CRLF_INJECTION_LOGS
  Code snippet:
  ```
      2: import java.util.UUID;
      3:
      4: // Security-focused class for user management
      5: public class Test {
      6:     // Use a secure logging framework instead of printStackTrace()
      7:     private static final Logger logger = Logger.getLogger(Test.class.getName());
      8:
      9:     public static void main(String[] args) {
     10:         try {
     11:             // Simulate user creation (in real applications, credentials should be hashed)
     12:             User user = new User("admin", "123456"); // Note: In real code, use secure credential handling
     13:             // Simulate a successful operation (no exception should be thrown here)
     14:             System.out.println("User created successfully");
     15:         } catch (Exception e) {
     16:             // OWASP Recommendation: Never expose stack traces to users
     17:             // CWE-209 Mitigation: Avoid leaking sensitive information in error messages
     18:             String errorId = UUID.randomUUID().toString();
     19:             logger.severe("Error occurred: " + errorId); // Log only an opaque error ID
     20:             logger.throwing(Test.class.getName(), "main", e); // Log exception details securely
     21:
     22:             // Return a generic error message to the user
     23:             System.err.println("An error occurred. Please try again later.");
     24:         }
     25:     }
     26: }
     27:
     28: // Simplified User class for demonstration
  ```
Case #232
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #240
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #233
- Before: 3
- After:  3
- Status: SAME

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L59-96
  Reason: OBJECT_DESERIALIZATION
  Code snippet:
  ```
     56:     }
     57: }
     58:
     59: public class Test {
     60:     public static void main(String[] args) {
     61:         try {
     62:             // Simulate secure serialization (if needed)
     63:             ByteArrayOutputStream bos = new ByteArrayOutputStream();
     64:             ObjectOutputStream oos = new ObjectOutputStream(bos);
     65:             SecureClass payload = new SecureClass("calc");
     66:             oos.writeObject(payload);
     67:             oos.flush();
     68:
     69:             // Deserialization is disabled in SecureClass, so this will throw
     70:             // In real use, consider using a safer serialization format like JSON
     71:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()))) {
     72:                 ois.readObject(); // Will throw InvalidClassException
     73:             } catch (InvalidClassException e) {
     74:                 // Expected behavior: log securely
     75:                 String errorId = generateOpaqueErrorId();
     76:                 System.err.println("Deserialization blocked for security. Error ID: " + errorId);
     77:             }
     78:
     79:         } catch (Exception e) {
     80:             // Secure error handling: log only an opaque error ID
     81:             String errorId = generateOpaqueErrorId();
     82:             System.err.println("An error occurred. Error ID: " + errorId);
     83:             // In production, send error details to a secure error collector
     84:         }
     85:     }
     86:
     87:     // Generates a secure, opaque error ID for logging
     88:     private static String generateOpaqueErrorId() {
     89:         try {
     90:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     91:             byte[] randomBytes = new byte[16];
     92:             new java.security.SecureRandom().nextBytes(randomBytes);
     93:             return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     94:         } catch (NoSuchAlgorithmException e) {
     95:             // Fallback in case SHA-256 is unavailable (should never happen)
     96:             return java.util.UUID.randomUUID().toString();
     97:         }
     98:     }
     99: }
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L71-71
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     68:
     69:             // Deserialization is disabled in SecureClass, so this will throw
     70:             // In real use, consider using a safer serialization format like JSON
     71:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()))) {
     72:                 ois.readObject(); // Will throw InvalidClassException
     73:             } catch (InvalidClassException e) {
     74:                 // Expected behavior: log securely
  ```
- [3] Scanner=horusec, CWE-0, Lines=L93-93
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     90:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     91:             byte[] randomBytes = new byte[16];
     92:             new java.security.SecureRandom().nextBytes(randomBytes);
     93:             return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     94:         } catch (NoSuchAlgorithmException e) {
     95:             // Fallback in case SHA-256 is unavailable (should never happen)
     96:             return java.util.UUID.randomUUID().toString();
  ```
Case #239
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-532, Lines=L56-56
  Reason: (1/2) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.

(2/2) * Possible vulnerability detected: No Log Sensitive Information
The App logs information. Sensitive information should never be logged. For more information checkout the CWE-532 (https://cwe.mitre.org/data/definitions/532.html) advisory.
  Code snippet:
  ```
     53:             System.arraycopy(authTag, 0, encryptedData, iv.length + ciphertext.length, authTag.length);
     54:
     55:             // Output Base64-encoded encrypted data (for demonstration only)
     56:             System.out.println(Base64.getEncoder().encodeToString(encryptedData));
     57:
     58:         } catch (Exception e) {
     59:             // Log error with opaque ID (never expose stack traces in production)
  ```
Case #241
- Before: 3
- After:  0
- Status: CLEAN
Case #236
- Before: 1
- After:  4
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L56-56
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     53:     private static void initializeSecureUsers() {
     54:         try {
     55:             // Simulated secure password hashes (in production, these would be retrieved from a secrets manager)
     56:             userPasswordHashes.put("admin", hashPassword("secureAdminPass123!"));
     57:             userPasswordHashes.put("user1", hashPassword("user1SecurePass456!"));
     58:             userPasswordHashes.put("user2", hashPassword("user2StrongPass789!"));
     59:         } catch (Exception e) {
  ```
- [2] Scanner=horusec, CWE-798, Lines=L57-57
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     54:         try {
     55:             // Simulated secure password hashes (in production, these would be retrieved from a secrets manager)
     56:             userPasswordHashes.put("admin", hashPassword("secureAdminPass123!"));
     57:             userPasswordHashes.put("user1", hashPassword("user1SecurePass456!"));
     58:             userPasswordHashes.put("user2", hashPassword("user2StrongPass789!"));
     59:         } catch (Exception e) {
     60:             // In production, log error securely and fail gracefully
  ```
- [3] Scanner=horusec, CWE-798, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     55:             // Simulated secure password hashes (in production, these would be retrieved from a secrets manager)
     56:             userPasswordHashes.put("admin", hashPassword("secureAdminPass123!"));
     57:             userPasswordHashes.put("user1", hashPassword("user1SecurePass456!"));
     58:             userPasswordHashes.put("user2", hashPassword("user2StrongPass789!"));
     59:         } catch (Exception e) {
     60:             // In production, log error securely and fail gracefully
     61:             System.err.println("Error initializing secure users: " + e.getMessage());
  ```
- [4] Scanner=horusec, CWE-0, Lines=L80-80
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     77:         PBEKeySpec spec = new PBEKeySpec(chars, salt, ITERATIONS, KEY_LENGTH);
     78:         SecretKeyFactory skf = SecretKeyFactory.getInstance(ALGORITHM);
     79:         byte[] hash = skf.generateSecret(spec).getEncoded();
     80:         return Base64.getEncoder().encodeToString(hash);
     81:     }
     82:
     83:     /**
  ```
Case #238
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     58:             new SecureRandom().nextBytes(iv);
     59:
     60:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     61:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     62:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     63:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     64:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     71:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     72:
     73:             // Use URL-safe encoding (CWE-0: Base64 encoding without URL safety)
     74:             return Base64.getUrlEncoder().withoutPadding().encodeToString(combined);
     75:
     76:         } catch (Exception e) {
     77:             // Secure error handling (CWE-523: Information Exposure)
  ```
- [3] Scanner=horusec, CWE-0, Lines=L91-91
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     88:     private String generateOpaqueErrorId() {
     89:         byte[] randomBytes = new byte[16];
     90:         new SecureRandom().nextBytes(randomBytes);
     91:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     92:     }
     93:
     94:     /**
  ```
Case #234
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #242
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #248
- Before: 0
- After:  0
- Status: CLEAN
Case #249
- Before: 0
- After:  0
- Status: CLEAN
Case #244
- Before: 0
- After:  0
- Status: CLEAN
Case #250
- Before: 0
- After:  0
- Status: CLEAN
Case #251
- Before: 2
- After:  0
- Status: CLEAN
Case #246
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #243
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation with explicit provider
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode base64 encoded key
     58:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     59:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new IOException("Invalid encryption key");
  ```
Case #259
- Before: 2
- After:  0
- Status: CLEAN
Case #247
- Before: 3
- After:  0
- Status: CLEAN
Case #253
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #256
- Before: 1
- After:  3
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L20-20
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     17:     // Hardcoded paths should be replaced with proper configuration in production
     18:     private static final List<String> ALLOWED_PROTOCOLS = Arrays.asList("TLSv1.2", "TLSv1.3");
     19:     private static final String KEYSTORE_PATH = "/etc/ssl/keystore.p12";
     20:     private static final String KEYSTORE_PASSWORD = "changeit";
     21:     private static final String KEY_PASSWORD = "keypass";
     22:     private static final List<String> ALLOWED_KEYSTORE_PATHS = Arrays.asList("/etc/ssl/keystore.p12");
     23:
  ```
- [2] Scanner=horusec, CWE-798, Lines=L21-21
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     18:     private static final List<String> ALLOWED_PROTOCOLS = Arrays.asList("TLSv1.2", "TLSv1.3");
     19:     private static final String KEYSTORE_PATH = "/etc/ssl/keystore.p12";
     20:     private static final String KEYSTORE_PASSWORD = "changeit";
     21:     private static final String KEY_PASSWORD = "keypass";
     22:     private static final List<String> ALLOWED_KEYSTORE_PATHS = Arrays.asList("/etc/ssl/keystore.p12");
     23:
     24:     public static void main(String[] args) {
  ```
- [3] Scanner=semgrep, CWE-326, Lines=L44-44
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     41:             keyManagerFactory.init(keyStore, KEY_PASSWORD.toCharArray());
     42:
     43:             // Create SSL context with strong protocol
     44:             SSLContext sslContext = SSLContext.getInstance("TLS");
     45:             sslContext.init(keyManagerFactory.getKeyManagers(), null, null);
     46:
     47:             // Create SSL server socket with proper configuration
  ```
Case #254
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L52-52
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     49:             System.out.println("Deserialized object: " + obj);
     50:         } catch (IOException | ClassNotFoundException | NoSuchAlgorithmException | SecurityException e) {
     51:             // Log only an opaque error ID in production
     52:             String errorId = "ERR-" + Base64.getEncoder().encodeToString(MessageDigest.getInstance("SHA-256").digest(e.getMessage().getBytes()));
     53:             System.err.println("An error occurred: " + errorId);
     54:             // In production, send e to a secure error collector
     55:         }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L77-77
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     74:         // In production, use a proper HMAC implementation (e.g., HmacSHA256)
     75:         MessageDigest md = MessageDigest.getInstance("SHA-256");
     76:         md.update(key.getBytes());
     77:         return Base64.getEncoder().encodeToString(md.digest(data));
     78:     }
     79:
     80:     // HMAC verification
  ```
Case #258
- Before: 0
- After:  0
- Status: CLEAN
Case #245
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:     public static void main(String[] args) {
     22:         // Simulate user input (in real app, read from secure input source)
     23:         String username = "admin";  // Should come from user input
     24:         String password = "secureP@ss123";  // Should come from user input
     25:
     26:         // Validate inputs
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #255
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L77-77
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     74:                 throw new IOException("Working directory is not safe");
     75:             }
     76:             processBuilder.directory(safeDir.toFile());
     77:         } catch (Exception e) {
     78:             String errorId = UUID.randomUUID().toString();
     79:             logError(errorId, "Failed to set working directory");
     80:             throw new IOException("Failed to set working directory");
  ```
Case #257
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #252
- Before: 0
- After:  0
- Status: CLEAN
Case #265
- Before: 0
- After:  0
- Status: CLEAN
Case #261
- Before: 0
- After:  0
- Status: CLEAN
Case #266
- Before: 1
- After:  0
- Status: CLEAN
Case #268
- Before: 1
- After:  0
- Status: CLEAN
Case #260
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L69-69
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     66:             if (Boolean.getBoolean("debug")) {
     67:                 e.printStackTrace();
     68:             }
     69:         } catch (Exception e) {
     70:             // Handle generic exceptions
     71:             String errorId = generateSecureErrorId();
     72:             System.err.println(String.format(ERROR_LOG_MESSAGE, errorId));
  ```
Case #262
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #263
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L66-66
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     63:             Key secret = new SecretKeySpec(tmp.getEncoded(), "AES");
     64:
     65:             // Secure AES-GCM encryption with explicit IV and authentication tag
     66:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     67:             byte[] iv = new byte[12]; // Standard GCM IV size
     68:             new SecureRandom().nextBytes(iv);
     69:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L80-80
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     77:             System.arraycopy(iv, 0, combined, 0, iv.length);
     78:             System.arraycopy(cipherText, 0, combined, iv.length, cipherText.length);
     79:
     80:             return Base64.getEncoder().encodeToString(combined);
     81:         } catch (Exception e) {
     82:             String errorId = generateOpaqueErrorId();
     83:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L105-105
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    102:     private String generateOpaqueErrorId() {
    103:         byte[] randomBytes = new byte[16];
    104:         new SecureRandom().nextBytes(randomBytes);
    105:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    106:     }
    107:
    108:     /**
  ```
Case #264
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Validate key format using Base64 decoding attempt
     58:             byte[] keyBytes = Base64.getDecoder().decode(key);
     59:             if (keyBytes.length != 32) {
     60:                 logger.severe("Invalid encryption key format");
     61:                 throw new IOException("Invalid encryption key format");
  ```
Case #274
- Before: 1
- After:  0
- Status: CLEAN
Case #270
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #272
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #267
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     77:
  ```
Case #276
- Before: 1
- After:  0
- Status: CLEAN
Case #275
- Before: 0
- After:  0
- Status: CLEAN
Case #269
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L16-16
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     13:     public static void main(String[] args) {
     14:         // Simulated user input - in real application would come from validated source
     15:         String username = "test'; DROP TABLE users; --"; // Vulnerable input (demonstration only)
     16:         String password = "password";
     17:
     18:         // Validate and sanitize inputs
     19:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-209, Lines=L50-50
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     47:             }
     48:             // In production, send error details to secure error collector
     49:             sendToErrorCollector(errorId, e);
     50:         } catch (Exception e) {
     51:             String errorId = "ERR-" + System.currentTimeMillis();
     52:             logger.severe("Application error: " + errorId);
     53:             if (DEBUG_MODE) {
  ```
Case #271
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L77-77
  Reason: (1/1) * Possible vulnerability detected: No Default  Hash
This App uses  Hash Code. It"s a weak hash function and should never be used in Secure Crypto Implementation. For more information checkout the CWE-327 (https://cwe.mitre.org/data/definitions/327.html) advisory.
  Code snippet:
  ```
     74:     }
     75:
     76:     @Override
     77:     public int hashCode() {
     78:         return hash;
     79:     }
     80: }
  ```
Case #273
- Before: 1
- After:  0
- Status: CLEAN
Case #278
- Before: 0
- After:  0
- Status: CLEAN
Case #283
- Before: 0
- After:  0
- Status: CLEAN
Case #282
- Before: 1
- After:  0
- Status: CLEAN
Case #285
- Before: 0
- After:  0
- Status: CLEAN
Case #277
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #281
- Before: 0
- After:  0
- Status: CLEAN
Case #280
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode base64 encoded key
     58:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     59:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new IOException("Invalid encryption key");
  ```
Case #279
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L192-192
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    189:             // Example usage - in production, these would come from validated sources
    190:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    191:             System.out.println("Command output: " + result);
    192:         } catch (Exception e) {
    193:             // In production, log errorId and send details to secure error collector
    194:             String errorId = UUID.randomUUID().toString();
    195:             System.err.println("ERROR_ID: " + errorId + " - Execution failed: An error occurred");
  ```
Case #286
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #287
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L214-214
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    211:             // Example usage - should be replaced with actual use case
    212:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    213:             System.out.println("Command output:\n" + result);
    214:         } catch (Exception e) {
    215:             // In production, log errorId and send details to secure error collector
    216:             String errorId = UUID.randomUUID().toString();
    217:             System.err.println("Error ID: " + errorId + ", Message: An error occurred");
  ```
- [2] Scanner=horusec, CWE-0, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    161:     private String generateErrorId() {
    162:         byte[] randomBytes = new byte[16];
    163:         new SecureRandom().nextBytes(randomBytes);
    164:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    165:     }
    166:
    167:     /**
  ```
Case #293
- Before: 1
- After:  0
- Status: CLEAN
Case #284
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     85:             new SecureRandom().nextBytes(iv);
     86:
     87:             // AES-GCM encryption implementation with explicit provider
     88:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     89:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     90:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     91:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:             System.arraycopy(iv, 0, combined, 0, iv.length);
     97:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     98:
     99:             return Base64.getEncoder().encodeToString(combined);
    100:         } catch (KeyStoreException | IOException | NoSuchAlgorithmException |
    101:                  CertificateException | UnrecoverableEntryException | Exception e) {
    102:             String errorId = generateOpaqueErrorId();
  ```
- [3] Scanner=horusec, CWE-0, Lines=L130-130
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    127:     private String generateOpaqueErrorId() {
    128:         byte[] randomBytes = new byte[16];
    129:         new SecureRandom().nextBytes(randomBytes);
    130:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    131:     }
    132:
    133:     /**
  ```
Case #289
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #290
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:
     73:             // Secure AES-GCM encryption implementation
     74:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     76:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     78:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L86-86
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     83:             System.arraycopy(iv, 0, combined, 0, iv.length);
     84:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     85:
     86:             return Base64.getEncoder().encodeToString(combined);
     87:         } catch (Exception e) {
     88:             String errorId = generateOpaqueErrorId();
     89:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L101-101
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     98:     private String generateOpaqueErrorId() {
     99:         byte[] randomBytes = new byte[16];
    100:         new SecureRandom().nextBytes(randomBytes);
    101:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    102:     }
    103:
    104:     /**
  ```
Case #291
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(iv, 0, combined, 0, iv.length);
     82:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     83:
     84:             return Base64.getEncoder().encodeToString(combined);
     85:         } catch (Exception e) {
     86:             String errorId = generateOpaqueErrorId();
     87:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:     private String generateOpaqueErrorId() {
     97:         byte[] randomBytes = new byte[16];
     98:         new SecureRandom().nextBytes(randomBytes);
     99:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    100:     }
    101:
    102:     /**
  ```
Case #292
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L85-85
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     82:             System.arraycopy(iv, 0, combined, 0, iv.length);
     83:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     84:
     85:             return Base64.getEncoder().encodeToString(combined);
     86:
     87:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
     88:                  IllegalBlockSizeException | BadPaddingException e) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L116-116
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    113:     private String generateOpaqueErrorId() {
    114:         byte[] randomBytes = new byte[16];
    115:         new SecureRandom().nextBytes(randomBytes);
    116:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    117:     }
    118:
    119:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     58:             }
     59:
     60:             // Decode and validate key size
     61:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     62:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     63:                 logger.severe("Encryption key has invalid length");
     64:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #294
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #300
- Before: 1
- After:  0
- Status: CLEAN
Case #295
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L60-60
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     57:             new SecureRandom().nextBytes(iv);
     58:
     59:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     60:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     61:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     62:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "AES");
     63:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L73-73
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     70:             System.arraycopy(cipherText, 0, output, iv.length, cipherText.length);
     71:
     72:             // CWE-0: Base64 encoding is not encryption, but used here for safe transport
     73:             return Base64.getEncoder().encodeToString(output);
     74:         } catch (AEADBadTagException | Exception e) {
     75:             String errorId = generateOpaqueErrorId();
     76:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     85:     private String generateOpaqueErrorId() {
     86:         byte[] randomBytes = new byte[16];
     87:         new SecureRandom().nextBytes(randomBytes);
     88:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     89:     }
     90:
     91:     /**
  ```
Case #288
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L194-194
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    191:             // Example usage - in production, these would come from validated sources
    192:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    193:             System.out.println("Command output: " + result);
    194:         } catch (Exception e) {
    195:             // In production, log errorId and send details to secure error collector
    196:             String errorId = UUID.randomUUID().toString();
    197:             System.err.println("ERROR_ID: " + errorId + " - Execution failed: An error occurred");
  ```
Case #296
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-319, Lines=L28-28
  Reason: Detected use of a Java socket that is not encrypted. As a result, the traffic could be read by an attacker intercepting the network traffic. Use an SSLSocket created by 'SSLSocketFactory' or 'SSLServerSocketFactory' instead.
  Code snippet:
  ```
     25:             SecurityManager security = new SecurityManager();
     26:             System.setSecurityManager(security);
     27:
     28:             try (ServerSocket serverSocket = new ServerSocket(0)) {
     29:                 serverSocket.setReuseAddress(true);
     30:                 serverSocket.bind(new InetSocketAddress(InetAddress.getByName("127.0.0.1"), 8080));
     31:                 String errorId = UUID.randomUUID().toString();
  ```
Case #297
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L159-159
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    156:             // Example secret retrieval
    157:             String apiKey = executor.getSecureSecret("PRODUCTION_API_KEY");
    158:             System.out.println("API Key retrieved successfully");
    159:         } catch (Exception e) {
    160:             // Catch-all for unexpected exceptions
    161:             String errorId = UUID.randomUUID().toString();
    162:             logError(errorId, "Unexpected error");
  ```
Case #298
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    162:             // Example secret retrieval
    163:             String apiKey = executor.getSecureSecret("PRODUCTION_API_KEY");
    164:             System.out.println("API Key retrieved successfully");
    165:         } catch (Exception e) {
    166:             // In production, log errorId to secure error collector
    167:             String errorId = UUID.randomUUID().toString();
    168:             System.err.println("Error occurred: " + errorId);
  ```
Case #301
- Before: 0
- After:  0
- Status: CLEAN
Case #303
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #302
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #305
- Before: 0
- After:  0
- Status: CLEAN
Case #304
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #307
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #299
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #306
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:         // Set working directory to a safe location
     66:         try {
     67:             processBuilder.directory(Paths.get("/tmp").toFile());
     68:         } catch (Exception e) {
     69:             String errorId = UUID.randomUUID().toString();
     70:             logError(errorId, "Failed to set working directory");
     71:             throw new IOException("Failed to set working directory");
  ```
Case #310
- Before: 0
- After:  0
- Status: CLEAN
Case #308
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L174-174
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    171:             if (isDebugMode()) {
    172:                 e.printStackTrace();
    173:             }
    174:         } catch (Exception e) {
    175:             // Catch-all for unexpected exceptions
    176:             String errorId = UUID.randomUUID().toString();
    177:             logErrorToCollector(errorId, e);
  ```
Case #315
- Before: 0
- After:  0
- Status: CLEAN
Case #312
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error: An error occurred");
    179:         }
  ```
Case #314
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #309
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #311
- Before: 1
- After:  0
- Status: CLEAN
Case #316
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #313
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation with explicit provider
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
Case #318
- Before: 1
- After:  0
- Status: CLEAN
Case #323
- Before: 0
- After:  0
- Status: CLEAN
Case #317
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L219-219
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    216:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    217:             System.out.println("Command output:");
    218:             System.out.println(result);
    219:         } catch (Exception e) {
    220:             String errorId = generateOpaqueErrorIdStatic();
    221:             System.err.println("Command execution failed: " + errorId);
    222:             // In production, send error details to secure error collector
  ```
Case #322
- Before: 3
- After:  0
- Status: CLEAN
Case #320
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L31-31
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     28:             // Generate opaque error ID
     29:             byte[] errorIdBytes = new byte[16];
     30:             new SecureRandom().nextBytes(errorIdBytes);
     31:             String errorId = Base64.getUrlEncoder().withoutPadding().encodeToString(errorIdBytes);
     32:
     33:             // Send detailed error to secure error collector (not shown here)
     34:             System.err.println("Error creating file: " + errorId);
  ```
Case #324
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #325
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L47-47
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     44:         ObjectInputFilter allowOnlyVulnerableClass = ObjectInputFilter.Config.createFilter("!*");
     45:
     46:         ByteArrayInputStream bin = new ByteArrayInputStream(bos.toByteArray());
     47:         try (ObjectInputStream ois = new ObjectInputStream(bin)) {
     48:             ois.setObjectInputFilter(ObjectInputFilter.Config.createFilter("com.example.VulnerableClass"));
     49:             Object obj = ois.readObject();
     50:             if (obj instanceof VulnerableClass) {
  ```
- [2] Scanner=semgrep, CWE-704, Lines=L65-83
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     62:         }
     63:     }
     64:
     65:     private static String generateSecureErrorId(String baseId) {
     66:         try {
     67:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     68:             byte[] randomBytes = new byte[16];
     69:             new SecureRandom().nextBytes(randomBytes);
     70:             byte[] combined = (baseId + new String(randomBytes)).getBytes();
     71:             byte[] hash = digest.digest(combined);
     72:             StringBuilder hexString = new StringBuilder(64);
     73:             for (byte b : hash) {
     74:                 String hex = Integer.toHexString(0xff & b);
     75:                 if (hex.length() == 1) hexString.append('0');
     76:                 hexString.append(hex);
     77:             }
     78:             return hexString.toString();
     79:         } catch (NoSuchAlgorithmException e) {
     80:             // This should never happen with SHA-256
     81:             return "FATAL-ERROR";
     82:         }
     83:     }
     84: }
  ```
Case #327
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-502, Lines=L9-9
  Reason: (1/1) * Possible vulnerability detected: Object deserialization is used
Object deserialization of untrusted data can lead to remote code execution, if there is a class in classpath that allows the trigger of malicious operation. For more information checkout the CWE-502 (https://cwe.mitre.org/data/definitions/502.html) advisory.
  Code snippet:
  ```
      6: import java.util.Objects;
      7: import java.util.Set;
      8:
      9: public class SecureClass implements Serializable {
     10:     private static final long serialVersionUID = 1L;
     11:     private static final Set<String> ALLOWED_COMMANDS = Set.of("true", "id");
     12:     private static final Path TRUE_PATH = Paths.get("/usr/bin/true");
  ```
Case #326
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #331
- Before: 4
- After:  0
- Status: CLEAN
Case #328
- Before: 0
- After:  0
- Status: CLEAN
Case #329
- Before: 3
- After:  0
- Status: CLEAN
Case #334
- Before: 1
- After:  0
- Status: CLEAN
Case #321
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L23-23
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     20:             byte[] bytes = byteOut.toByteArray();
     21:
     22:             // Safe deserialization with validation
     23:             try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes))) {
     24:                 Class<?> allowedClass = Class.forName(ALLOWED_CLASS);
     25:                 Object obj = in.readObject();
     26:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L50-50
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     47:             random.nextBytes(errorIdBytes);
     48:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     49:             byte[] hash = digest.digest(errorIdBytes);
     50:             return Base64.getEncoder().encodeToString(hash).replace('+', '-').replace('/', '_').replace('=', '');
     51:         } catch (NoSuchAlgorithmException e) {
     52:             // This should never happen with SHA-256
     53:             return "FATAL_ERROR";
  ```
Case #319
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L91-91
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     88:             System.arraycopy(iv, 0, combined, 0, iv.length);
     89:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     90:
     91:             return Base64.getEncoder().encodeToString(combined);
     92:         } catch (GeneralSecurityException e) {
     93:             String errorId = generateOpaqueErrorId();
     94:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L106-106
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    103:     private String generateOpaqueErrorId() {
    104:         byte[] randomBytes = new byte[16];
    105:         new SecureRandom().nextBytes(randomBytes);
    106:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    107:     }
    108:
    109:     /**
  ```
Case #335
- Before: 2
- After:  0
- Status: CLEAN
Case #330
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-326, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: Classes should not be loaded dynamically
Dynamically loaded classes could contain malicious code executed by a static class initializer. I.E. you wouldn't even have to instantiate or explicitly invoke methods on such classes to be vulnerable to an attack. For more information checkout the CWE-326 (https://cwe.mitre.org/data/definitions/326.html) advisory
  Code snippet:
  ```
     80:                 throw new IllegalStateException("Invalid command state");
     81:             }
     82:             pb.redirectErrorStream(true);
     83:             pb.directory(new File(System.getProperty("java.io.tmpdir")));
     84:             Process process = pb.start();
     85:
     86:             try (BufferedReader reader = new BufferedReader(
  ```
- [2] Scanner=semgrep, CWE-470, Lines=L30-30
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     27:                         throw new InvalidClassException("Unauthorized deserialization attempt", className);
     28:                     }
     29:                     ClassLoader loader = SecureDeserializationExample.class.getClassLoader();
     30:                     return Class.forName(className, false, loader);
     31:                 }
     32:             };
     33:
  ```
Case #336
- Before: 1
- After:  0
- Status: CLEAN
Case #338
- Before: 2
- After:  0
- Status: CLEAN
Case #333
- Before: 0
- After:  0
- Status: CLEAN
Case #340
- Before: 1
- After:  0
- Status: CLEAN
Case #332
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     79:             System.arraycopy(iv, 0, combined, 0, iv.length);
     80:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     81:
     82:             return Base64.getEncoder().encodeToString(combined);
     83:         } catch (Exception e) {
     84:             String errorId = generateOpaqueErrorId();
     85:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:     private String generateOpaqueErrorId() {
     95:         byte[] randomBytes = new byte[16];
     96:         new SecureRandom().nextBytes(randomBytes);
     97:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     98:     }
     99:
    100:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #337
- Before: 0
- After:  0
- Status: CLEAN
Case #339
- Before: 0
- After:  0
- Status: CLEAN
Case #342
- Before: 0
- After:  0
- Status: CLEAN
Case #349
- Before: 0
- After:  0
- Status: CLEAN
Case #341
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode base64 encoded key
     58:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     59:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new IOException("Invalid encryption key");
  ```
Case #347
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #350
- Before: 3
- After:  0
- Status: CLEAN
Case #344
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L197-197
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    194:             // Example usage - in production, inputs would come from validated sources
    195:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    196:             System.out.println("Command output: " + result);
    197:         } catch (Exception e) {
    198:             String errorId = UUID.randomUUID().toString();
    199:             // In production, log errorId and send details to secure error collector
    200:             System.err.println("ERROR [" + errorId + "]: An error occurred");
  ```
Case #348
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L42-42
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     39:
     40:                 new Thread(() -> handleClient(socket)).start();
     41:             }
     42:         } catch (Exception e) {
     43:             String errorId = "ERR-" + System.currentTimeMillis();
     44:             System.err.println("Server error: " + errorId);
     45:             logErrorToSecureCollector(errorId, e);
  ```
Case #346
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-704, Lines=L145-145
  Reason: (1/1) * Possible vulnerability detected: Bad hexadecimal concatenation
When converting a byte array containing a hash signature to a human readable string, a conversion mistake can be made if the array is read byte by byte. The following sample illustrates the use of the method Integer.toHexString() which will trim any leading zeroes from each byte of the computed hash value. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.
  Code snippet:
  ```
    142:             for (String allowedPath : ALLOWED_COMMAND_PATHS) {
    143:                 if (allowedPath.endsWith(command)) {
    144:                     Path path = Paths.get(allowedPath).toAbsolutePath().normalize();
    145:                     if (Files.exists(path) && Files.isExecutable(path) &&
    146:                         !path.startsWith(".") && // Prevent path traversal
    147:                         path.toString().contains("..")) { // Prevent path traversal
    148:                         return path;
  ```
- [2] Scanner=horusec, CWE-209, Lines=L153-153
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    150:                 }
    151:             }
    152:             return null;
    153:         } catch (Exception e) {
    154:             String errorId = UUID.randomUUID().toString();
    155:             logError(errorId, "Error validating command path", e);
    156:             return null;
  ```
Case #343
- Before: 2
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L60-60
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     57:             byte[] encryptedText = cipher.doFinal(plaintext.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     58:
     59:             // 6. Output encrypted data (Base64 encoded for readability)
     60:             String encryptedBase64 = Base64.getEncoder().encodeToString(encryptedText);
     61:             System.out.println("Encrypted: " + encryptedBase64);
     62:             System.out.println("IV: " + Base64.getEncoder().encodeToString(iv));
     63:
  ```
- [2] Scanner=horusec, CWE-532, Lines=L62-62
  Reason: (1/2) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.

(2/2) * Possible vulnerability detected: No Log Sensitive Information
The App logs information. Sensitive information should never be logged. For more information checkout the CWE-532 (https://cwe.mitre.org/data/definitions/532.html) advisory.
  Code snippet:
  ```
     59:             // 6. Output encrypted data (Base64 encoded for readability)
     60:             String encryptedBase64 = Base64.getEncoder().encodeToString(encryptedText);
     61:             System.out.println("Encrypted: " + encryptedBase64);
     62:             System.out.println("IV: " + Base64.getEncoder().encodeToString(iv));
     63:
     64:         } catch (Exception e) {
     65:             // 7. Secure error handling: log opaque ID, show generic message
  ```
- [3] Scanner=horusec, CWE-0, Lines=L43-43
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     40:             }
     41:
     42:             // 2. Decode Base64 secret key
     43:             byte[] decodedKey = Base64.getDecoder().decode(secretKeyBase64);
     44:             Key key = new SecretKeySpec(decodedKey, "AES");
     45:
     46:             // 3. Generate random IV
  ```
Case #353
- Before: 0
- After:  0
- Status: CLEAN
Case #351
- Before: 0
- After:  0
- Status: CLEAN
Case #345
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L146-146
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
    143:         byte[] iv = new byte[GCM_IV_LENGTH];
    144:         random.nextBytes(iv);
    145:
    146:         Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
    147:         GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
    148:         SecretKeySpec keySpec = new SecretKeySpec(ENCRYPTION_KEY, "AES");
    149:         cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L158-158
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    155:         System.arraycopy(iv, 0, combined, 0, iv.length);
    156:         System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
    157:
    158:         return Base64.getEncoder().encodeToString(combined);
    159:     }
    160:
    161:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L174-174
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
    171:         }
    172:
    173:         // In production, consider using a secret manager like HashiCorp Vault or AWS Secrets Manager
    174:         return Base64.getDecoder().decode(keyValue);
    175:     }
    176:
    177:     /**
  ```
Case #356
- Before: 0
- After:  0
- Status: CLEAN
Case #357
- Before: 0
- After:  0
- Status: CLEAN
Case #352
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L73-73
  Reason: (1/1) * Possible vulnerability detected:  Crypto import
 Crypto import
  Code snippet:
  ```
     70:             }
     71:
     72:             Key key = keyStore.getKey(ENCRYPTION_KEY_ALIAS, keystorePass.toCharArray());
     73:             if (!(key instanceof javax.crypto.SecretKey) || key.getEncoded().length != 32) { // AES-256 requires 32-byte key
     74:                 logger.severe("Invalid encryption key type or length");
     75:                 throw new SecurityException("Invalid encryption key type or length");
     76:             }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:             System.arraycopy(cipherText, 0, output, iv.length, cipherText.length);
     94:
     95:             // Use Base64 encoding only for safe transport, not for security
     96:             return Base64.getEncoder().encodeToString(output);
     97:
     98:         } catch (Exception e) {
     99:             // Log error with opaque ID, never expose stack traces
  ```
- [3] Scanner=horusec, CWE-0, Lines=L122-122
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    119:     private String generateOpaqueErrorId() {
    120:         byte[] randomBytes = new byte[16];
    121:         new SecureRandom().nextBytes(randomBytes);
    122:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    123:     }
    124:
    125:     /**
  ```
Case #354
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:             new SecureRandom().nextBytes(iv);
     73:
     74:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     76:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     77:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     78:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L86-86
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     83:             System.arraycopy(iv, 0, output, 0, iv.length);
     84:             System.arraycopy(encryptedBytes, 0, output, iv.length, encryptedBytes.length);
     85:
     86:             return Base64.getEncoder().encodeToString(output);
     87:         } catch (GeneralSecurityException | IOException e) {
     88:             String errorId = generateOpaqueErrorId();
     89:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L102-102
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     99:         try {
    100:             byte[] randomBytes = new byte[16];
    101:             new SecureRandom().nextBytes(randomBytes);
    102:             return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    103:         } catch (Exception e) {
    104:             // Fallback for critical error logging
    105:             return "FALLBACK_ERROR_ID";
  ```
Case #358
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L37-37
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     34:             }
     35:         } catch (InvalidClassException | IOException e) {
     36:             handleError(e);
     37:         } catch (Exception e) {
     38:             handleError(e);
     39:         }
     40:     }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L45-45
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     42:     private static void handleError(Exception e) {
     43:         byte[] errorIdBytes = new byte[16];
     44:         new SecureRandom().nextBytes(errorIdBytes);
     45:         String opaqueId = Base64.getUrlEncoder().withoutPadding().encodeToString(errorIdBytes);
     46:
     47:         if (DEBUG_MODE) {
     48:             e.printStackTrace();
  ```
Case #363
- Before: 0
- After:  0
- Status: CLEAN
Case #359
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L43-43
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     40:                 System.err.println("An error occurred: " + errorId);
     41:                 sendToErrorCollector(new SecurityException("Deserialization blocked: Untrusted payload."), errorId);
     42:             }
     43:         } catch (Exception e) {
     44:             String errorId = "ERROR_ID_" + generateErrorId();
     45:             System.err.println("An error occurred: " + errorId);
     46:             sendToErrorCollector(e, errorId);
  ```
- [2] Scanner=horusec, CWE-502, Lines=L10-10
  Reason: (1/1) * Possible vulnerability detected: Object deserialization is used
Object deserialization of untrusted data can lead to remote code execution, if there is a class in classpath that allows the trigger of malicious operation. For more information checkout the CWE-502 (https://cwe.mitre.org/data/definitions/502.html) advisory.
  Code snippet:
  ```
      7: import java.util.Objects;
      8: import java.util.Set;
      9:
     10: public class SecureDeserialization {
     11:     private static final Set<String> ALLOWED_CLASSES = Set.of("java.lang.String");
     12:     private static final byte[] EXPECTED_HASH = new byte[0]; // Precomputed SHA-256 hash of "test" string
     13:
  ```
Case #355
- Before: 3
- After:  4
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L49-49
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     46:             } else {
     47:                 logger.warning("Deserialization failed: " + VALIDATION_ERROR_ID);
     48:             }
     49:         } catch (Exception e) {
     50:             String errorId = ERROR_ID;
     51:             logger.severe("Deserialization failed: " + errorId);
     52:             AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
  ```
- [2] Scanner=horusec, CWE-704, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Bad hexadecimal concatenation
When converting a byte array containing a hash signature to a human readable string, a conversion mistake can be made if the array is read byte by byte. The following sample illustrates the use of the method Integer.toHexString() which will trim any leading zeroes from each byte of the computed hash value. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.
  Code snippet:
  ```
     68:         }
     69:
     70:         // Check for STREAM_MAGIC numbers at the beginning
     71:         if (data.length < 2 || (data[0] & 0xFF) != 0xAC || (data[1] & 0xFF) != 0xED) {
     72:             return false;
     73:         }
     74:
  ```
- [3] Scanner=horusec, CWE-704, Lines=L76-76
  Reason: (1/1) * Possible vulnerability detected: Bad hexadecimal concatenation
When converting a byte array containing a hash signature to a human readable string, a conversion mistake can be made if the array is read byte by byte. The following sample illustrates the use of the method Integer.toHexString() which will trim any leading zeroes from each byte of the computed hash value. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.
  Code snippet:
  ```
     73:         }
     74:
     75:         // Check for STREAM_VERSION
     76:         if (data.length < 3 || (data[2] & 0xFF) != 5) {
     77:             return false;
     78:         }
     79:
  ```
- [4] Scanner=semgrep, CWE-502, Lines=L32-32
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     29:
     30:             // Validate and allowlist deserialization
     31:             if (isValidSerializedData(serializedData)) {
     32:                 try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData))) {
     33:                     ois.setObjectInputFilter((desc, depth) -> {
     34:                         if (desc.getSourceClass() != null && !desc.getSourceClass().equals(SecureClass.class)) {
     35:                             return ObjectInputFilter.Status.REJECTED;
  ```
Case #367
- Before: 1
- After:  0
- Status: CLEAN
Case #360
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     68:         // Set working directory to a safe location (CWE-36: Weak Randomness)
     69:         try {
     70:             processBuilder.directory(Paths.get("/tmp").toFile());
     71:         } catch (Exception e) {
     72:             String errorId = UUID.randomUUID().toString();
     73:             logError(errorId, "Failed to set working directory");
     74:             throw new IOException("Failed to set working directory");
  ```
Case #365
- Before: 0
- After:  0
- Status: CLEAN
Case #362
- Before: 5
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-89, Lines=L28-28
  Reason: (1/1) * Possible vulnerability detected: SQL Injection With Turbine
The input values included in SQL queries need to be passed in safely. Bind variables in prepared statements can be used to easily mitigate the risk of SQL injection. Turbine API provide a DSL to build query with  code. Alternatively to prepare statements, each parameter can be escaped manually. For more information checkout the CWE-89 (https://cwe.mitre.org/data/definitions/89.html) advisory.
  Code snippet:
  ```
     25:      * @throws SQLException if a database error occurs
     26:      * @throws IllegalArgumentException if input validation fails
     27:      */
     28:     public void executeQuery(String userInput) throws SQLException, IllegalArgumentException {
     29:         if (userInput == null || !NAME_PATTERN.matcher(userInput).matches()) {
     30:             logger.warning("Invalid input detected: " + userInput);
     31:             throw new IllegalArgumentException("Invalid user input");
  ```
- [2] Scanner=horusec, CWE-89, Lines=L43-43
  Reason: (1/1) * Possible vulnerability detected: SQL Injection
The input values included in SQL queries need to be passed in safely. Bind variables in prepared statements can be used to easily mitigate the risk of SQL injection. Alternatively to prepare statements, each parameter can be escaped manually. For more information checkout the CWE-89 (https://cwe.mitre.org/data/definitions/89.html) advisory.
  Code snippet:
  ```
     40:         try {
     41:             // Use try-with-resources for automatic resource cleanup
     42:             conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
     43:             String sql = "SELECT Name, Email FROM Users WHERE Name = ?";
     44:             stmt = conn.prepareStatement(sql);
     45:             stmt.setString(1, userInput);
     46:             rs = stmt.executeQuery();
  ```
Case #366
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L143-143
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    140:             String[] arguments = {"-c", "3", "8.8.8.8"};
    141:             String result = executor.executeCommand("ping", arguments);
    142:             System.out.println("Command result:" + System.lineSeparator() + result);
    143:         } catch (Exception e) {
    144:             // In production, log errorId to secure error collector
    145:             String errorId = UUID.randomUUID().toString();
    146:             logError(errorId, "Exception during command execution: " + e.getClass().getSimpleName());
  ```
Case #368
- Before: 0
- After:  0
- Status: CLEAN
Case #369
- Before: 0
- After:  0
- Status: CLEAN
Case #370
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #361
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L78-78
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     75:             byte[] result = new byte[iv.length + encryptedBytes.length];
     76:             System.arraycopy(iv, 0, result, 0, iv.length);
     77:             System.arraycopy(encryptedBytes, 0, result, iv.length, encryptedBytes.length);
     78:             return BASE64_ENCODER.encodeToString(result);
     79:
     80:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
     81:             String errorId = generateOpaqueErrorId();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L160-160
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    157:     private String generateOpaqueErrorId() {
    158:         byte[] randomBytes = new byte[16];
    159:         new SecureRandom().nextBytes(randomBytes);
    160:         return URL_BASE64_ENCODER.encodeToString(randomBytes);
    161:     }
    162: }
    163:
  ```
Case #364
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L35-35
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     32:             if (DB_DRIVER == null || DB_DRIVER.isEmpty()) {
     33:                 throw new IllegalStateException("Database driver not configured");
     34:             }
     35:             Class.forName(DB_DRIVER);
     36:
     37:             // Establish secure connection (credentials externalized)
     38:             if (DB_URL == null || DB_URL.isEmpty() || DB_USERNAME == null || DB_PASSWORD == null) {
  ```
Case #371
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #372
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:
     83:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
     84:                  IllegalBlockSizeException | BadPaddingException | java.security.InvalidAlgorithmParameterException e) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L110-110
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    107:     private String generateOpaqueErrorId() {
    108:         byte[] randomBytes = new byte[16];
    109:         new SecureRandom().nextBytes(randomBytes);
    110:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    111:     }
    112:
    113:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L57-57
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     54:             }
     55:
     56:             // Decode and validate key
     57:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     58:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     59:                 logger.severe("Encryption key has invalid length");
     60:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #378
- Before: 4
- After:  0
- Status: CLEAN
Case #374
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     65:
     66:             // Secure AES-GCM encryption implementation
     67:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     68:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     69:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     70:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
     71:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L79-79
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     76:             System.arraycopy(iv, 0, combined, 0, iv.length);
     77:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     78:
     79:             return Base64.getEncoder().encodeToString(combined);
     80:         } catch (Exception e) {
     81:             String errorId = generateOpaqueErrorId();
     82:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L94-94
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     91:     private String generateOpaqueErrorId() {
     92:         byte[] randomBytes = new byte[16];
     93:         new SecureRandom().nextBytes(randomBytes);
     94:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     95:     }
     96:
     97:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L56-56
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     53:             }
     54:
     55:             // Decode base64 encoded key
     56:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     57:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     58:                 logger.severe("Invalid encryption key length");
     59:                 throw new IOException("Invalid encryption key");
  ```
Case #373
- Before: 0
- After:  0
- Status: CLEAN
Case #377
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L177-177
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output:");
    176:             System.out.println(result);
    177:         } catch (Exception e) {
    178:             // In production, log errorId to secure error collector
    179:             System.err.println("Error occurred: An error occurred");
    180:         }
  ```
Case #375
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L153-153
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    150:             // Example usage - in production, inputs would come from validated sources
    151:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    152:             System.out.println("Command output:" + System.lineSeparator() + result);
    153:         } catch (Exception e) {
    154:             // In production, log errorId to secure error collector
    155:             String errorId = UUID.randomUUID().toString();
    156:             System.err.println("Error: An error occurred (ErrorId: " + errorId + ")");
  ```
Case #384
- Before: 2
- After:  0
- Status: CLEAN
Case #376
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     58:             if (System.getProperty("debug", "false").equals("true")) {
     59:                 e.printStackTrace();
     60:             }
     61:         } catch (Exception e) {
     62:             String errorId = generateSecureErrorId();
     63:             logger.severe("Error occurred: " + errorId);
     64:             if (System.getProperty("debug", "false").equals("true")) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L76-76
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     73:             byte[] randomBytes = new byte[16];
     74:             new SecureRandom().nextBytes(randomBytes);
     75:             byte[] hash = MessageDigest.getInstance("SHA-256").digest(randomBytes);
     76:             return Base64.getEncoder().encodeToString(hash);
     77:         } catch (NoSuchAlgorithmException e) {
     78:             // Fallback to UUID if SHA-256 fails (should never happen in Java 8+)
     79:             return UUID.randomUUID().toString();
  ```
Case #382
- Before: 0
- After:  0
- Status: CLEAN
Case #379
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     79:             new SecureRandom().nextBytes(iv);
     80:
     81:             // AES-GCM encryption implementation with explicit provider
     82:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     83:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     84:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     85:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L94-94
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     91:             System.arraycopy(iv, 0, combined, 0, iv.length);
     92:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     93:
     94:             return Base64.getEncoder().encodeToString(combined);
     95:         } catch (KeyStoreException | NoSuchAlgorithmException | CertificateException | IOException | UnrecoverableKeyException | Exception e) {
     96:             String errorId = generateOpaqueErrorId();
     97:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L109-109
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    106:     private String generateOpaqueErrorId() {
    107:         byte[] randomBytes = new byte[16];
    108:         new SecureRandom().nextBytes(randomBytes);
    109:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    110:     }
    111:
    112:     /**
  ```
Case #389
- Before: 1
- After:  0
- Status: CLEAN
Case #385
- Before: 0
- After:  0
- Status: CLEAN
Case #383
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #390
- Before: 1
- After:  0
- Status: CLEAN
Case #386
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:             new SecureRandom().nextBytes(iv);
     73:
     74:             // Secure AES-GCM encryption implementation
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     76:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     77:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     78:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L87-87
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     84:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     85:
     86:             // Use URL-safe Base64 encoding
     87:             return Base64.getUrlEncoder().withoutPadding().encodeToString(combined);
     88:
     89:         } catch (Exception e) {
     90:             // Opaque error handling - never expose stack traces
  ```
- [3] Scanner=horusec, CWE-0, Lines=L104-104
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    101:     private String generateOpaqueErrorId() {
    102:         byte[] randomBytes = new byte[16];
    103:         new SecureRandom().nextBytes(randomBytes);
    104:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    105:     }
    106:
    107:     /**
  ```
Case #387
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L85-85
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     82:         // 8. Set working directory to a safe location
     83:         try {
     84:             processBuilder.directory(Paths.get("/tmp").toFile());
     85:         } catch (Exception e) {
     86:             String errorId = UUID.randomUUID().toString();
     87:             logError(errorId, "Failed to set working directory");
     88:             throw new IOException("Failed to set working directory", e);
  ```
Case #388
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L10-78
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      7: // restricted commands. In production, consider eliminating direct OS command
      8: // execution entirely. If unavoidable, use a whitelist and absolute paths.
      9:
     10: public class Test {
     11:     // Security Note: Whitelist of allowed commands (case-insensitive)
     12:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
     13:
     14:     // Security Note: Absolute path to shell (if needed) - should be externalized
     15:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     16:
     17:     public static void main(String[] args) {
     18:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     19:             System.out.println("Enter command (allowed: echo, date, whoami):");
     20:             String input = reader.readLine().trim();
     21:
     22:             // Security Note: Input validation and sanitization
     23:             if (input == null || input.isBlank()) {
     24:                 System.err.println("Error: Empty input");
     25:                 return;
     26:             }
     27:
     28:             // Security Note: Split command and arguments safely
     29:             String[] parts = input.split("\\s+", 2);
     30:             String command = parts[0].toLowerCase();
     31:             String arguments = parts.length > 1 ? parts[1] : "";
     32:
     33:             // Security Note: Command whitelisting (CWE-78 mitigation)
     34:             if (!ALLOWED_COMMANDS.contains(command)) {
     35:                 System.err.println("Error: Command not allowed");
     36:                 return;
     37:             }
     38:
     39:             // Security Note: Use ProcessBuilder with absolute path and argument array
     40:             ProcessBuilder processBuilder = new ProcessBuilder(
     41:                 ABSOLUTE_SHELL_PATH,
     42:                 "-i", // Interactive shell flag (if needed)
     43:                 command,
     44:                 arguments
     45:             );
     46:
     47:             // Security Note: Set secure process environment (optional)
     48:             Map<String, String> env = processBuilder.environment();
     49:             env.remove("LD_PRELOAD"); // Remove potentially dangerous env vars
     50:             env.remove("LD_LIBRARY_PATH");
     51:
     52:             // Security Note: Redirect error stream to capture output
     53:             processBuilder.redirectErrorStream(true);
     54:
     55:             Process process = processBuilder.start();
     56:
     57:             // Security Note: Read process output with timeout
     58:             try (BufferedReader outputReader = new BufferedReader(
     59:                     new InputStreamReader(process.getInputStream()))) {
     60:                 String line;
     61:                 while ((line = outputReader.readLine()) != null) {
     62:                     System.out.println(line);
     63:                 }
     64:             }
     65:
     66:             int exitCode = process.waitFor();
     67:             if (exitCode != 0) {
     68:                 System.err.println("Command failed with exit code: " + exitCode);
     69:             }
     70:
     71:         } catch (IOException | InterruptedException e) {
     72:             // Security Note: Opaque error logging (never expose stack traces)
     73:             String errorId = UUID.randomUUID().toString();
     74:             System.err.println("An error occurred (ID: " + errorId + ")");
     75:             // In production, send errorId + e.toString() to secure error collector
     76:             Thread.currentThread().interrupt(); // Restore interrupt status
     77:         }
     78:     }
     79: }
  ```
Case #381
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #380
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L76-76
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     73:             System.arraycopy(iv, 0, combined, 0, iv.length);
     74:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     75:
     76:             return Base64.getEncoder().encodeToString(combined);
     77:
     78:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
     79:                  InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L100-100
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     97:         try {
     98:             byte[] randomBytes = new byte[16];
     99:             new SecureRandom().nextBytes(randomBytes);
    100:             return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    101:         } catch (Exception e) {
    102:             // Fallback for critical error ID generation failure
    103:             return "fallback-error-id";
  ```
Case #393
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L44-44
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     41:             errorId = generateSecureErrorId();
     42:             System.err.println("Deserialization error: " + errorId);
     43:             sendToErrorCollector(errorId, e);
     44:         } catch (Exception e) {
     45:             errorId = generateSecureErrorId();
     46:             System.err.println("Unexpected error: " + errorId);
     47:             sendToErrorCollector(errorId, e);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L57-57
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     54:             new SecureRandom().nextBytes(randomBytes);
     55:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     56:             byte[] hash = digest.digest(randomBytes);
     57:             return Base64.getEncoder().encodeToString(hash);
     58:         } catch (NoSuchAlgorithmException e) {
     59:             return String.format("%032x", System.currentTimeMillis() ^ System.nanoTime());
     60:         }
  ```
Case #398
- Before: 0
- After:  0
- Status: CLEAN
Case #392
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     80:             System.arraycopy(iv, 0, combined, 0, iv.length);
     81:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     82:
     83:             return Base64.getEncoder().encodeToString(combined);
     84:         } catch (Exception e) {
     85:             String errorId = generateOpaqueErrorId();
     86:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L98-98
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     95:     private String generateOpaqueErrorId() {
     96:         byte[] randomBytes = new byte[16];
     97:         new SecureRandom().nextBytes(randomBytes);
     98:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     99:     }
    100:
    101:     /**
  ```
Case #391
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, this would come from a secure form)
     17:         String username = "test' OR '1'='1"; // Example of malicious input
     18:         String password = "password";       // Example of weak password
     19:
     20:         // Validate inputs (basic example - in real app, use more robust validation)
     21:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #394
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L38-38
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     35:             String errorId = generateErrorId();
     36:             logError(errorId, e);
     37:             System.err.println("Error occurred: " + errorId);
     38:         } catch (Exception e) {
     39:             String errorId = generateErrorId();
     40:             logError(errorId, e);
     41:             System.err.println("Unexpected error occurred: " + errorId);
  ```
Case #395
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L169-169
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    166:             // Example usage - in production, these would come from validated sources
    167:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    168:             System.out.println("Command output: " + result);
    169:         } catch (Exception e) {
    170:             // In production, log errorId and send details to secure error collector
    171:             String errorId = UUID.randomUUID().toString();
    172:             System.err.println("ERROR_ID: " + errorId + " - Execution failed");
  ```
Case #397
- Before: 2
- After:  2
- Status: SAME

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L87-88
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     84:         }
     85:
     86:         byte[] serializedData = bos.toByteArray();
     87:         try (ObjectInputStream ois = new ObjectInputStream(
     88:                 new ByteArrayInputStream(serializedData))) {
     89:             ois.readObject();
     90:         }
     91:     }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L64-64
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     61:     }
     62:
     63:     private String generateErrorId() {
     64:         return Base64.getEncoder().encodeToString(
     65:             String.valueOf(ThreadLocalRandom.current().nextLong()).getBytes()
     66:         );
     67:     }
  ```
Case #396
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #401
- Before: 2
- After:  0
- Status: CLEAN
Case #405
- Before: 1
- After:  0
- Status: CLEAN
Case #402
- Before: 1
- After:  0
- Status: CLEAN
Case #399
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #408
- Before: 2
- After:  0
- Status: CLEAN
Case #407
- Before: 2
- After:  0
- Status: CLEAN
Case #409
- Before: 0
- After:  0
- Status: CLEAN
Case #403
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L94-94
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     91:             System.arraycopy(iv, 0, combined, 0, iv.length);
     92:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     93:
     94:             return Base64.getEncoder().encodeToString(combined);
     95:         } catch (KeyStoreException | CertificateException | NoSuchAlgorithmException | UnrecoverableKeyException | IOException e) {
     96:             String errorId = generateOpaqueErrorId();
     97:             logger.severe("Encryption failed: " + errorId);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L113-113
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    110:     private String generateOpaqueErrorId() {
    111:         byte[] randomBytes = new byte[16];
    112:         new SecureRandom().nextBytes(randomBytes);
    113:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    114:     }
    115:
    116:     /**
  ```
Case #406
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             // In production, log errorId to secure error collector
    159:             String errorId = UUID.randomUUID().toString();
    160:             System.err.println("ERROR_ID: " + errorId + ", Message: An error occurred");
  ```
Case #415
- Before: 3
- After:  0
- Status: CLEAN
Case #411
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L50-50
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     47:
     48:             Object obj = ois.readObject();
     49:             ois.close();
     50:         } catch (Exception e) {
     51:             System.err.println("An error occurred");
     52:             // In production, send error details to secure error collector
     53:             System.err.println("Error ID: " + errorId);
  ```
Case #400
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:
     28:         // Example user input (in real app, this would come from user input)
     29:         String username = "testUser";
     30:         String password = "testPassword";
     31:
     32:         // Input validation (basic example - adjust based on actual requirements)
     33:         if (username == null || password == null || username.isBlank() || password.isBlank()) {
  ```
Case #412
- Before: 0
- After:  0
- Status: CLEAN
Case #410
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: An error occurred");
    179:         }
  ```
Case #404
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final String GCM_CIPHER_TRANSFORMATION = "AES/GCM/NoPadding";
     31:     private static final String CONFIG_FILE_PATH = "/etc/secureapp/config.properties";
     32:     private static final String KEY_STORE_PATH = "/etc/secureapp/keystore.jceks";
     33:     private static final String KEY_STORE_PASSWORD = "keystore_password";
     34:     private static final String ENCRYPTION_KEY_ALIAS = "encryption_key";
     35:     private static Properties configProps = loadConfigProperties();
     36:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(iv, 0, combined, 0, iv.length);
     82:             System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
     83:
     84:             return Base64.getEncoder().encodeToString(combined);
     85:         } catch (Exception e) {
     86:             String errorId = generateOpaqueErrorId();
     87:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:     private String generateOpaqueErrorId() {
     97:         byte[] randomBytes = new byte[16];
     98:         new SecureRandom().nextBytes(randomBytes);
     99:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    100:     }
    101:
    102:     /**
  ```
Case #421
- Before: 2
- After:  0
- Status: CLEAN
Case #422
- Before: 0
- After:  0
- Status: CLEAN
Case #413
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #419
- Before: 3
- After:  0
- Status: CLEAN
Case #416
- Before: 1
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-73
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path and argument array
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and display output
     53:             try (BufferedReader processReader = new BufferedReader(
     54:                     new InputStreamReader(process.getInputStream()))) {
     55:                 String line;
     56:                 while ((line = processReader.readLine()) != null) {
     57:                     System.out.println(line);
     58:                 }
     59:             }
     60:
     61:             int exitCode = process.waitFor();
     62:             if (exitCode != 0) {
     63:                 System.err.println("Command exited with non-zero status: " + exitCode);
     64:             }
     65:
     66:         } catch (IOException | InterruptedException e) {
     67:             // Log error securely (no stack traces in production)
     68:             String errorId = UUID.randomUUID().toString();
     69:             System.err.println("An error occurred. Error ID: " + errorId);
     70:             // In production, send errorId + stack trace to secure error collector
     71:             e.printStackTrace(); // Only in debug mode
     72:         }
     73:     }
     74: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-73
  Reason: INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path and argument array
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and display output
     53:             try (BufferedReader processReader = new BufferedReader(
     54:                     new InputStreamReader(process.getInputStream()))) {
     55:                 String line;
     56:                 while ((line = processReader.readLine()) != null) {
     57:                     System.out.println(line);
     58:                 }
     59:             }
     60:
     61:             int exitCode = process.waitFor();
     62:             if (exitCode != 0) {
     63:                 System.err.println("Command exited with non-zero status: " + exitCode);
     64:             }
     65:
     66:         } catch (IOException | InterruptedException e) {
     67:             // Log error securely (no stack traces in production)
     68:             String errorId = UUID.randomUUID().toString();
     69:             System.err.println("An error occurred. Error ID: " + errorId);
     70:             // In production, send errorId + stack trace to secure error collector
     71:             e.printStackTrace(); // Only in debug mode
     72:         }
     73:     }
     74: }
  ```
Case #418
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             System.arraycopy(iv, 0, combined, 0, iv.length);
     79:             System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
     80:
     81:             return Base64.getEncoder().encodeToString(combined);
     82:         } catch (Exception e) {
     83:             String errorId = generateOpaqueErrorId();
     84:             logger.severe("Encryption failed: " + errorId);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private String generateOpaqueErrorId() {
     94:         byte[] randomBytes = new byte[16];
     95:         new SecureRandom().nextBytes(randomBytes);
     96:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
     97:     }
     98:
     99:     /**
  ```
- [4] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode base64 encoded key
     58:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     59:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new IOException("Invalid encryption key");
  ```
Case #420
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     85:             System.arraycopy(encryptedBytes, 0, output, iv.length, encryptedBytes.length);
     86:
     87:             // Use Base64 encoding only for safe transport (CWE-327: Not for security)
     88:             return Base64.getEncoder().encodeToString(output);
     89:
     90:         } catch (Exception e) {
     91:             String errorId = generateOpaqueErrorId();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L104-104
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    101:     private String generateOpaqueErrorId() {
    102:         byte[] randomBytes = new byte[16];
    103:         new SecureRandom().nextBytes(randomBytes);
    104:         return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    105:     }
    106:
    107:     /**
  ```
Case #414
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #417
- Before: 0
- After:  0
- Status: CLEAN
Case #423
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-79, Lines=L32-32
  Reason: (1/1) * Possible vulnerability detected: Potential XSS in Servlet
A potential XSS was found. It could be used to execute unwanted Script in a client's browser. For more information checkout the CWE-79 (https://cwe.mitre.org/data/definitions/79.html) advisory
  Code snippet:
  ```
     29:     @Override
     30:     protected void doPost(HttpServletRequest request, HttpServletResponse response)
     31:             throws ServletException, IOException {
     32:         String userInput = request.getParameter("userInput");
     33:         String errorId = "ERR-" + System.currentTimeMillis();
     34:
     35:         if (userInput == null || userInput.trim().isEmpty()) {
  ```
Case #424
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:     public static void main(String[] args) {
     23:         // Simulated user input (in real application, these would come from a secure form)
     24:         String username = "testUser";
     25:         String password = "secureP@ss123";
     26:
     27:         // Validate inputs before use
     28:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Summary
=====
Total:    424
Clean:    205
Improved: 40
Same:     32
Worse:    147
