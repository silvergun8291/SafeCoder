Secure Coding Evaluation
Timestamp: 2025-11-24T11:19:43.808223+00:00
Scanners: horusec, semgrep, spotbugs (java)
Case #8
- Before: 2
- After:  0
- Status: CLEAN
Case #10
- Before: 0
- After:  0
- Status: CLEAN
Case #13
- Before: 1
- After:  0
- Status: CLEAN
Case #5
- Before: 1
- After:  0
- Status: CLEAN
Case #6
- Before: 1
- After:  0
- Status: CLEAN
Case #7
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L23-23
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     20:     public static void main(String[] args) {
     21:         // Simulated user input (in real application, these would come from a secure input source)
     22:         String username = "testUser";
     23:         String password = "securePassword123";
     24:
     25:         // Validate inputs
     26:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #1
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #3
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #2
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L128-128
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    125:     private String generateOpaqueErrorId() {
    126:         byte[] randomBytes = new byte[32]; // Increased size for better randomness
    127:         new SecureRandom().nextBytes(randomBytes);
    128:         return Base64.getEncoder().withoutPadding().encodeToString(randomBytes);
    129:     }
    130:
    131:     /**
  ```
Case #9
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-704, Lines=L182-196
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
    179:      * @return The hashed secret
    180:      * @throws NoSuchAlgorithmException if SHA-256 is not available
    181:      */
    182:     private String hashSecret(String secret) throws NoSuchAlgorithmException {
    183:         MessageDigest digest = MessageDigest.getInstance("SHA-256");
    184:         byte[] hash = digest.digest(secret.getBytes(java.nio.charset.StandardCharsets.UTF_8));
    185:         StringBuilder hexString = new StringBuilder();
    186:
    187:         for (byte b : hash) {
    188:             String hex = Integer.toHexString(0xff & b);
    189:             if (hex.length() == 1) {
    190:                 hexString.append('0');
    191:             }
    192:             hexString.append(hex);
    193:         }
    194:
    195:         return hexString.toString();
    196:     }
    197:
    198:     /**
    199:      * Logs security errors with an opaque error ID.
  ```
Case #4
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L167-167
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    164:             // Example usage - in production, inputs should come from secure sources
    165:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    166:             System.out.println("Command output: " + result);
    167:         } catch (Exception e) {
    168:             // In production, log errorId and send details to secure error collector
    169:             String errorId = generateErrorId();
    170:             System.err.println("Error ID: " + errorId + ", Message: An error occurred");
  ```
Case #12
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #11
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L269-269
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    266:             // Example usage - in production, these would come from validated sources
    267:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    268:             System.out.println("Command output: " + result);
    269:         } catch (Exception e) {
    270:             // In production, log errorId and send details to secure error collector
    271:             String errorId = UUID.randomUUID().toString();
    272:             System.err.println("ERROR_ID: " + errorId + " - Execution failed: An error occurred");
  ```
- [2] Scanner=semgrep, CWE-704, Lines=L205-221
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
    202:      * @param input the input string to hash
    203:      * @return SHA-256 hash of the input
    204:      */
    205:     private String hashError(String input) {
    206:         try {
    207:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    208:             byte[] hash = digest.digest(input.getBytes("UTF-8"));
    209:             StringBuilder hexString = new StringBuilder();
    210:             for (byte b : hash) {
    211:                 String hex = Integer.toHexString(0xff & b);
    212:                 if (hex.length() == 1) hexString.append('0');
    213:                 hexString.append(hex);
    214:             }
    215:             return hexString.toString();
    216:         } catch (NoSuchAlgorithmException | IOException e) {
    217:             String errorId = UUID.randomUUID().toString();
    218:             logError(errorId, "Error hashing sensitive data", e);
    219:             return "HASHING_FAILED";
    220:         }
    221:     }
    222:
    223:     /**
    224:      * Secure error logging method
  ```
Case #16
- Before: 4
- After:  0
- Status: CLEAN
Case #20
- Before: 1
- After:  0
- Status: CLEAN
Case #14
- Before: 3
- After:  3
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L73-73
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     70:             };
     71:             Object obj = ois.readObject();
     72:             System.out.println(obj);
     73:         } catch (Exception e) {
     74:             String errorId = UUID.randomUUID().toString();
     75:             logger.severe("An error occurred: " + errorId);
     76:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L22-22
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     19:     private String generateSalt() {
     20:         byte[] saltBytes = new byte[16];
     21:         new SecureRandom().nextBytes(saltBytes);
     22:         return Base64.getEncoder().encodeToString(saltBytes);
     23:     }
     24:
     25:     public SecureClass(String command) {
  ```
- [3] Scanner=horusec, CWE-0, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     30:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     31:             digest.reset();
     32:             digest.update(salt.getBytes(StandardCharsets.UTF_8));
     33:             this.commandHash = Base64.getEncoder().encodeToString(digest.digest(command.getBytes(StandardCharsets.UTF_8)));
     34:         } catch (NoSuchAlgorithmException e) {
     35:             String errorId = UUID.randomUUID().toString();
     36:             logger.severe("An error occurred: " + errorId);
  ```
Case #18
- Before: 0
- After:  0
- Status: CLEAN
Case #25
- Before: 2
- After:  0
- Status: CLEAN
Case #15
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:
     22:         // Example user input (in real application, validate and sanitize all inputs)
     23:         String username = "testUser";  // Should come from validated user input
     24:         String password = "testPassword";  // Should come from validated user input
     25:
     26:         // Validate input (basic example; enhance with regex or allowlist in production)
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #26
- Before: 1
- After:  0
- Status: CLEAN
Case #17
- Before: 1
- After:  5
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-326, Lines=L25-25
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     22:     public static void main(String[] args) {
     23:         try {
     24:             // Load SSLContext with default TrustManager (in production, use proper certificate pinning)
     25:             SSLContext sslContext = SSLContext.getInstance("TLS");
     26:             sslContext.init(null, new TrustManager[]{new X509TrustManager() {
     27:                 public X509Certificate[] getAcceptedIssuers() { return null; }
     28:                 public void checkClientTrusted(X509Certificate[] certs, String authType) {}
  ```
- [2] Scanner=semgrep, CWE-0, Lines=L26-30
  Reason: Checks for redefinitions of the checkServerTrusted function in the X509TrustManager class that disables TLS/SSL certificate verification. This should only be used for debugging purposes because it leads to vulnerability to MTM attacks.
  Code snippet:
  ```
     23:         try {
     24:             // Load SSLContext with default TrustManager (in production, use proper certificate pinning)
     25:             SSLContext sslContext = SSLContext.getInstance("TLS");
     26:             sslContext.init(null, new TrustManager[]{new X509TrustManager() {
     27:                 public X509Certificate[] getAcceptedIssuers() { return null; }
     28:                 public void checkClientTrusted(X509Certificate[] certs, String authType) {}
     29:                 public void checkServerTrusted(X509Certificate[] certs, String authType) {}
     30:             }}, new java.security.SecureRandom());
     31:
     32:             // Create SSL Server Socket Factory
     33:             SSLServerSocketFactory factory = sslContext.getServerSocketFactory();
  ```
- [3] Scanner=semgrep, CWE-295, Lines=L27-27
  Reason: Detected empty trust manager implementations. This is dangerous because it accepts any certificate, enabling man-in-the-middle attacks. Consider using a KeyStore and TrustManagerFactory instead. See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https for more information.
  Code snippet:
  ```
     24:             // Load SSLContext with default TrustManager (in production, use proper certificate pinning)
     25:             SSLContext sslContext = SSLContext.getInstance("TLS");
     26:             sslContext.init(null, new TrustManager[]{new X509TrustManager() {
     27:                 public X509Certificate[] getAcceptedIssuers() { return null; }
     28:                 public void checkClientTrusted(X509Certificate[] certs, String authType) {}
     29:                 public void checkServerTrusted(X509Certificate[] certs, String authType) {}
     30:             }}, new java.security.SecureRandom());
  ```
- [4] Scanner=semgrep, CWE-295, Lines=L28-28
  Reason: Detected empty trust manager implementations. This is dangerous because it accepts any certificate, enabling man-in-the-middle attacks. Consider using a KeyStore and TrustManagerFactory instead. See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https for more information.
  Code snippet:
  ```
     25:             SSLContext sslContext = SSLContext.getInstance("TLS");
     26:             sslContext.init(null, new TrustManager[]{new X509TrustManager() {
     27:                 public X509Certificate[] getAcceptedIssuers() { return null; }
     28:                 public void checkClientTrusted(X509Certificate[] certs, String authType) {}
     29:                 public void checkServerTrusted(X509Certificate[] certs, String authType) {}
     30:             }}, new java.security.SecureRandom());
     31:
  ```
- [5] Scanner=semgrep, CWE-295, Lines=L29-29
  Reason: Detected empty trust manager implementations. This is dangerous because it accepts any certificate, enabling man-in-the-middle attacks. Consider using a KeyStore and TrustManagerFactory instead. See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https for more information.
  Code snippet:
  ```
     26:             sslContext.init(null, new TrustManager[]{new X509TrustManager() {
     27:                 public X509Certificate[] getAcceptedIssuers() { return null; }
     28:                 public void checkClientTrusted(X509Certificate[] certs, String authType) {}
     29:                 public void checkServerTrusted(X509Certificate[] certs, String authType) {}
     30:             }}, new java.security.SecureRandom());
     31:
     32:             // Create SSL Server Socket Factory
  ```
Case #23
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L38-38
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     35:             byte[] bytes = baos.toByteArray();
     36:
     37:             try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
     38:                  ObjectInputStream ois = new ObjectInputStream(bais)) {
     39:
     40:                 Object obj = ois.readObject();
     41:                 if (!(obj instanceof String)) {
  ```
Case #19
- Before: 1
- After:  0
- Status: CLEAN
Case #30
- Before: 1
- After:  0
- Status: CLEAN
Case #22
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #21
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(cipherText, 0, encryptedData, iv.length, cipherText.length);
     82:             System.arraycopy(authTag, 0, encryptedData, iv.length + cipherText.length, authTag.length);
     83:
     84:             return Base64.getEncoder().encodeToString(encryptedData);
     85:
     86:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
     87:                  IllegalBlockSizeException | BadPaddingException e) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode and validate key
     58:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     59:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #24
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L29-29
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     26:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     27:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     28:     private static final String KEYSTORE_PATH = "/etc/security/keystore.jks";
     29:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     30:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     31:     private static final String ABSOLUTE_PATH_EXECUTABLE = "/usr/local/bin/secure-tool";
     32:     private static final int GCM_TAG_LENGTH = 128; // bits
  ```
- [2] Scanner=horusec, CWE-0, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    162:     private String generateErrorId() {
    163:         byte[] errorIdBytes = new byte[16];
    164:         new SecureRandom().nextBytes(errorIdBytes);
    165:         return ERROR_ID_PREFIX + Base64.getEncoder().encodeToString(errorIdBytes);
    166:     }
    167: }
    168:
  ```
Case #27
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #29
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-79, Lines=L38-38
  Reason: Detected a request with potential user-input going into a OutputStream or Writer object. This bypasses any view or template environments, including HTML escaping, which may expose this application to cross-site scripting (XSS) vulnerabilities. Consider using a view technology such as JavaServer Faces (JSFs) which automatically escapes HTML views.
  Code snippet:
  ```
     35:             String safeSearchQuery = escapeHtml4(searchQuery);
     36:
     37:             out.println("<html><body>");
     38:             out.println("<p>Your search query is: " + safeSearchQuery + "</p>");
     39:             out.println("</body></html>");
     40:         } catch (IOException e) {
     41:             // Security Note: Avoid logging stack traces in production
  ```
Case #34
- Before: 0
- After:  0
- Status: CLEAN
Case #31
- Before: 3
- After:  0
- Status: CLEAN
Case #37
- Before: 0
- After:  0
- Status: CLEAN
Case #36
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L31-31
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     28:             String errorId = UUID.randomUUID().toString();
     29:             logError(errorId, e);
     30:             System.err.println("An error occurred. Reference ID: " + errorId);
     31:         } catch (Exception e) {
     32:             String errorId = UUID.randomUUID().toString();
     33:             logError(errorId, e);
     34:             System.err.println("An error occurred. Reference ID: " + errorId);
  ```
Case #35
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L55-55
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     52:             }
     53:
     54:             // Decode Base64 encoded key
     55:             byte[] keyBytes = Base64.getDecoder().decode(key);
     56:             if (keyBytes.length != 32) {
     57:                 logger.severe("Invalid encryption key length");
     58:                 throw new IOException("Invalid encryption key length");
  ```
Case #33
- Before: 1
- After:  5
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L112-112
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
    109:
    110:         // Deserialize only after verification
    111:         try (ByteArrayInputStream bais = new ByteArrayInputStream(receivedData);
    112:              ObjectInputStream ois = new ObjectInputStream(bais)) {
    113:
    114:             @SuppressWarnings("unchecked")
    115:             T result = (T) ois.readObject();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     21:         try {
     22:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     23:             byte[] hashBytes = md.digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     24:             return Base64.getEncoder().encodeToString(hashBytes);
     25:         } catch (NoSuchAlgorithmException e) {
     26:             throw new RuntimeException("Critical security failure: SHA-256 not available", e);
     27:         }
  ```
- [3] Scanner=horusec, CWE-0, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     85:         byte[] hmacBytes = mac.doFinal(baos.toByteArray());
     86:
     87:         // 3. Combine data + HMAC using a safe delimiter
     88:         return Base64.getEncoder().encodeToString(baos.toByteArray()) + ":" + Base64.getEncoder().encodeToString(hmacBytes);
     89:     }
     90:
     91:     private static <T extends Serializable> T deserializeWithHmacVerification(String serializedData, byte[] hmacKey) throws Exception {
  ```
- [4] Scanner=horusec, CWE-0, Lines=L98-98
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     95:             throw new SecurityException("Invalid serialized data format");
     96:         }
     97:
     98:         byte[] receivedData = Base64.getDecoder().decode(parts[0]);
     99:         byte[] receivedHmac = Base64.getDecoder().decode(parts[1]);
    100:
    101:         // Verify HMAC
  ```
- [5] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     96:         }
     97:
     98:         byte[] receivedData = Base64.getDecoder().decode(parts[0]);
     99:         byte[] receivedHmac = Base64.getDecoder().decode(parts[1]);
    100:
    101:         // Verify HMAC
    102:         Mac mac = Mac.getInstance(HMAC_ALGORITHM);
  ```
Case #39
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L55-55
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     52:             if (DEBUG_MODE) {
     53:                 e.printStackTrace();
     54:             }
     55:         } catch (Exception e) {
     56:             // Catch-all for unexpected exceptions
     57:             errorId = generateErrorId();
     58:             logger.severe("An unexpected error occurred: " + errorId);
  ```
Case #28
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L17-17
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     14:     public static void main(String[] args) {
     15:         // Simulated user input (in production, use secure input handling)
     16:         String username = "test' OR '1'='1"; // Vulnerable input (will be rejected)
     17:         String password = "Password123!";    // Valid password format
     18:
     19:         // Validate inputs before processing (CWE-89 mitigation)
     20:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L89-89
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     86:     // Password hashing (OWASP recommends bcrypt or Argon2 in production)
     87:     private static String hashPassword(String password) {
     88:         // In production, use a proper password hashing library like BCrypt
     89:         return java.util.Base64.getEncoder().encodeToString(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     90:     }
     91:
     92:     // Securely retrieve database properties (externalized secrets)
  ```
Case #38
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L38-38
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     35:             byte[] data = new byte[stream.available()];
     36:             stream.readFully(data);
     37:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     38:             return Base64.getEncoder().encodeToString(md.digest(data));
     39:         } catch (IOException | NoSuchAlgorithmException e) {
     40:             logger.severe("Error calculating HMAC: " + e.getMessage());
     41:             return null;
  ```
- [2] Scanner=horusec, CWE-0, Lines=L91-91
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     88:         try {
     89:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     90:             md.update(input.getBytes());
     91:             return Base64.getEncoder().encodeToString(md.digest());
     92:         } catch (NoSuchAlgorithmException e) {
     93:             return "ERR_UNKNOWN";
     94:         }
  ```
Case #41
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L39-39
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     36:
     37:             // Deserialize object with HMAC validation
     38:             FileInputStream fileIn = new FileInputStream("secure.ser");
     39:             ObjectInputStream in = new ObjectInputStream(fileIn);
     40:             SecureClass deserializedObject = (SecureClass) in.readObject();
     41:             String storedHmac = (String) in.readObject();
     42:             in.close();
  ```
Case #40
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     74:             Key keySpec = new SecretKeySpec(keyBytes, "AES");
     75:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     58:             }
     59:
     60:             // Decode base64 key
     61:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     62:             if (keyBytes.length != 32) {
     63:                 logger.log(Level.SEVERE, "Invalid encryption key length");
     64:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #42
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L229-229
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    226:             // Example usage - in production, these would come from validated sources
    227:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    228:             System.out.println("Command output: " + result);
    229:         } catch (Exception e) {
    230:             // In production, errorId would be generated and logged by the method itself
    231:             System.err.println("Execution failed: An error occurred");
    232:         }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    161:         try {
    162:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    163:             byte[] hash = digest.digest(UUID.randomUUID().toString().getBytes());
    164:             return Base64.getEncoder().encodeToString(hash);
    165:         } catch (NoSuchAlgorithmException e) {
    166:             // Fallback to simple UUID if SHA-256 not available
    167:             return UUID.randomUUID().toString();
  ```
- [3] Scanner=horusec, CWE-0, Lines=L180-180
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    177:         try {
    178:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    179:             byte[] hash = digest.digest(data.getBytes());
    180:             return Base64.getEncoder().encodeToString(hash);
    181:         } catch (NoSuchAlgorithmException e) {
    182:             // Fallback to empty string if hashing fails
    183:             return "";
  ```
Case #50
- Before: 1
- After:  0
- Status: CLEAN
Case #45
- Before: 2
- After:  0
- Status: CLEAN
Case #32
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L142-142
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
    139:             throw new IllegalStateException("Encryption key must be 256 bits (32 bytes)");
    140:         }
    141:
    142:         byte[] keyBytes = Base64.getDecoder().decode(ENCRYPTION_KEY);
    143:         SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
    144:
    145:         byte[] iv = new byte[GCM_IV_LENGTH];
  ```
Case #52
- Before: 1
- After:  0
- Status: CLEAN
Case #44
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:         // Set working directory to a safe location
     66:         try {
     67:             processBuilder.directory(Paths.get("/tmp").toFile());
     68:         } catch (Exception e) {
     69:             String errorId = UUID.randomUUID().toString();
     70:             logError(errorId, "Failed to set working directory");
     71:             throw new IOException("Failed to set working directory");
  ```
Case #48
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     56:             if (Boolean.getBoolean("debug")) {
     57:                 e.printStackTrace();
     58:             }
     59:         } catch (Exception e) {
     60:             String errorId = generateErrorId();
     61:             logger.warning("Unexpected error: " + errorId);
     62:             System.err.println("An error occurred: " + errorId);
  ```
Case #55
- Before: 0
- After:  0
- Status: CLEAN
Case #49
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #47
- Before: 0
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L177-177
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output:");
    176:             System.out.println(result);
    177:         } catch (Exception e) {
    178:             // Use instance methods instead of creating new instances
    179:             String errorId = executor.generateOpaqueErrorId();
    180:             executor.logError(errorId, "Execution failed", e);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L149-149
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    146:         byte[] randomBytes = new byte[32]; // Increased size for better uniqueness
    147:         SecureRandom random = new SecureRandom();
    148:         random.nextBytes(randomBytes);
    149:         return Base64.getEncoder().withoutPadding().encodeToString(randomBytes);
    150:     }
    151:
    152:     /**
  ```
Case #46
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #53
- Before: 0
- After:  0
- Status: CLEAN
Case #51
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-704, Lines=L93-93
  Reason: (1/1) * Possible vulnerability detected: Unsafe hash equals
An attacker might be able to detect the value of the secret hash due to the exposure of comparison timing. When the functions Arrays.equals() or String.equals() are called, they will exit earlier if fewer bytes are matched. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.
  Code snippet:
  ```
     90:         try {
     91:             // Recompute hash with stored salt
     92:             String inputHash = hashPassword(password, storedSalt);
     93:             if (inputHash.equals(storedHash)) {
     94:                 System.out.println("Access granted!");
     95:             } else {
     96:                 System.out.println("Access denied!");
  ```
Case #60
- Before: 1
- After:  0
- Status: CLEAN
Case #56
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #43
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #62
- Before: 4
- After:  0
- Status: CLEAN
Case #54
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #66
- Before: 1
- After:  0
- Status: CLEAN
Case #69
- Before: 3
- After:  0
- Status: CLEAN
Case #57
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:             new SecureRandom().nextBytes(iv);
     69:
     70:             // Secure AES-GCM encryption implementation with explicit provider
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     72:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     73:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     74:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #61
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L79-79
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     76:                 throw new IOException("Invalid working directory");
     77:             }
     78:             processBuilder.directory(safeDir.toFile());
     79:         } catch (Exception e) {
     80:             String errorId = UUID.randomUUID().toString();
     81:             logError(errorId, "Failed to set working directory");
     82:             throw new IOException("Failed to set working directory");
  ```
Case #71
- Before: 2
- After:  0
- Status: CLEAN
Case #63
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     72:                 throw new IOException("Invalid working directory");
     73:             }
     74:             processBuilder.directory(safeDir.toFile());
     75:         } catch (Exception e) {
     76:             String errorId = UUID.randomUUID().toString();
     77:             logError(errorId, "Failed to set working directory");
     78:             throw new IOException("Failed to set working directory");
  ```
Case #65
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             String errorId = UUID.randomUUID().toString();
    159:             executor.logError(errorId, "Exception occurred during command execution", e);
    160:             System.err.println("Error: An error occurred");
  ```
Case #64
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #67
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L66-66
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     63:             new SecureRandom().nextBytes(iv);
     64:
     65:             // Secure AES-GCM encryption implementation
     66:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     67:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     68:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     69:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L55-55
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     52:             }
     53:
     54:             // Decode base64 encoded key
     55:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     56:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     57:                 logger.severe("Invalid encryption key length");
     58:                 throw new IOException("Invalid encryption key");
  ```
Case #58
- Before: 2
- After:  2
- Status: SAME

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:     public static void main(String[] args) {
     22:         // Simulated user input (in real app, these would come from a secure form)
     23:         String username = "testUser";  // Should be validated/sanitized before use
     24:         String password = "testPassword";  // Should be hashed before comparison
     25:
     26:         // Validate inputs
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:      */
     97:     private static String hashPassword(String password) {
     98:         // In real application, use proper password hashing like BCrypt
     99:         return java.util.Base64.getEncoder().encodeToString(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
    100:     }
    101:
    102:     /**
  ```
Case #68
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     74:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     75:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #74
- Before: 0
- After:  0
- Status: CLEAN
Case #70
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #72
- Before: 0
- After:  0
- Status: CLEAN
Case #59
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     80:      */
     81:     private static String hashPassword(String password) {
     82:         // TODO: Replace with proper hashing (e.g., using BCrypt or PBKDF2)
     83:         return "$2a$10$" + java.util.Base64.getEncoder().encodeToString(password.getBytes());
     84:     }
     85: }
  ```
Case #78
- Before: 0
- After:  0
- Status: CLEAN
Case #81
- Before: 1
- After:  0
- Status: CLEAN
Case #75
- Before: 0
- After:  0
- Status: CLEAN
Case #82
- Before: 2
- After:  0
- Status: CLEAN
Case #73
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L52-52
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     49:
     50:                 new Thread(() -> handleClient(socket)).start();
     51:             }
     52:         } catch (Exception e) {
     53:             String errorId = "ERR-" + System.currentTimeMillis();
     54:             System.err.println("Server error: " + errorId);
     55:             // In production, send errorId to secure error collector
  ```
- [2] Scanner=semgrep, CWE-326, Lines=L25-25
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     22:     public static void main(String[] args) {
     23:         try {
     24:             // Initialize SSL context with trusted keystore
     25:             SSLContext sslContext = SSLContext.getInstance("TLS");
     26:             KeyManagerFactory kmf = KeyManagerFactory
     27:                 .getInstance(KeyManagerFactory.getDefaultAlgorithm());
     28:             KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
  ```
Case #79
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L183-183
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    180:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    181:             System.out.println("Command output:");
    182:             System.out.println(result);
    183:         } catch (Exception e) {
    184:             // In production, log errorId to secure error collector
    185:             System.err.println("Error: An error occurred");
    186:         }
  ```
Case #77
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #80
- Before: 1
- After:  0
- Status: CLEAN
Case #84
- Before: 1
- After:  0
- Status: CLEAN
Case #76
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #85
- Before: 2
- After:  0
- Status: CLEAN
Case #86
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-330, Lines=L6-6
  Reason: (1/1) * Possible vulnerability detected: Insecure Random Number Generator
The App uses an insecure Random Number Generator. For more information checkout the CWE-330 (https://cwe.mitre.org/data/definitions/330.html) advisory.
  Code snippet:
  ```
      3:
      4: /**
      5:  * SecureRandomExample demonstrates the use of a cryptographically strong random number generator.
      6:  * This replaces the insecure java.util.Random with java.security.SecureRandom to mitigate CWE-330.
      7:  *
      8:  * Security Improvements:
      9:  * 1. Uses SecureRandom (cryptographically strong) instead of Random (pseudo-random)
  ```
Case #83
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L64-64
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     61:             new SecureRandom().nextBytes(iv);
     62:
     63:             // AES-GCM encryption implementation
     64:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     65:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     66:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     67:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #87
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #90
- Before: 1
- After:  0
- Status: CLEAN
Case #92
- Before: 2
- After:  0
- Status: CLEAN
Case #88
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    162:             // Example secret retrieval
    163:             String apiKey = executor.getSecureSecret("PRODUCTION_API_KEY");
    164:             System.out.println("API Key retrieved successfully");
    165:         } catch (Exception e) {
    166:             // In production, log errorId to secure error collector
    167:             String errorId = UUID.randomUUID().toString();
    168:             executor.logError(errorId, "Error occurred");
  ```
Case #96
- Before: 4
- After:  0
- Status: CLEAN
Case #97
- Before: 4
- After:  0
- Status: CLEAN
Case #89
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:     public static void main(String[] args) {
     23:         // Example input (in real app, these would come from user input or API)
     24:         String inputUsername = "test";
     25:         String inputPassword = "test";
     26:
     27:         // Validate inputs (basic example - in real app, use stricter validation)
     28:         if (!isValidInput(inputUsername) || !isValidInput(inputPassword)) {
  ```
Case #91
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L41-41
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     38:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     39:     private static final String ENCRYPTION_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     40:     private static final String KEYSTORE_PATH = "/etc/security/keystore.jks";
     41:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     42:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     43:     private static final int MAX_INPUT_LENGTH = 1024;
     44:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #104
- Before: 0
- After:  0
- Status: CLEAN
Case #94
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L162-162
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    159:             // Example secret retrieval
    160:             String apiKey = executor.getSecureSecret("PRODUCTION_API_KEY");
    161:             System.out.println("API Key retrieved successfully");
    162:         } catch (Exception e) {
    163:             String errorId = UUID.randomUUID().toString();
    164:             logError(errorId, "Exception occurred");
    165:             if (Boolean.getBoolean("debug")) {
  ```
Case #95
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #99
- Before: 0
- After:  0
- Status: CLEAN
Case #101
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #100
- Before: 3
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L17-17
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     14:
     15:     // Secure error logging (production-safe)
     16:     private static final String logError(Exception e) {
     17:         String errorId = Base64.getEncoder().encodeToString(MessageDigest.getInstance("SHA-256").digest(e.getMessage().getBytes()));
     18:         System.err.println("Error occurred: " + errorId);
     19:         // In production, send e.toString() + stack trace to secure error collector
     20:         return errorId;
  ```
Case #98
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:
     22:         // Example user input (in real application, validate and sanitize all inputs)
     23:         String username = "testUser";  // Should come from validated user input
     24:         String password = "testPassword";  // Should come from validated user input
     25:
     26:         // Validate input (basic example; enhance with regex or allowlist in production)
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #107
- Before: 2
- After:  0
- Status: CLEAN
Case #103
- Before: 1
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-77
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data in logs)
     53:             StringBuilder output = new StringBuilder();
     54:             try (BufferedReader processReader = new BufferedReader(
     55:                     new InputStreamReader(process.getInputStream()))) {
     56:                 String line;
     57:                 while ((line = processReader.readLine()) != null) {
     58:                     output.append(line).append(System.lineSeparator());
     59:                 }
     60:             }
     61:
     62:             int exitCode = process.waitFor();
     63:             if (exitCode != 0) {
     64:                 System.err.println("Command failed with exit code: " + exitCode);
     65:             } else {
     66:                 System.out.println("Command output:");
     67:                 System.out.println(output);
     68:             }
     69:
     70:         } catch (IOException | InterruptedException e) {
     71:             // Log error securely (no stack traces in production)
     72:             String errorId = UUID.randomUUID().toString();
     73:             System.err.println("An error occurred. Error ID: " + errorId);
     74:             // In production, send errorId + stack trace to secure error collector
     75:             e.printStackTrace(); // Only in debug mode
     76:         }
     77:     }
     78: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-77
  Reason: INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data in logs)
     53:             StringBuilder output = new StringBuilder();
     54:             try (BufferedReader processReader = new BufferedReader(
     55:                     new InputStreamReader(process.getInputStream()))) {
     56:                 String line;
     57:                 while ((line = processReader.readLine()) != null) {
     58:                     output.append(line).append(System.lineSeparator());
     59:                 }
     60:             }
     61:
     62:             int exitCode = process.waitFor();
     63:             if (exitCode != 0) {
     64:                 System.err.println("Command failed with exit code: " + exitCode);
     65:             } else {
     66:                 System.out.println("Command output:");
     67:                 System.out.println(output);
     68:             }
     69:
     70:         } catch (IOException | InterruptedException e) {
     71:             // Log error securely (no stack traces in production)
     72:             String errorId = UUID.randomUUID().toString();
     73:             System.err.println("An error occurred. Error ID: " + errorId);
     74:             // In production, send errorId + stack trace to secure error collector
     75:             e.printStackTrace(); // Only in debug mode
     76:         }
     77:     }
     78: }
  ```
Case #102
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:             new SecureRandom().nextBytes(iv);
     69:
     70:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     72:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     74:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L60-60
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     57:             }
     58:
     59:             // Decode Base64 key
     60:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     61:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     62:                 logger.severe("Invalid encryption key length");
     63:                 throw new SecurityException("Encryption key has invalid length");
  ```
Case #93
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:     public static void main(String[] args) {
     22:         // Simulated user input (in real app, this would come from a secure form/endpoint)
     23:         String username = "test";
     24:         String password = "test' OR '1'='1"; // Simulated malicious input
     25:
     26:         try {
     27:             // 1. Validate inputs (OWASP ASVS 6.1.1)
  ```
Case #106
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L109-109
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    106:         try {
    107:             byte[] errorHash = MessageDigest.getInstance("SHA-256")
    108:                     .digest(e.getClass().getName().getBytes());
    109:             return Base64.getEncoder().encodeToString(errorHash);
    110:         } catch (NoSuchAlgorithmException ex) {
    111:             return "ERROR_ID_GENERATION_FAILED";
    112:         }
  ```
Case #111
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L152-152
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    149:             // Example usage - in production, these would come from validated user input
    150:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    151:             System.out.println("Command output: " + result);
    152:         } catch (Exception e) {
    153:             // In production, log only errorId and send details to secure error collector
    154:             String errorId = UUID.randomUUID().toString();
    155:             executor.logError(errorId, "Execution failed: " + e.getClass().getSimpleName(), e);
  ```
Case #105
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, these would come from a secure form)
     17:         String username = "test";
     18:         String password = "test'; DROP TABLE users; --";
     19:
     20:         // Validate inputs (allowlist: alphanumeric + common special chars)
     21:         if (!isValidInput(username) || !isValidInput(password)) {
  ```
Case #109
- Before: 1
- After:  0
- Status: CLEAN
Case #110
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L27-27
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     24:             byte[] serializedData = bos.toByteArray();
     25:             if (isValidSerializedData(serializedData)) {
     26:                 ByteArrayInputStream bin = new ByteArrayInputStream(serializedData);
     27:                 try (ObjectInputStream ois = new ObjectInputStream(bin)) {
     28:                     Class<?> allowedClass = Class.forName(ALLOWED_CLASS, false, ClassLoader.getSystemClassLoader());
     29:                     ois.setObjectInputFilter((desc, depth) -> {
     30:                         if (desc.getType() != null && !allowedClass.isAssignableFrom(desc.getType())) {
  ```
Case #112
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L65-65
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     62:             System.arraycopy(key.getBytes(StandardCharsets.UTF_8), 0, keyBytes, 0, KEY_SIZE_BYTES);
     63:
     64:             // Secure AES encryption with GCM
     65:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     66:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, new byte[12]); // Random IV will be generated
     67:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     68:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
  ```
Case #113
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-704, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Unsafe hash equals
An attacker might be able to detect the value of the secret hash due to the exposure of comparison timing. When the functions Arrays.equals() or String.equals() are called, they will exit earlier if fewer bytes are matched. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.
  Code snippet:
  ```
     27:
     28:             // Verify file integrity before deserialization
     29:             String fileHash = calculateFileHash(filePath);
     30:             if (!VALID_HASH.equals(fileHash)) {
     31:                 throw new SecurityException("File integrity check failed");
     32:             }
     33:
  ```
- [2] Scanner=semgrep, CWE-704, Lines=L60-89
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     57:         }
     58:     }
     59:
     60:     private static String calculateFileHash(Path filePath) throws IOException {
     61:         try {
     62:             if (!filePath.isAbsolute() || !Files.exists(filePath) || !Files.isRegularFile(filePath)) {
     63:                 throw new IOException("Invalid file path");
     64:             }
     65:
     66:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     67:
     68:             try (InputStream fis = Files.newInputStream(filePath)) {
     69:                 byte[] byteArray = new byte[8192];
     70:                 int bytesCount;
     71:                 while ((bytesCount = fis.read(byteArray)) != -1) {
     72:                     digest.update(byteArray, 0, bytesCount);
     73:                 }
     74:             }
     75:
     76:             byte[] hashBytes = digest.digest();
     77:             StringBuilder hexString = new StringBuilder();
     78:             for (byte b : hashBytes) {
     79:                 String hex = Integer.toHexString(0xff & b);
     80:                 if (hex.length() == 1) {
     81:                     hexString.append('0');
     82:                 }
     83:                 hexString.append(hex);
     84:             }
     85:             return hexString.toString();
     86:         } catch (NoSuchAlgorithmException e) {
     87:             throw new IOException("Hashing algorithm not found", e);
     88:         }
     89:     }
     90: }
     91:
     92: class User implements Serializable {
  ```
Case #120
- Before: 4
- After:  0
- Status: CLEAN
Case #114
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             String errorId = UUID.randomUUID().toString();
    159:             executor.logError(errorId, "Exception during command execution", e);
    160:             System.err.println("Error: An error occurred");
  ```
Case #117
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L178-178
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    175:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    176:             System.out.println("Command output:");
    177:             System.out.println(result);
    178:         } catch (Exception e) {
    179:             // In production, log errorId to secure error collector
    180:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    181:         }
  ```
Case #108
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #115
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     31:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     32:     private static final String KEYSTORE_PATH = "/etc/security/keystore.jks";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     34:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_LENGTH = 1024;
     36:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation with explicit transformation
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     77:
  ```
Case #119
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #125
- Before: 2
- After:  0
- Status: CLEAN
Case #127
- Before: 0
- After:  0
- Status: CLEAN
Case #118
- Before: 0
- After:  0
- Status: CLEAN
Case #121
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #129
- Before: 1
- After:  0
- Status: CLEAN
Case #122
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L77-77
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     74:
     75:         // Step 5: Deserialize safely
     76:         ByteArrayInputStream bin = new ByteArrayInputStream(serializedData);
     77:         ObjectInputStream ois = new ObjectInputStream(bin);
     78:         T obj = (T) ois.readObject();
     79:         ois.close();
     80:         return obj;
  ```
Case #131
- Before: 3
- After:  0
- Status: CLEAN
Case #123
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:         // Set working directory to a safe location to prevent path traversal
     66:         try {
     67:             processBuilder.directory(Paths.get("/tmp").toFile());
     68:         } catch (Exception e) {
     69:             String errorId = UUID.randomUUID().toString();
     70:             logError(errorId, "Failed to set working directory");
     71:             throw new IOException("Failed to set working directory");
  ```
Case #126
- Before: 0
- After:  0
- Status: CLEAN
Case #133
- Before: 1
- After:  0
- Status: CLEAN
Case #124
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L171-171
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    168:             // Example usage - in production, these would come from validated sources
    169:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    170:             System.out.println("Command output: " + result);
    171:         } catch (Exception e) {
    172:             String errorId = UUID.randomUUID().toString();
    173:             // In production, log errorId and send details to secure error collector
    174:             System.err.println("ERROR_ID: " + errorId + ", Message: Execution failed");
  ```
Case #134
- Before: 2
- After:  0
- Status: CLEAN
Case #116
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L76-76
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     73:             new SecureRandom().nextBytes(iv);
     74:
     75:             // AES-GCM encryption implementation
     76:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     77:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     78:             cipher.init(Cipher.ENCRYPT_MODE, secret, spec);
     79:
  ```
Case #135
- Before: 2
- After:  0
- Status: CLEAN
Case #138
- Before: 1
- After:  0
- Status: CLEAN
Case #130
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L38-38
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     35:             }
     36:
     37:             byte[] data = bos.toByteArray();
     38:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data))) {
     39:                 // Security Note: Read and validate each object individually
     40:                 ois.readObject();  // First object is a String, safe to read
     41:                 Object obj = ois.readObject();
  ```
Case #128
- Before: 2
- After:  2
- Status: SAME

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-326, Lines=L42-42
  Reason: (1/1) * Possible vulnerability detected: Classes should not be loaded dynamically
Dynamically loaded classes could contain malicious code executed by a static class initializer. I.E. you wouldn't even have to instantiate or explicitly invoke methods on such classes to be vulnerable to an attack. For more information checkout the CWE-326 (https://cwe.mitre.org/data/definitions/326.html) advisory
  Code snippet:
  ```
     39:             if (!Files.exists(outputDir)) {
     40:                 Files.createDirectories(outputDir);
     41:                 // Set secure permissions (OS-dependent; example for Unix-like systems)
     42:                 if (System.getProperty("os.name").toLowerCase().contains("win")) {
     43:                     // Windows: No direct permission setting via Java; handled by OS
     44:                 } else {
     45:                     // Unix-like: Set directory permissions to 700 (owner read/write/execute only)
  ```
- [2] Scanner=semgrep, CWE-470, Lines=L91-91
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     88:             }
     89:
     90:             // Load class securely (no arbitrary class loading)
     91:             Class<?> clazz = Class.forName("evilPackage." + className);
     92:             Method method = clazz.getMethod("sayHello");
     93:             method.invoke(clazz.getDeclaredConstructor().newInstance());
     94:
  ```
Case #132
- Before: 1
- After:  1
- Status: SAME

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L65-65
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     62:             };
     63:             Object obj = ois.readObject();
     64:             System.out.println(obj);
     65:         } catch (Exception e) {
     66:             String errorId = UUID.randomUUID().toString();
     67:             logError(errorId, "Error during deserialization", e);
     68:             System.err.println("An error occurred");
  ```
Case #144
- Before: 1
- After:  0
- Status: CLEAN
Case #143
- Before: 2
- After:  0
- Status: CLEAN
Case #137
- Before: 0
- After:  0
- Status: CLEAN
Case #139
- Before: 2
- After:  0
- Status: CLEAN
Case #142
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L177-177
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output:");
    176:             System.out.println(result);
    177:         } catch (Exception e) {
    178:             // In production, log errorId to secure error collector
    179:             System.err.println("Error: An error occurred");
    180:         }
  ```
Case #140
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     85:                 String errorId = "ERR-DESERIALIZATION-001";
     86:                 ErrorCollector.logError(errorId, e);
     87:                 System.err.println("Deserialization error: " + errorId);
     88:             } catch (Exception e) {
     89:                 String errorId = "ERR-UNEXPECTED-002";
     90:                 ErrorCollector.logError(errorId, e);
     91:                 System.err.println("An error occurred");
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L69-69
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     66:                 }
     67:             });
     68:
     69:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(validatedData))) {
     70:                 ois.setObjectInputFilter((desc, depth) -> {
     71:                     if (desc.getSerialClass() != null) {
     72:                         String className = desc.getSerialClass().getName();
  ```
Case #145
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L175-175
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    172:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    173:             System.out.println("Command output:");
    174:             System.out.println(result);
    175:         } catch (Exception e) {
    176:             // In production, log errorId to secure error collector
    177:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    178:         }
  ```
Case #149
- Before: 0
- After:  0
- Status: CLEAN
Case #147
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L55-55
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     52:         }
     53:
     54:         // 5. Deserialize with validation
     55:         try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(untrustedBytes))) {
     56:             Class<?> allowedClass = MyClass.class;
     57:             ois.setObjectInputFilter(filterInfo -> {
     58:                 if (filterInfo == null || filterInfo.serialClass() == null ||
  ```
Case #150
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    179:         }
  ```
Case #146
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L120-120
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    117:             String errorId = UUID.randomUUID().toString();
    118:             logError(errorId, "IO error during command execution", e);
    119:             throw new IOException("IO error during command execution", e);
    120:         } catch (Exception e) {
    121:             String errorId = UUID.randomUUID().toString();
    122:             logError(errorId, "Unexpected error during command execution", e);
    123:             throw new IOException("Command execution failed", e);
  ```
Case #155
- Before: 1
- After:  0
- Status: CLEAN
Case #152
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #153
- Before: 1
- After:  3
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L45-45
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     42:             SecretData data = (SecretData) obj;
     43:             System.out.println("Secret Data: " + data.getData());
     44:         }
     45:     } catch (Exception e) {
     46:         String errorId = "ERR-" + UUID.randomUUID().toString();
     47:         logError(errorId, e);
     48:         System.err.println("Deserialization failed: " + errorId);
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L32-32
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     29:             throw new SecurityException("Invalid file hash");
     30:         }
     31:
     32:         try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(fileBytes))) {
     33:             Object obj = ois.readObject();
     34:
     35:             // Type check to prevent class substitution attacks
  ```
- [3] Scanner=semgrep, CWE-704, Lines=L56-68
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     53:     }
     54: }
     55:
     56: private String hashFile(byte[] data) throws NoSuchAlgorithmException {
     57:     MessageDigest digest = MessageDigest.getInstance("SHA-256");
     58:     byte[] hashBytes = digest.digest(data);
     59:     StringBuilder hexString = new StringBuilder();
     60:
     61:     for (byte b : hashBytes) {
     62:         String hex = Integer.toHexString(0xff & b);
     63:         if (hex.length() == 1) hexString.append('0');
     64:         hexString.append(hex);
     65:     }
     66:
     67:     return hexString.toString();
     68: }
     69:
     70: private boolean isDebugMode() {
     71:     return Boolean.getBoolean("debug.mode");
  ```
Case #148
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L119-119
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    116:     private String generateObfuscatedErrorId() {
    117:         byte[] randomBytes = new byte[16];
    118:         new SecureRandom().nextBytes(randomBytes);
    119:         return Base64.getEncoder().encodeToString(randomBytes).replace('+', 'A').replace('/', 'B').replace('=', 'C').substring(0, 16);
    120:     }
    121:
    122:     /**
  ```
Case #141
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L42-42
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     39:             errorId = UUID.randomUUID().toString();
     40:             logger.severe("Deserialization error: " + errorId);
     41:             sendToErrorCollector(errorId, e);
     42:         } catch (Exception e) {
     43:             // Handle other exceptions
     44:             errorId = UUID.randomUUID().toString();
     45:             logger.severe("An error occurred: " + errorId);
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L25-25
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     22:             oos.writeObject(safeInput);
     23:             oos.flush();
     24:
     25:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()))) {
     26:                 // Use validation during deserialization
     27:                 Object obj = ois.readObject();
     28:                 if (!(obj instanceof String)) {
  ```
Case #136
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L86-86
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     83:             new SecureRandom().nextBytes(iv);
     84:
     85:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     86:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     87:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     88:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     89:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #151
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #163
- Before: 2
- After:  0
- Status: CLEAN
Case #164
- Before: 2
- After:  0
- Status: CLEAN
Case #156
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #160
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    162:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    163:             System.out.println("Command output:");
    164:             System.out.println(result);
    165:         } catch (Exception e) {
    166:             // In production, log errorId to secure error collector
    167:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    168:         }
  ```
Case #161
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #159
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     59:                 String errorId = errorIdRef.get() != null ? errorIdRef.get() : UUID.randomUUID().toString();
     60:                 logger.severe("Error occurred: " + errorId);
     61:                 sendToErrorCollector(errorId, e);
     62:             } catch (Exception e) {
     63:                 String errorId = UUID.randomUUID().toString();
     64:                 logger.severe("Unexpected error occurred: " + errorId);
     65:                 sendToErrorCollector(errorId, e);
  ```
Case #166
- Before: 0
- After:  0
- Status: CLEAN
Case #157
- Before: 4
- After:  0
- Status: CLEAN
Case #165
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L66-66
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     63:         try {
     64:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     65:             byte[] hash = digest.digest(data);
     66:             String hashStr = Base64.getEncoder().encodeToString(hash);
     67:             return hashStr.startsWith(EXPECTED_HASH_PREFIX);
     68:         } catch (NoSuchAlgorithmException e) {
     69:             logger.severe("Hashing algorithm not available: " + e.getMessage());
  ```
Case #158
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #162
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:             new SecureRandom().nextBytes(iv);
     73:
     74:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     76:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
     78:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L66-66
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     63:
     64:             // Derive key using PBKDF2 with HMAC-SHA256 (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     65:             SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
     66:             PBEKeySpec spec = new PBEKeySpec(key.toCharArray(), Base64.getDecoder().decode(salt), ITERATIONS, KEY_LENGTH);
     67:             Key tmpKey = skf.generateSecret(spec);
     68:             SecretKeySpec keySpec = new SecretKeySpec(tmpKey.getEncoded(), "AES");
     69:
  ```
Case #167
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #169
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #175
- Before: 1
- After:  0
- Status: CLEAN
Case #168
- Before: 3
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #176
- Before: 0
- After:  0
- Status: CLEAN
Case #154
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L175-175
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    172:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    173:             System.out.println("Command output:");
    174:             System.out.println(result);
    175:         } catch (Exception e) {
    176:             // In production, log errorId to secure error collector
    177:             System.err.println("Error: An error occurred");
    178:         }
  ```
Case #170
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #173
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L41-41
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     38:             if (Boolean.getBoolean("debug")) {
     39:                 e.printStackTrace();
     40:             }
     41:         } catch (Exception e) {
     42:             // Log general errors with opaque error ID
     43:             String errorId = "DESERIAL-002";
     44:             System.err.println("Deserialization error [ERRORID: " + errorId + "]");
  ```
Case #172
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L159-159
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    156:             // Example secret retrieval
    157:             String apiKey = executor.getSecureSecret("API_KEY");
    158:             System.out.println("API Key retrieved successfully");
    159:         } catch (Exception e) {
    160:             // In production, log errorId to secure error collector
    161:             String errorId = UUID.randomUUID().toString();
    162:             System.err.println("Error occurred: " + errorId);
  ```
Case #174
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-75
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:     // Allowlist of permitted commands (secure default)
      7:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      8:
      9:     // Absolute path to shell (never use PATH lookup)
     10:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     11:
     12:     public static void main(String[] args) {
     13:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     14:             System.out.println("Enter your command (allowed: echo, date, whoami):");
     15:             String input = reader.readLine().trim();
     16:
     17:             if (input == null || input.isEmpty()) {
     18:                 System.err.println("Error: Empty command input");
     19:                 return;
     20:             }
     21:
     22:             // Validate command against allowlist
     23:             String[] parts = input.split("\\s+", 2);
     24:             if (parts.length < 1 || !ALLOWED_COMMANDS.contains(parts[0])) {
     25:                 System.err.println("Error: Command not allowed");
     26:                 return;
     27:             }
     28:
     29:             // Prevent command chaining with special characters
     30:             if (Pattern.compile("[;&|]").matcher(input).find()) {
     31:                 System.err.println("Error: Invalid command syntax");
     32:                 return;
     33:             }
     34:
     35:             // Use ProcessBuilder with argument array (no string concatenation)
     36:             ProcessBuilder processBuilder = new ProcessBuilder(
     37:                 ABSOLUTE_SHELL_PATH, "sh", "-c", input
     38:             );
     39:
     40:             // Secure defaults: no inheritance of environment variables
     41:             processBuilder.environment().clear();
     42:
     43:             // Optional: set working directory to a safe location
     44:             // processBuilder.directory(new File("/safe/working/dir"));
     45:
     46:             Process process = processBuilder.start();
     47:
     48:             // Read error stream first to prevent deadlocks
     49:             try (BufferedReader errorReader = new BufferedReader(
     50:                     new InputStreamReader(process.getErrorStream()))) {
     51:                 String errorLine;
     52:                 while ((errorLine = errorReader.readLine()) != null) {
     53:                     System.err.println("Command error: " + errorLine);
     54:                 }
     55:             }
     56:
     57:             // Read standard output
     58:             try (BufferedReader outputReader = new BufferedReader(
     59:                     new InputStreamReader(process.getInputStream()))) {
     60:                 String line;
     61:                 while ((line = outputReader.readLine()) != null) {
     62:                     System.out.println(line);
     63:                 }
     64:             }
     65:
     66:             int exitCode = process.waitFor();
     67:             System.out.println("Command exited with code: " + exitCode);
     68:
     69:         } catch (IOException | InterruptedException e) {
     70:             // Log errorId to secure error collector in production
     71:             String errorId = UUID.randomUUID().toString();
     72:             System.err.println("An error occurred (ID: " + errorId + ")");
     73:             // In development: e.printStackTrace();
     74:         }
     75:     }
     76: }
  ```
Case #183
- Before: 2
- After:  0
- Status: CLEAN
Case #181
- Before: 2
- After:  0
- Status: CLEAN
Case #177
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #178
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L102-102
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     99:         try {
    100:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    101:             byte[] hash = digest.digest(input.getBytes());
    102:             return Base64.getEncoder().encodeToString(hash);
    103:         } catch (NoSuchAlgorithmException e) {
    104:             return "ERROR_ID_GENERATION_FAILED";
    105:         }
  ```
Case #182
- Before: 3
- After:  0
- Status: CLEAN
Case #187
- Before: 1
- After:  0
- Status: CLEAN
Case #179
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     58:             }
     59:
     60:             // Decode and validate key
     61:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     62:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     63:                 logger.severe("Encryption key has invalid length");
     64:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #190
- Before: 0
- After:  0
- Status: CLEAN
Case #180
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     60:             new SecureRandom().nextBytes(iv);
     61:
     62:             // AES-GCM encryption implementation with explicit provider (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     63:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", CRYPTO_PROVIDER);
     64:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     65:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "AES");
     66:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L76-76
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     73:             System.arraycopy(cipherText, 0, encryptedData, iv.length, cipherText.length);
     74:
     75:             // Use Base64 encoding only for safe transport (CWE-0: Base64 not for security)
     76:             return Base64.getEncoder().encodeToString(encryptedData);
     77:         } catch (GeneralSecurityException e) {
     78:             String errorId = generateOpaqueErrorId();
     79:             logger.severe("Encryption failed: " + errorId);
  ```
Case #185
- Before: 0
- After:  0
- Status: CLEAN
Case #193
- Before: 4
- After:  0
- Status: CLEAN
Case #184
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #189
- Before: 0
- After:  0
- Status: CLEAN
Case #186
- Before: 1
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-77
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data in logs)
     53:             StringBuilder output = new StringBuilder();
     54:             try (BufferedReader processReader = new BufferedReader(
     55:                     new InputStreamReader(process.getInputStream()))) {
     56:                 String line;
     57:                 while ((line = processReader.readLine()) != null) {
     58:                     output.append(line).append(System.lineSeparator());
     59:                 }
     60:             }
     61:
     62:             int exitCode = process.waitFor();
     63:             if (exitCode != 0) {
     64:                 System.err.println("Command failed with exit code: " + exitCode);
     65:             } else {
     66:                 System.out.println("Command output:");
     67:                 System.out.println(output);
     68:             }
     69:
     70:         } catch (IOException | InterruptedException e) {
     71:             // Log error securely (no stack traces in production)
     72:             String errorId = UUID.randomUUID().toString();
     73:             System.err.println("An error occurred. Error ID: " + errorId);
     74:             // In production, send errorId + stack trace to secure error collector
     75:             e.printStackTrace(); // Only in debug mode
     76:         }
     77:     }
     78: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-77
  Reason: INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data in logs)
     53:             StringBuilder output = new StringBuilder();
     54:             try (BufferedReader processReader = new BufferedReader(
     55:                     new InputStreamReader(process.getInputStream()))) {
     56:                 String line;
     57:                 while ((line = processReader.readLine()) != null) {
     58:                     output.append(line).append(System.lineSeparator());
     59:                 }
     60:             }
     61:
     62:             int exitCode = process.waitFor();
     63:             if (exitCode != 0) {
     64:                 System.err.println("Command failed with exit code: " + exitCode);
     65:             } else {
     66:                 System.out.println("Command output:");
     67:                 System.out.println(output);
     68:             }
     69:
     70:         } catch (IOException | InterruptedException e) {
     71:             // Log error securely (no stack traces in production)
     72:             String errorId = UUID.randomUUID().toString();
     73:             System.err.println("An error occurred. Error ID: " + errorId);
     74:             // In production, send errorId + stack trace to secure error collector
     75:             e.printStackTrace(); // Only in debug mode
     76:         }
     77:     }
     78: }
  ```
Case #188
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     34:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_LENGTH = 1024;
     36:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation with explicit provider
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #198
- Before: 2
- After:  0
- Status: CLEAN
Case #201
- Before: 1
- After:  0
- Status: CLEAN
Case #191
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L87-87
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     84:             System.arraycopy(cipherText, 0, encryptedData, iv.length, cipherText.length);
     85:             System.arraycopy(tag, 0, encryptedData, iv.length + cipherText.length, tag.length);
     86:
     87:             return Base64.getEncoder().encodeToString(encryptedData);
     88:         } catch (Exception e) {
     89:             String errorId = generateOpaqueErrorId();
     90:             logger.severe("Encryption failed: " + errorId);
  ```
Case #192
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #194
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #197
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L167-167
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    164:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    165:             System.out.println("Command output:");
    166:             System.out.println(result);
    167:         } catch (Exception e) {
    168:             // In production, log errorId to secure error collector
    169:             System.err.println("Error occurred: An error occurred");
    170:             // Stack traces only in debug mode
  ```
Case #171
- Before: 3
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L89-89
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     86:         try {
     87:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     88:             byte[] hash = digest.digest((System.currentTimeMillis() + ":" + context).getBytes());
     89:             return Base64.getEncoder().encodeToString(hash);
     90:         } catch (Exception e) {
     91:             return "ERR_UNKNOWN";
     92:         }
  ```
Case #204
- Before: 4
- After:  0
- Status: CLEAN
Case #199
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L49-49
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     46:             if (Boolean.getBoolean("debug")) {
     47:                 e.printStackTrace(System.err); // Only in debug mode
     48:             }
     49:         } catch (Exception e) {
     50:             // Fixed: Generic exception handling with opaque error ID
     51:             String errorId = UUID.randomUUID().toString();
     52:             System.err.println("Error occurred: " + errorId);
  ```
Case #196
- Before: 2
- After:  0
- Status: CLEAN
Case #195
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     34:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_LENGTH = 1024;
     36:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation with explicit provider
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #206
- Before: 0
- After:  0
- Status: CLEAN
Case #200
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L57-57
  Reason: (1/1) * Possible vulnerability detected: No Default  Hash
This App uses  Hash Code. It"s a weak hash function and should never be used in Secure Crypto Implementation. For more information checkout the CWE-327 (https://cwe.mitre.org/data/definitions/327.html) advisory.
  Code snippet:
  ```
     54:             return Base64.getEncoder().encodeToString(hash);
     55:         } catch (NoSuchAlgorithmException ex) {
     56:             // Fallback to simple hash if SHA-256 fails
     57:             return String.valueOf(e.hashCode());
     58:         }
     59:     }
     60: }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L54-54
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     51:         try {
     52:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     53:             byte[] hash = digest.digest(e.getClass().getName().getBytes(java.nio.charset.StandardCharsets.UTF_8));
     54:             return Base64.getEncoder().encodeToString(hash);
     55:         } catch (NoSuchAlgorithmException ex) {
     56:             // Fallback to simple hash if SHA-256 fails
     57:             return String.valueOf(e.hashCode());
  ```
Case #209
- Before: 4
- After:  0
- Status: CLEAN
Case #203
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L80-80
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     77:             new SecureRandom().nextBytes(iv);
     78:
     79:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     80:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     81:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     82:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     83:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L116-116
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    113:     private String generateOpaqueErrorId() {
    114:         byte[] randomBytes = new byte[16];
    115:         new SecureRandom().nextBytes(randomBytes);
    116:         return BASE64_ENCODER.encodeToString(randomBytes);
    117:     }
    118:
    119:     /**
  ```
Case #205
- Before: 1
- After:  0
- Status: CLEAN
Case #202
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #216
- Before: 2
- After:  0
- Status: CLEAN
Case #208
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     30:             logger.severe("Deserialization failed: " + errorId);
     31:             sendErrorDetailsToCollector(e, errorId);
     32:             System.err.println("An error occurred");
     33:         } catch (Exception e) {
     34:             String errorId = ERROR_ID_PREFIX + UUID.randomUUID().toString();
     35:             logger.severe("Unexpected error: " + errorId);
     36:             sendErrorDetailsToCollector(e, errorId);
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L25-25
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     22:             // Deserialize with validation
     23:             try (ByteArrayInputStream bis = new ByteArrayInputStream(data);
     24:                  InputStream validationStream = new ValidationInputStream(bis, ALLOWED_CLASS)) {
     25:                 Object obj = new ObjectInputStream(validationStream).readObject();
     26:                 System.out.println(obj);
     27:             }
     28:         } catch (InvalidClassException | ClassNotFoundException | IOException e) {
  ```
Case #211
- Before: 4
- After:  0
- Status: CLEAN
Case #207
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #212
- Before: 0
- After:  0
- Status: CLEAN
Case #214
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #213
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #219
- Before: 1
- After:  0
- Status: CLEAN
Case #220
- Before: 4
- After:  0
- Status: CLEAN
Case #215
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #218
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #223
- Before: 3
- After:  0
- Status: CLEAN
Case #228
- Before: 2
- After:  0
- Status: CLEAN
Case #217
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     79:             byte[] randomBytes = new byte[16];
     80:             new java.security.SecureRandom().nextBytes(randomBytes);
     81:             return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     82:         } catch (NoSuchAlgorithmException e) {
     83:             // Fallback if SHA-256 is unavailable (should never happen in Java 8+)
     84:             return "ERR-" + System.currentTimeMillis();
  ```
Case #225
- Before: 0
- After:  0
- Status: CLEAN
Case #222
- Before: 3
- After:  3
- Status: SAME

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L108-108
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
    105:             oos.writeObject(obj);
    106:             oos.flush();
    107:
    108:             ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
    109:             ois.readObject();
    110:         } catch (InvalidObjectException e) {
    111:             logger.warning("Invalid object detected: " + e.getMessage());
  ```
- [2] Scanner=horusec, CWE-0, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     71:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     72:             digest.update(secret.getBytes());
     73:             byte[] hash = digest.digest(data);
     74:             return Base64.getEncoder().encodeToString(hash);
     75:         } catch (Exception e) {
     76:             throw new NoSuchAlgorithmException("HMAC calculation failed", e);
     77:         }
  ```
- [3] Scanner=horusec, CWE-0, Lines=L89-89
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     86:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     87:             byte[] randomBytes = new byte[16];
     88:             new java.security.SecureRandom().nextBytes(randomBytes);
     89:             return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     90:         } catch (NoSuchAlgorithmException e) {
     91:             return "ERROR_ID_GENERATION_FAILED";
     92:         }
  ```
Case #210
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     79:             new SecureRandom().nextBytes(iv);
     80:
     81:             // AES-GCM encryption implementation
     82:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     83:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     84:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     85:
  ```
Case #221
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L123-123
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    120:             String errorId = UUID.randomUUID().toString();
    121:             logError(errorId, "IO error during command execution", e);
    122:             throw new IOException("Command execution failed: " + errorId, e);
    123:         } catch (Exception e) {
    124:             String errorId = UUID.randomUUID().toString();
    125:             logError(errorId, "Unexpected error during command execution", e);
    126:             throw new IOException("Command execution failed: " + errorId, e);
  ```
Case #224
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     60:                     }
     61:                 } catch (IOException | InterruptedException e) {
     62:                     logger.severe("Error handling client: " + e.getMessage());
     63:                     String errorId = Base64.getEncoder().encodeToString(e.getClass().getName().getBytes());
     64:                     logger.fine("Error details: " + errorId);
     65:                 }
     66:             }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L69-69
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     66:             }
     67:         } catch (IOException e) {
     68:             logger.severe("Failed to start secure server: " + e.getMessage());
     69:             String errorId = Base64.getEncoder().encodeToString(e.getClass().getName().getBytes());
     70:             logger.fine("Error details: " + errorId);
     71:         }
     72:     }
  ```
Case #229
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L173-173
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    170:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    171:             System.out.println("Command output:");
    172:             System.out.println(result);
    173:         } catch (Exception e) {
    174:             // In production, log errorId and send details to secure error collector
    175:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    176:             // Log errorId to secure logging system here
  ```
Case #233
- Before: 3
- After:  0
- Status: CLEAN
Case #226
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L135-135
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
    132:             throw new InvalidKeySpecException("Invalid key size. Expected 32 bytes for AES-256");
    133:         }
    134:
    135:         Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
    136:         GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, Base64.getDecoder().decode(GCM_IV));
    137:         SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
    138:         cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L141-141
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    138:         cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
    139:
    140:         byte[] encryptedBytes = cipher.doFinal(data.getBytes(java.nio.charset.StandardCharsets.UTF_8));
    141:         return Base64.getEncoder().encodeToString(encryptedBytes);
    142:     }
    143:
    144:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L130-130
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
    127:         }
    128:
    129:         // Validate key size
    130:         byte[] keyBytes = Base64.getDecoder().decode(ENCRYPTION_KEY);
    131:         if (keyBytes.length != 32) {  // 256 bits = 32 bytes
    132:             throw new InvalidKeySpecException("Invalid key size. Expected 32 bytes for AES-256");
    133:         }
  ```
- [4] Scanner=horusec, CWE-0, Lines=L136-136
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
    133:         }
    134:
    135:         Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
    136:         GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, Base64.getDecoder().decode(GCM_IV));
    137:         SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
    138:         cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
    139:
  ```
Case #227
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     59:             new SecureRandom().nextBytes(iv);
     60:
     61:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     62:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     63:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     64:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     65:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #231
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L61-61
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     58:                 }
     59:
     60:                 try {
     61:                     return Class.forName(className, false, classLoader);
     62:                 } catch (ClassNotFoundException e) {
     63:                     String errorId = UUID.randomUUID().toString();
     64:                     // Log.error("Class not found during deserialization: " + errorId);
  ```
Case #234
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #232
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L54-54
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     51:             }
     52:
     53:             // Decode and validate key
     54:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     55:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     56:                 logger.severe("Encryption key has invalid length");
     57:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #235
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L78-78
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     75:             new SecureRandom().nextBytes(iv);
     76:
     77:             // AES-GCM encryption implementation
     78:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     79:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     80:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     81:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #241
- Before: 3
- After:  0
- Status: CLEAN
Case #230
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     55:                 e.printStackTrace();
     56:             }
     57:             // Send e to secure error collector in production
     58:         } catch (Exception e) {
     59:             String errorId = java.util.UUID.randomUUID().toString();
     60:             logger.severe("Deserialization error: " + errorId);
     61:             if (DEBUG_MODE) {
  ```
Case #236
- Before: 1
- After:  6
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L23-23
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     20:
     21:     public static void main(String[] args) {
     22:         try {
     23:             String adminHash = hashPassword("secureAdminPass123!");
     24:             String user1Hash = hashPassword("secureUser1Pass456!");
     25:             String user2Hash = hashPassword("secureUser2Pass789!");
     26:             userPasswordHashes.put("admin", adminHash);
  ```
- [2] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:     public static void main(String[] args) {
     22:         try {
     23:             String adminHash = hashPassword("secureAdminPass123!");
     24:             String user1Hash = hashPassword("secureUser1Pass456!");
     25:             String user2Hash = hashPassword("secureUser2Pass789!");
     26:             userPasswordHashes.put("admin", adminHash);
     27:             userPasswordHashes.put("user1", user1Hash);
  ```
- [3] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:         try {
     23:             String adminHash = hashPassword("secureAdminPass123!");
     24:             String user1Hash = hashPassword("secureUser1Pass456!");
     25:             String user2Hash = hashPassword("secureUser2Pass789!");
     26:             userPasswordHashes.put("admin", adminHash);
     27:             userPasswordHashes.put("user1", user1Hash);
     28:             userPasswordHashes.put("user2", user2Hash);
  ```
- [4] Scanner=horusec, CWE-798, Lines=L36-36
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     33:         }
     34:
     35:         String username = "admin";
     36:         String password = "secureAdminPass123!";
     37:
     38:         if (!isValidUser(username)) {
     39:             System.out.println("Access denied!");
  ```
- [5] Scanner=horusec, CWE-0, Lines=L88-88
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     85:         System.arraycopy(salt, 0, saltedHash, 0, salt.length);
     86:         System.arraycopy(hash, 0, saltedHash, salt.length, hash.length);
     87:
     88:         return Base64.getEncoder().encodeToString(saltedHash);
     89:     }
     90:
     91:     private static boolean verifyPassword(String password, String storedHash) throws NoSuchAlgorithmException, InvalidKeySpecException {
  ```
- [6] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     93:             return false;
     94:         }
     95:
     96:         byte[] decodedHash = Base64.getDecoder().decode(storedHash);
     97:         if (decodedHash.length < 16) {
     98:             return false;
     99:         }
  ```
Case #238
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L79-79
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     76:                 throw new IOException("Invalid working directory");
     77:             }
     78:             processBuilder.directory(safeDir.toFile());
     79:         } catch (Exception e) {
     80:             String errorId = UUID.randomUUID().toString();
     81:             logError(errorId, "Failed to set working directory");
     82:             throw new IOException("Failed to set working directory");
  ```
Case #243
- Before: 0
- After:  0
- Status: CLEAN
Case #240
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #237
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L15-15
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     12:             User user = new User("admin", "123456"); // Note: In real code, use secure credential handling
     13:             // Simulate a successful operation (no exception should be thrown here)
     14:             System.out.println("User created successfully");
     15:         } catch (Exception e) {
     16:             // OWASP Recommendation: Never expose stack traces to users
     17:             // CWE-209 Mitigation: Avoid leaking sensitive information in error messages
     18:             String errorId = UUID.randomUUID().toString(); // Opaque error ID for tracking
  ```
Case #244
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     56:             System.arraycopy(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), 0, keyBytes, 0, KEY_SIZE_BYTES);
     57:
     58:             // Secure AES encryption with GCM
     59:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     60:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, new byte[12]); // Random IV will be generated
     61:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     62:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #247
- Before: 3
- After:  0
- Status: CLEAN
Case #252
- Before: 0
- After:  0
- Status: CLEAN
Case #246
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #242
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #239
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #245
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:     public static void main(String[] args) {
     22:         // Simulate user input (in real app, read from secure input source)
     23:         String username = "admin";  // Should come from user input
     24:         String password = "secureP@ss123";  // Should come from user input
     25:
     26:         // Validate inputs before use
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #248
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             if (executor.isDebugMode()) {
    162:                 e.printStackTrace(); // Only in debug mode
    163:             }
    164:         } catch (Exception e) {
    165:             // Catch-all for unexpected exceptions
    166:             String errorId = UUID.randomUUID().toString();
    167:             System.err.println("ERROR_ID: " + errorId + " - Error: An unexpected error occurred");
  ```
Case #253
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #251
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L66-66
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     63:         try {
     64:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     65:             byte[] hash = digest.digest(data);
     66:             String hashStr = Base64.getEncoder().encodeToString(hash);
     67:             // In production, compare with a precomputed trusted hash
     68:             return hashStr.equals("U3RhcnR1cGRfSGFzaE9wZW4="); // Example placeholder
     69:         } catch (NoSuchAlgorithmException e) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     80:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     81:             byte[] randomBytes = new byte[16];
     82:             new java.security.SecureRandom().nextBytes(randomBytes);
     83:             return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     84:         } catch (NoSuchAlgorithmException e) {
     85:             return "ERR-UNKNOWN";
     86:         }
  ```
Case #259
- Before: 2
- After:  0
- Status: CLEAN
Case #257
- Before: 0
- After:  0
- Status: CLEAN
Case #249
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     80:             new SecureRandom().nextBytes(iv);
     81:
     82:             // AES-GCM encryption implementation with explicit provider
     83:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     84:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     85:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     86:
  ```
Case #250
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #255
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #256
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-326, Lines=L21-21
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     18:     public static void main(String[] args) {
     19:         try {
     20:             // Initialize SSLContext with default settings (can be customized)
     21:             SSLContext sslContext = SSLContext.getInstance("TLS");
     22:
     23:             // Initialize KeyManagerFactory with keystore (server certificate)
     24:             KeyManagerFactory kmf = KeyManagerFactory
  ```
Case #258
- Before: 0
- After:  0
- Status: CLEAN
Case #266
- Before: 1
- After:  0
- Status: CLEAN
Case #254
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L52-52
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     49:             System.out.println("Deserialized object: " + obj);
     50:         } catch (IOException | ClassNotFoundException | NoSuchAlgorithmException e) {
     51:             // Log only an opaque error ID in production
     52:             String errorId = "ERR-" + Base64.getEncoder().encodeToString(MessageDigest.getInstance("SHA-256").digest(e.getMessage().getBytes()));
     53:             System.err.println("An error occurred: " + errorId);
     54:             // In production, send e to a secure error collector
     55:         }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     71:         // In production, use a proper HMAC implementation (e.g., HmacSHA256)
     72:         MessageDigest md = MessageDigest.getInstance("SHA-256");
     73:         md.update(key.getBytes());
     74:         return Base64.getEncoder().encodeToString(md.digest(data));
     75:     }
     76:
     77:     // HMAC verification
  ```
Case #268
- Before: 1
- After:  0
- Status: CLEAN
Case #260
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L44-44
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     41:             Object deserializedObj = objIn.readObject();
     42:
     43:             System.out.println("Deserialization successful");
     44:         } catch (Exception e) {
     45:             String errorId = generateSecureErrorId();
     46:             logger.severe(String.format(ERROR_LOG_MESSAGE, errorId));
     47:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L54-54
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     51:             } else {
     52:                 // Send error details to secure error collector
     53:                 String errorDetails = String.format("Exception: %s, Class: %s", e.getMessage(), e.getClass().getName());
     54:                 String encodedErrorDetails = Base64.getEncoder().encodeToString(errorDetails.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     55:                 // sendToErrorCollector(errorId, encodedErrorDetails);
     56:             }
     57:         }
  ```
Case #263
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L178-178
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    175:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    176:             System.out.println("Command output:");
    177:             System.out.println(result);
    178:         } catch (Exception e) {
    179:             // In production, log errorId to secure error collector
    180:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    181:         }
  ```
Case #264
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #274
- Before: 1
- After:  0
- Status: CLEAN
Case #265
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L117-117
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    114:             String errorId = UUID.randomUUID().toString();
    115:             logError(errorId, "IO error during command execution", e);
    116:             throw new IOException("Command execution failed", e);
    117:         } catch (Exception e) {
    118:             String errorId = UUID.randomUUID().toString();
    119:             logError(errorId, "Unexpected error during command execution", e);
    120:             throw new IOException("Command execution failed", e);
  ```
Case #262
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #267
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:         // Set working directory to a safe location
     66:         try {
     67:             processBuilder.directory(Paths.get("/tmp").toFile());
     68:         } catch (Exception e) {
     69:             String errorId = UUID.randomUUID().toString();
     70:             logError(errorId, "Failed to set working directory");
     71:             throw new IOException("Failed to set working directory");
  ```
Case #276
- Before: 1
- After:  0
- Status: CLEAN
Case #269
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L22-22
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     19:     public static void main(String[] args) {
     20:         // Simulated user input - in real application this would come from request parameters
     21:         String username = "test'; DROP TABLE users; --"; // Vulnerable input
     22:         String password = "password";
     23:
     24:         // Validate input with allowlist pattern
     25:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #271
- Before: 2
- After:  5
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L15-15
  Reason: (1/1) * Possible vulnerability detected: No Default  Hash
This App uses  Hash Code. It"s a weak hash function and should never be used in Secure Crypto Implementation. For more information checkout the CWE-327 (https://cwe.mitre.org/data/definitions/327.html) advisory.
  Code snippet:
  ```
     12:         HashMap<User, String> userMap = new HashMap<>();
     13:         userMap.put(user1, "Value1");
     14:
     15:         // Correct object comparison using properly overridden equals() and hashCode()
     16:         if (userMap.containsKey(user2)) {
     17:             System.out.println("User found: " + userMap.get(user2));
     18:         } else {
  ```
- [2] Scanner=horusec, CWE-704, Lines=L31-31
  Reason: (1/2) * Possible vulnerability detected: Unsafe hash equals
An attacker might be able to detect the value of the secret hash due to the exposure of comparison timing. When the functions Arrays.equals() or String.equals() are called, they will exit earlier if fewer bytes are matched. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.

(2/2) * Possible vulnerability detected: No Log Sensitive Information
The App logs information. Sensitive information should never be logged. For more information checkout the CWE-532 (https://cwe.mitre.org/data/definitions/532.html) advisory.
  Code snippet:
  ```
     28:             System.out.println("Secure Hash (user1): " + secureHash1);
     29:             System.out.println("Secure Hash (user2): " + secureHash2);
     30:             System.out.println("Secure Hash (user3): " + secureHash3);
     31:             System.out.println("Hashes equal (user1 vs user2)? " + secureHash1.equals(secureHash2));
     32:         } catch (NoSuchAlgorithmException e) {
     33:             System.err.println("Error generating secure hash: " + e.getMessage());
     34:             // In production, log errorId and send details to secure error collector
  ```
- [3] Scanner=horusec, CWE-327, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: No Default  Hash
This App uses  Hash Code. It"s a weak hash function and should never be used in Secure Crypto Implementation. For more information checkout the CWE-327 (https://cwe.mitre.org/data/definitions/327.html) advisory.
  Code snippet:
  ```
     59:     }
     60:
     61:     @Override
     62:     public int hashCode() {
     63:         // Standard non-cryptographic hash implementation for Map/Set usage
     64:         // NOT suitable for security-sensitive contexts (e.g., password storage, unique identifiers)
     65:         return Objects.hash(firstName, lastName);
  ```
- [4] Scanner=spotbugs, CWE-0, Lines=L43-83
  Reason: BAD_HEXA_CONVERSION
  Code snippet:
  ```
     40:     private final String firstName;
     41:     private final String lastName;
     42:
     43:     public User(String firstName, String lastName) {
     44:         // Validate inputs to prevent null or empty values
     45:         if (firstName == null || firstName.trim().isEmpty() ||
     46:             lastName == null || lastName.trim().isEmpty()) {
     47:             throw new IllegalArgumentException("First and last names must not be null or empty.");
     48:         }
     49:         this.firstName = firstName.trim();
     50:         this.lastName = lastName.trim();
     51:     }
     52:
     53:     @Override
     54:     public boolean equals(Object obj) {
     55:         if (this == obj) return true;
     56:         if (obj == null || getClass() != obj.getClass()) return false;
     57:         User user = (User) obj;
     58:         return firstName.equals(user.firstName) && lastName.equals(user.lastName);
     59:     }
     60:
     61:     @Override
     62:     public int hashCode() {
     63:         // Standard non-cryptographic hash implementation for Map/Set usage
     64:         // NOT suitable for security-sensitive contexts (e.g., password storage, unique identifiers)
     65:         return Objects.hash(firstName, lastName);
     66:     }
     67:
     68:     /**
     69:      * Generates a secure cryptographic hash for security-sensitive use cases.
     70:      * @param user The user object to hash
     71:      * @return Hex-encoded SHA-256 hash string
     72:      * @throws NoSuchAlgorithmException If SHA-256 is not available
     73:      */
     74:     public static String generateSecureHash(User user) throws NoSuchAlgorithmException {
     75:         MessageDigest digest = MessageDigest.getInstance("SHA-256");
     76:         byte[] hashBytes = digest.digest((user.firstName + user.lastName).getBytes(java.nio.charset.StandardCharsets.UTF_8));
     77:         StringBuilder hexString = new StringBuilder();
     78:         for (byte b : hashBytes) {
     79:             String hex = Integer.toHexString(0xff & b);
     80:             if (hex.length() == 1) hexString.append('0');
     81:             hexString.append(hex);
     82:         }
     83:         return hexString.toString();
     84:     }
     85: }
  ```
- [5] Scanner=semgrep, CWE-704, Lines=L74-84
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     71:      * @return Hex-encoded SHA-256 hash string
     72:      * @throws NoSuchAlgorithmException If SHA-256 is not available
     73:      */
     74:     public static String generateSecureHash(User user) throws NoSuchAlgorithmException {
     75:         MessageDigest digest = MessageDigest.getInstance("SHA-256");
     76:         byte[] hashBytes = digest.digest((user.firstName + user.lastName).getBytes(java.nio.charset.StandardCharsets.UTF_8));
     77:         StringBuilder hexString = new StringBuilder();
     78:         for (byte b : hashBytes) {
     79:             String hex = Integer.toHexString(0xff & b);
     80:             if (hex.length() == 1) hexString.append('0');
     81:             hexString.append(hex);
     82:         }
     83:         return hexString.toString();
     84:     }
     85: }
  ```
Case #261
- Before: 0
- After:  0
- Status: CLEAN
Case #272
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             // In production, log errorId to secure error collector
    159:             String errorId = UUID.randomUUID().toString();
    160:             System.err.println("ERROR_ID: " + errorId + ", Message: An error occurred");
  ```
Case #270
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example secret retrieval
    155:             String apiKey = executor.getSecureSecret("API_KEY");
    156:             System.out.println("API Key retrieved successfully");
    157:         } catch (Exception e) {
    158:             String errorId = UUID.randomUUID().toString();
    159:             // In production, send errorId to secure error collector
    160:             System.err.println("Error occurred: " + errorId);
  ```
Case #273
- Before: 1
- After:  0
- Status: CLEAN
Case #278
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L163-163
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    160:             // Example usage - in production, these would come from validated user input
    161:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    162:             System.out.println("Command output: " + result);
    163:         } catch (Exception e) {
    164:             // In production, log only errorId and send details to secure error collector
    165:             String errorId = UUID.randomUUID().toString();
    166:             System.err.println("ERROR_ID: " + errorId + " - Execution failed: " + e.getClass().getSimpleName());
  ```
Case #282
- Before: 1
- After:  0
- Status: CLEAN
Case #286
- Before: 0
- After:  0
- Status: CLEAN
Case #279
- Before: 0
- After:  0
- Status: CLEAN
Case #275
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L77-77
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     74:             new SecureRandom().nextBytes(iv);
     75:
     76:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     77:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     78:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     79:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     80:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #281
- Before: 0
- After:  0
- Status: CLEAN
Case #277
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:
     28:         // Example user input (in real app, this would come from user input)
     29:         String username = "testUser";
     30:         String password = "testPassword";
     31:
     32:         // Input validation (basic example - adjust based on actual requirements)
     33:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #283
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L171-171
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    168:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    169:             System.out.println("Command output:");
    170:             System.out.println(result);
    171:         } catch (Exception e) {
    172:             // In production, log errorId to secure error collector
    173:             System.err.println("Error: An error occurred");
    174:         }
  ```
Case #280
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #289
- Before: 0
- After:  0
- Status: CLEAN
Case #293
- Before: 1
- After:  0
- Status: CLEAN
Case #284
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     68:
     69:             // Secure AES-GCM encryption implementation
     70:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     71:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     72:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     73:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     74:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     56:             }
     57:
     58:             // Decode base64 encoded key
     59:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     60:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     61:                 logger.severe("Invalid encryption key length");
     62:                 throw new IOException("Invalid encryption key");
  ```
Case #285
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L169-169
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    166:             // Example secret retrieval
    167:             String apiKey = executor.getSecureSecret("PRODUCTION_API_KEY");
    168:             System.out.println("API Key retrieved successfully");
    169:         } catch (Exception e) {
    170:             // In production, log errorId to secure error collector
    171:             String errorId = UUID.randomUUID().toString();
    172:             System.err.println("Error occurred: " + errorId);
  ```
Case #291
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #287
- Before: 0
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L172-172
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    169:             // Example usage - should be externalized in production
    170:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    171:             System.out.println("Command output:\n" + result);
    172:         } catch (Exception e) {
    173:             // Use instance variables instead of creating new instances
    174:             String errorId = executor.generateOpaqueErrorId();
    175:             executor.logError(errorId, "Execution failed", e);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L134-134
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    131:         // Use secure random generator with Base64 encoding for compactness
    132:         byte[] randomBytes = new byte[32]; // Increased from 16 to 32 bytes for better entropy
    133:         new SecureRandom().nextBytes(randomBytes);
    134:         return Base64.getEncoder().withoutPadding().encodeToString(randomBytes);
    135:     }
    136:
    137:     /**
  ```
Case #292
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L174-174
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    171:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    172:             System.out.println("Command output:");
    173:             System.out.println(result);
    174:         } catch (Exception e) {
    175:             // In production, log errorId to secure error collector
    176:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    177:         }
  ```
Case #290
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L120-120
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    117:             String errorId = UUID.randomUUID().toString();
    118:             logError(errorId, "IO error during command execution", e);
    119:             throw new IOException("IO error during command execution", e);
    120:         } catch (Exception e) {
    121:             String errorId = UUID.randomUUID().toString();
    122:             logError(errorId, "Unexpected error during command execution", e);
    123:             throw new IOException("Command execution failed", e);
  ```
Case #300
- Before: 1
- After:  0
- Status: CLEAN
Case #298
- Before: 0
- After:  0
- Status: CLEAN
Case #288
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L69-69
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     66:             new SecureRandom().nextBytes(iv);
     67:
     68:             // AES-GCM encryption implementation with provider specification
     69:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", CRYPTOGRAPHY_PROVIDER);
     70:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     71:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #295
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #304
- Before: 0
- After:  0
- Status: CLEAN
Case #299
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #296
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #297
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     80:             new SecureRandom().nextBytes(iv);
     81:
     82:             // Secure AES-GCM encryption implementation
     83:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     84:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     85:             cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);
     86:
  ```
Case #294
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L85-85
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     82:             new SecureRandom().nextBytes(randomBytes);
     83:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     84:             byte[] hash = digest.digest(randomBytes);
     85:             return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
     86:         } catch (NoSuchAlgorithmException e) {
     87:             // This should never happen as SHA-256 is a standard algorithm
     88:             return "FATAL_ERROR";
  ```
Case #301
- Before: 0
- After:  0
- Status: CLEAN
Case #306
- Before: 0
- After:  0
- Status: CLEAN
Case #305
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #309
- Before: 0
- After:  0
- Status: CLEAN
Case #311
- Before: 1
- After:  0
- Status: CLEAN
Case #303
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     60:             new SecureRandom().nextBytes(iv);
     61:
     62:             // Secure AES-GCM encryption implementation
     63:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     64:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     65:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     66:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #312
- Before: 0
- After:  0
- Status: CLEAN
Case #307
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L158-158
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    155:             logError(errorId, "Command execution interrupted", e);
    156:             Thread.currentThread().interrupt();  // Restore interrupt status
    157:             throw new IOException("Command execution interrupted");
    158:         } catch (Exception e) {
    159:             String errorId = UUID.randomUUID().toString();
    160:             logError(errorId, "Unexpected error during command execution", e);
    161:             throw new IOException("Command execution failed");
  ```
Case #310
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L173-173
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    170:             SecureProcessExecutor executor = new SecureProcessExecutor();
    171:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    172:             System.out.println("Command output:\n" + result);
    173:         } catch (Exception e) {
    174:             System.err.println("Error: An error occurred");
    175:             // Error details are logged internally with errorId
    176:         }
  ```
Case #308
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #318
- Before: 1
- After:  0
- Status: CLEAN
Case #320
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L31-31
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     28:             // Generate opaque error ID
     29:             byte[] errorIdBytes = new byte[16];
     30:             new SecureRandom().nextBytes(errorIdBytes);
     31:             String errorId = Base64.getUrlEncoder().withoutPadding().encodeToString(errorIdBytes);
     32:
     33:             // Send detailed error to secure error collector (not shown here)
     34:             // SecureErrorCollector.send(e, errorId);
  ```
Case #302
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #316
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L201-201
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    198:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    199:             System.out.println("Command output:");
    200:             System.out.println(result);
    201:         } catch (Exception e) {
    202:             // In production, log errorId to secure error collector
    203:             System.err.println("Error: An error occurred");
    204:             // Stack traces only in debug mode
  ```
Case #313
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #314
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #323
- Before: 0
- After:  0
- Status: CLEAN
Case #319
- Before: 0
- After:  0
- Status: CLEAN
Case #315
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L228-228
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    225:             // Example usage - should be externalized in production
    226:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    227:             System.out.println("Command output:\n" + result);
    228:         } catch (Exception e) {
    229:             String errorId = UUID.randomUUID().toString();
    230:             System.err.println("Execution failed: " + errorId);
    231:             // In production, send error details to a secure error collector
  ```
Case #326
- Before: 0
- After:  0
- Status: CLEAN
Case #321
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L24-24
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     21:             byte[] bytes = byteOut.toByteArray();
     22:
     23:             // Safe deserialization with validation
     24:             try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes))) {
     25:                 // Enable validation during deserialization
     26:                 in.setObjectInputFilter((desc, depth) -> {
     27:                     String className = desc.getType().getName();
  ```
Case #322
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L47-47
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     44:             if (Boolean.getBoolean("debug")) {
     45:                 e.printStackTrace();
     46:             }
     47:         } catch (Exception e) {
     48:             String errorId = generateSecureErrorId();
     49:             logger.severe("Unexpected error occurred: " + errorId);
     50:
  ```
Case #331
- Before: 4
- After:  0
- Status: CLEAN
Case #325
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L29-29
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     26:             } catch (IOException e) {
     27:                 byte[] errorIdBytes = new byte[16];
     28:                 random.nextBytes(errorIdBytes);
     29:                 String errorId = ERROR_ID_PREFIX + "-" + Base64.getEncoder().encodeToString(errorIdBytes);
     30:
     31:                 String hash;
     32:                 try {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     37:                     byte[] saltedInput = new byte[salt.length + inputBytes.length];
     38:                     System.arraycopy(salt, 0, saltedInput, 0, salt.length);
     39:                     System.arraycopy(inputBytes, 0, saltedInput, salt.length, inputBytes.length);
     40:                     hash = Base64.getEncoder().encodeToString(digest.digest(saltedInput));
     41:                 } catch (NoSuchAlgorithmException ex) {
     42:                     hash = "HASHING_FAILED";
     43:                 }
  ```
Case #317
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L190-190
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    187:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    188:             System.out.println("Command output:");
    189:             System.out.println(result);
    190:         } catch (Exception e) {
    191:             // In production, log errorId to secure error collector
    192:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    193:         }
  ```
Case #334
- Before: 1
- After:  0
- Status: CLEAN
Case #329
- Before: 3
- After:  0
- Status: CLEAN
Case #335
- Before: 2
- After:  0
- Status: CLEAN
Case #333
- Before: 0
- After:  0
- Status: CLEAN
Case #332
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #336
- Before: 1
- After:  0
- Status: CLEAN
Case #330
- Before: 2
- After:  3
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     68:
     69:             // Execute command safely (if needed)
     70:             executeCommand(deserialized.command);
     71:         } catch (Exception ex) {
     72:             // Log error securely (in production, send errorId to secure collector)
     73:             System.err.println("An error occurred: " + ex.getClass().getSimpleName());
     74:             // In debug mode, log stack trace
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L65-65
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     62:             oos.flush();
     63:
     64:             // Deserialize with integrity check
     65:             ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
     66:             SecureDeserialization deserialized = (SecureDeserialization) ois.readObject();
     67:             ois.close();
     68:
  ```
- [3] Scanner=horusec, CWE-0, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     37:         try {
     38:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     39:             byte[] digest = md.digest(data.getBytes());
     40:             return Base64.getEncoder().encodeToString(digest);
     41:         } catch (NoSuchAlgorithmException e) {
     42:             throw new RuntimeException("SHA-256 not available", e);
     43:         }
  ```
Case #340
- Before: 1
- After:  0
- Status: CLEAN
Case #328
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #327
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L29-29
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     26:                 pb.command("C:\\Windows\\System32\\cmd.exe", "/c", "echo", "default");
     27:             }
     28:             pb.start();
     29:         } catch (Exception e) {
     30:             String errorId = UUID.randomUUID().toString();
     31:             logError(errorId, e);
     32:             throw new Exception("Command execution failed: " + errorId);
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L77-78
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     74:
     75:             byte[] serializedData = bos.toByteArray();
     76:
     77:             try (ObjectInputStream ois = new ObjectInputStream(
     78:                     new ByteArrayInputStream(serializedData))) {
     79:                 ois.setObjectInputFilter((desc, depth) -> {
     80:                     if (desc == null) {
     81:                         return ObjectInputFilter.Status.REJECTED;
  ```
Case #339
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #338
- Before: 2
- After:  0
- Status: CLEAN
Case #341
- Before: 0
- After:  0
- Status: CLEAN
Case #346
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L171-171
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    168:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    169:             System.out.println("Command output:");
    170:             System.out.println(result);
    171:         } catch (Exception e) {
    172:             // In production, log errorId to secure error collector
    173:             System.err.println("Error: An error occurred");
    174:         }
  ```
Case #350
- Before: 3
- After:  0
- Status: CLEAN
Case #343
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     37:             }
     38:
     39:             // 2. Decode and validate key
     40:             byte[] decodedKey = Base64.getDecoder().decode(encodedSecret);
     41:             if (decodedKey.length != KEY_SIZE_BYTES) {
     42:                 logger.severe("Invalid key length");
     43:                 System.err.println("An error occurred (ERR-SEC-002)");
  ```
Case #337
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #324
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #345
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L241-241
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    238:             // Example usage - should use externalized inputs in production
    239:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    240:             System.out.println("Command output: " + result);
    241:         } catch (Exception e) {
    242:             // In production, log errorId and send details to secure error collector
    243:             String errorId = UUID.randomUUID().toString();
    244:             logError(errorId, "Execution failed");
  ```
- [2] Scanner=semgrep, CWE-704, Lines=L145-161
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
    142:      * @param data data to hash
    143:      * @return SHA-256 hash of the data
    144:      */
    145:     private String hashSensitiveData(String data) {
    146:         try {
    147:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    148:             byte[] hash = digest.digest(data.getBytes());
    149:             StringBuilder hexString = new StringBuilder();
    150:             for (byte b : hash) {
    151:                 String hex = Integer.toHexString(0xff & b);
    152:                 if (hex.length() == 1) hexString.append('0');
    153:                 hexString.append(hex);
    154:             }
    155:             return hexString.toString();
    156:         } catch (NoSuchAlgorithmException e) {
    157:             String errorId = generateErrorId();
    158:             logError(errorId, "Hashing algorithm not found", e);
    159:             return "HASHING_FAILED";
    160:         }
    161:     }
    162:
    163:     /**
    164:      * Gets the absolute path of a command to prevent path traversal attacks
  ```
Case #349
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L186-186
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    183:             // Example usage - should be replaced with actual use case
    184:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    185:             System.out.println("Command output: " + result);
    186:         } catch (Exception e) {
    187:             // In production, errorId would be logged and sent to error collector
    188:             System.err.println("Error occurred. Please check logs for ERROR_ID.");
    189:         }
  ```
Case #342
- Before: 0
- After:  0
- Status: CLEAN
Case #348
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #352
- Before: 0
- After:  0
- Status: CLEAN
Case #351
- Before: 0
- After:  0
- Status: CLEAN
Case #359
- Before: 2
- After:  0
- Status: CLEAN
Case #347
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L152-152
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    149:             // Example of secure configuration retrieval
    150:             String apiKey = executor.getSecureConfig("PRODUCTION_API_KEY");
    151:             System.out.println("API key retrieved successfully");
    152:         } catch (Exception e) {
    153:             String errorId = UUID.randomUUID().toString();
    154:             executor.logError(errorId, "Exception during execution");
    155:             System.err.println("An error occurred");
  ```
Case #353
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #363
- Before: 0
- After:  0
- Status: CLEAN
Case #358
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L51-51
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     48:             String errorId = UUID.randomUUID().toString();
     49:             byte[] errorIdBytes = new byte[16];
     50:             new SecureRandom().nextBytes(errorIdBytes);
     51:             String opaqueErrorId = Base64.getUrlEncoder().encodeToString(hashBytes(errorIdBytes));
     52:             logger.severe("An error occurred: " + opaqueErrorId);
     53:             // In production, send opaqueErrorId and t to a secure error collector
     54:             // (e.g., via a logging framework or error reporting service)
  ```
Case #356
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     74:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     75:
  ```
Case #360
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #357
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     34:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_LENGTH = 1024;
     36:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #362
- Before: 5
- After:  0
- Status: CLEAN
Case #361
- Before: 0
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L201-201
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    198:                 e.printStackTrace(pw);
    199:                 System.err.println(sw.toString());
    200:             }
    201:         } catch (Exception e) {
    202:             // Catch-all for unexpected exceptions
    203:             String errorId = executor.generateOpaqueErrorId();
    204:             executor.logError(errorId, "Unexpected exception", e);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L158-158
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    155:         byte[] randomBytes = new byte[32]; // Increased size for better uniqueness
    156:         SecureRandom random = new SecureRandom();
    157:         random.nextBytes(randomBytes);
    158:         return Base64.getEncoder().encodeToString(randomBytes); // Using standard Base64 encoding
    159:     }
    160:
    161:     /**
  ```
Case #344
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #368
- Before: 0
- After:  0
- Status: CLEAN
Case #364
- Before: 3
- After:  0
- Status: CLEAN
Case #354
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #367
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L36-36
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     33:             String errorId = UUID.randomUUID().toString();
     34:             logger.severe("Error reading file: " + errorId);
     35:             sendErrorToCollector(errorId, e);
     36:         } catch (Exception e) {
     37:             String errorId = UUID.randomUUID().toString();
     38:             logger.severe("Unexpected error: " + errorId);
     39:             sendErrorToCollector(errorId, e);
  ```
Case #355
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     59:                     String errorId = "ERR-DESERIALIZATION-004";
     60:                     logger.warning("Deserialization failed: " + errorId);
     61:                     throw new RuntimeException(errorId);
     62:                 } catch (Exception ex) {
     63:                     String errorId = "ERR-DESERIALIZATION-005";
     64:                     logger.warning("Deserialization failed: " + errorId);
     65:                     throw new RuntimeException(errorId);
  ```
Case #365
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(cipherText, 0, encryptedData, iv.length, cipherText.length);
     82:             System.arraycopy(authTag, 0, encryptedData, iv.length + cipherText.length, authTag.length);
     83:
     84:             return Base64.getEncoder().encodeToString(encryptedData);
     85:
     86:         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
     87:                  IllegalBlockSizeException | BadPaddingException e) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode and validate key
     58:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     59:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #370
- Before: 0
- After:  0
- Status: CLEAN
Case #378
- Before: 4
- After:  0
- Status: CLEAN
Case #366
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     74:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     75:
  ```
Case #369
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     79:             new SecureRandom().nextBytes(iv);
     80:
     81:             // AES-GCM encryption implementation with explicit provider
     82:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     83:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     84:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     85:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #371
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #375
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L178-178
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    175:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    176:             System.out.println("Command output:");
    177:             System.out.println(result);
    178:         } catch (Exception e) {
    179:             // In production, log errorId to secure error collector
    180:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    181:         }
  ```
Case #376
- Before: 3
- After:  0
- Status: CLEAN
Case #374
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #373
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #383
- Before: 2
- After:  0
- Status: CLEAN
Case #384
- Before: 2
- After:  0
- Status: CLEAN
Case #377
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     74:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     75:
  ```
Case #389
- Before: 1
- After:  0
- Status: CLEAN
Case #380
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:             }
     73:
     74:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     76:             byte[] iv = new byte[GCM_IV_LENGTH];
     77:             new SecureRandom().nextBytes(iv);
     78:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
  ```
Case #372
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #381
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #390
- Before: 1
- After:  0
- Status: CLEAN
Case #382
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #387
- Before: 0
- After:  0
- Status: CLEAN
Case #386
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L54-54
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     51:             }
     52:
     53:             // Decode and validate key
     54:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     55:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     56:                 logger.severe("Encryption key has invalid length");
     57:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #388
- Before: 1
- After:  0
- Status: CLEAN
Case #385
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #391
- Before: 2
- After:  2
- Status: SAME

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, read from secure input source)
     17:         String username = "testUser123";
     18:         String password = "SecurePass123!";
     19:
     20:         // Validate inputs before processing
     21:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L96-96
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     93:     private static String hashPassword(String password) {
     94:         try {
     95:             // In production, use PBKDF2, bcrypt, or Argon2 with salt
     96:             return java.util.Base64.getEncoder().encodeToString(
     97:                 java.security.MessageDigest.getInstance("SHA-256")
     98:                     .digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8))
     99:             );
  ```
Case #392
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #379
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L86-86
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     83:             new SecureRandom().nextBytes(iv);
     84:
     85:             // AES-GCM encryption implementation
     86:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     87:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     88:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     89:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #396
- Before: 0
- After:  0
- Status: CLEAN
Case #394
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     37:             }
     38:
     39:             System.out.println(obj);
     40:         } catch (Exception e) {
     41:             String errorId = generateSecureErrorId();
     42:             String safeMessage = String.format(ERROR_LOG_TEMPLATE, "Deserialization failed", errorId);
     43:             logger.severe(safeMessage);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L57-57
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     54:             byte[] bytes = new byte[32]; // Increased size for better entropy
     55:             random.nextBytes(bytes);
     56:             byte[] hash = MessageDigest.getInstance("SHA-256").digest(bytes);
     57:             return Base64.getEncoder().encodeToString(hash).replace('=', 'A').replace('+', 'B').replace('/', 'C');
     58:         } catch (NoSuchAlgorithmException e) {
     59:             // This should never happen with SHA-256
     60:             return "FALLBACK_ERROR_ID";
  ```
Case #393
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     68:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     69:             digest.update(randomBytes);
     70:             byte[] hash = digest.digest();
     71:             byte[] encodedHash = Base64.getUrlEncoder().withoutPadding().encode(hash);
     72:             return new String(encodedHash);
     73:         } catch (NoSuchAlgorithmException e) {
     74:             // Fallback to non-cryptographic ID in case of algorithm failure
  ```
Case #399
- Before: 0
- After:  0
- Status: CLEAN
Case #395
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    162:             // Example secret retrieval
    163:             String apiKey = executor.getSecureSecret("PRODUCTION_API_KEY");
    164:             System.out.println("API Key retrieved successfully");
    165:         } catch (Exception e) {
    166:             // In production, log errorId to secure error collector
    167:             String errorId = UUID.randomUUID().toString();
    168:             System.err.println("Error occurred: " + errorId);
  ```
Case #398
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #400
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
Case #405
- Before: 1
- After:  0
- Status: CLEAN
Case #401
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-704, Lines=L51-74
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     48:         }
     49:     }
     50:
     51:     private static String generateErrorId() {
     52:         try {
     53:             byte[] randomBytes = new byte[16];
     54:             new SecureRandom().nextBytes(randomBytes);
     55:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     56:             byte[] hash = digest.digest(randomBytes);
     57:             StringBuilder hexString = new StringBuilder();
     58:             for (byte b : hash) {
     59:                 String hex = Integer.toHexString(0xff & b);
     60:                 if (hex.length() == 1) {
     61:                     hexString.append('0');
     62:                 }
     63:                 hexString.append(hex);
     64:             }
     65:             return hexString.toString();
     66:         } catch (NoSuchAlgorithmException e) {
     67:             String errorId = "ERR-0000";
     68:             logger.severe("Error generating error ID: " + errorId);
     69:             if (Boolean.getBoolean("debug")) {
     70:                 logger.throwing("Main", "generateErrorId", e);
     71:             }
     72:             return errorId;
     73:         }
     74:     }
     75: }
  ```
Case #407
- Before: 2
- After:  0
- Status: CLEAN
Case #408
- Before: 2
- After:  0
- Status: CLEAN
Case #397
- Before: 2
- After:  2
- Status: SAME

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L67-67
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     64:         }
     65:
     66:         // Use ObjectInputStream with allowlist
     67:         try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(actualData))) {
     68:             Class<?> loadedClass = Class.forName("com.example.SafeClass");
     69:             if (!ALLOWLIST.containsValue(loadedClass)) {
     70:                 throw new InvalidClassException(loadedClass.getName(), "Class not in allowlist");
  ```
- [2] Scanner=horusec, CWE-0, Lines=L79-79
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     76:     private static String calculateHmacSHA256(byte[] data, String key) throws NoSuchAlgorithmException {
     77:         // In production, use a proper HMAC implementation (e.g., javax.crypto.Mac)
     78:         // This is a placeholder for demonstration purposes
     79:         return Base64.getEncoder().encodeToString(MessageDigest.getInstance("SHA-256").digest(key.getBytes()));
     80:     }
     81:
     82:     // Example safe class for serialization
  ```
Case #403
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #402
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-326, Lines=L15-15
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     12:     public static void main(String[] args) {
     13:         try {
     14:             // Load SSLContext with default truststore (can be replaced with custom keystore)
     15:             SSLContext sslContext = SSLContext.getInstance("TLS");
     16:             sslContext.init(null, null, null); // Uses default TrustManager
     17:
     18:             SSLServerSocketFactory factory = sslContext.getServerSocketFactory();
  ```
Case #404
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L117-117
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    114:     private String generateOpaqueErrorId() {
    115:         byte[] randomBytes = new byte[16];
    116:         new SecureRandom().nextBytes(randomBytes);
    117:         return Base64.getEncoder().encodeToString(randomBytes);
    118:     }
    119:
    120:     /**
  ```
Case #406
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:
     73:             // Secure AES-GCM encryption implementation
     74:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     76:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     78:
  ```
Case #415
- Before: 3
- After:  0
- Status: CLEAN
Case #409
- Before: 0
- After:  5
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L112-112
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
    109:      * @return true if sensitive data is present
    110:      */
    111:     private boolean containsSensitiveData(String line) {
    112:         return line.matches(".*(password|secret|key|token|credential|ssn|password=|secret=|key=|token=|credential=|ssn=).*");
    113:     }
    114:
    115:     /**
  ```
- [2] Scanner=horusec, CWE-704, Lines=L128-128
  Reason: (1/1) * Possible vulnerability detected: Bad hexadecimal concatenation
When converting a byte array containing a hash signature to a human readable string, a conversion mistake can be made if the array is read byte by byte. The following sample illustrates the use of the method Integer.toHexString() which will trim any leading zeroes from each byte of the computed hash value. For more information checkout the CWE-704 (https://cwe.mitre.org/data/definitions/704.html) advisory.
  Code snippet:
  ```
    125:             try (BufferedReader reader = new BufferedReader(
    126:                     new InputStreamReader(process.getInputStream()))) {
    127:                 String path = reader.readLine();
    128:                 if (path != null && !path.isEmpty() && Files.isExecutable(Paths.get(path)) &&
    129:                     path.matches("^/[a-zA-Z0-9/_\\-\\.]+$")) {
    130:                     return path;
    131:                 }
  ```
- [3] Scanner=horusec, CWE-209, Lines=L201-201
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    198:             String[] arguments = {"-c", "3", "8.8.8.8"};
    199:             String result = executor.executeCommand("ping", arguments);
    200:             System.out.println("Command result:" + System.lineSeparator() + result);
    201:         } catch (Exception e) {
    202:             // In production, log errorId to secure error collector
    203:             String errorId = UUID.randomUUID().toString();
    204:             System.err.println("Error ID: " + errorId + ". An error occurred");
  ```
- [4] Scanner=horusec, CWE-0, Lines=L145-145
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    142:      * @return unique error identifier
    143:      */
    144:     private String generateErrorId() {
    145:         return Base64.getEncoder().encodeToString(UUID.randomUUID().toByteArray());
    146:     }
    147:
    148:     /**
  ```
- [5] Scanner=horusec, CWE-0, Lines=L167-167
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    164:         try {
    165:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    166:             byte[] hash = digest.digest(message.getBytes());
    167:             return Base64.getEncoder().encodeToString(hash);
    168:         } catch (NoSuchAlgorithmException e) {
    169:             return "HASH_ERROR";
    170:         }
  ```
Case #411
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L27-27
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     24:             }
     25:
     26:             Files.createFile(safePath);
     27:         } catch (Exception e) {
     28:             String errorId = UUID.randomUUID().toString();
     29:             // Send error details to secure error collector (not shown here)
     30:             System.err.println("Deserialization error: " + errorId);
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L54-54
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     51:             oos.close();
     52:
     53:             ByteArrayInputStream bin = new ByteArrayInputStream(bos.toByteArray());
     54:             ObjectInputStream ois = new ObjectInputStream(bin);
     55:             ois.setObjectInputFilter(WHITELIST_FILTER);
     56:
     57:             Object obj = ois.readObject();
  ```
Case #414
- Before: 2
- After:  0
- Status: CLEAN
Case #410
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #412
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             // Example usage - in production, these would come from validated user input
    162:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    163:             System.out.println("Command output: " + result);
    164:         } catch (Exception e) {
    165:             String errorId = UUID.randomUUID().toString();
    166:             logError(errorId, "Exception occurred during command execution", e);
    167:             System.err.println("Error: An error occurred");
  ```
Case #421
- Before: 2
- After:  0
- Status: CLEAN
Case #418
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #419
- Before: 3
- After:  0
- Status: CLEAN
Case #420
- Before: 0
- After:  0
- Status: CLEAN
Case #416
- Before: 1
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-77
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data in logs)
     53:             StringBuilder output = new StringBuilder();
     54:             try (BufferedReader processReader = new BufferedReader(
     55:                     new InputStreamReader(process.getInputStream()))) {
     56:                 String line;
     57:                 while ((line = processReader.readLine()) != null) {
     58:                     output.append(line).append(System.lineSeparator());
     59:                 }
     60:             }
     61:
     62:             int exitCode = process.waitFor();
     63:             if (exitCode != 0) {
     64:                 System.err.println("Command failed with exit code: " + exitCode);
     65:             } else {
     66:                 System.out.println("Command output:");
     67:                 System.out.println(output);
     68:             }
     69:
     70:         } catch (IOException | InterruptedException e) {
     71:             // Log error securely (no stack traces in production)
     72:             String errorId = UUID.randomUUID().toString();
     73:             System.err.println("An error occurred. Error ID: " + errorId);
     74:             // In production, send errorId + stack trace to secure error collector
     75:             e.printStackTrace(); // Only in debug mode
     76:         }
     77:     }
     78: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-77
  Reason: INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data in logs)
     53:             StringBuilder output = new StringBuilder();
     54:             try (BufferedReader processReader = new BufferedReader(
     55:                     new InputStreamReader(process.getInputStream()))) {
     56:                 String line;
     57:                 while ((line = processReader.readLine()) != null) {
     58:                     output.append(line).append(System.lineSeparator());
     59:                 }
     60:             }
     61:
     62:             int exitCode = process.waitFor();
     63:             if (exitCode != 0) {
     64:                 System.err.println("Command failed with exit code: " + exitCode);
     65:             } else {
     66:                 System.out.println("Command output:");
     67:                 System.out.println(output);
     68:             }
     69:
     70:         } catch (IOException | InterruptedException e) {
     71:             // Log error securely (no stack traces in production)
     72:             String errorId = UUID.randomUUID().toString();
     73:             System.err.println("An error occurred. Error ID: " + errorId);
     74:             // In production, send errorId + stack trace to secure error collector
     75:             e.printStackTrace(); // Only in debug mode
     76:         }
     77:     }
     78: }
  ```
Case #423
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-93, Lines=L19-55
  Reason: When data from an untrusted source is put into a logger and not neutralized correctly, an attacker could forge log entries or include malicious content.
  Code snippet:
  ```
     16:
     17:     protected void doPost(HttpServletRequest request, HttpServletResponse response)
     18:             throws ServletException, IOException {
     19:         String userInput = request.getParameter("userInput");
     20:         String errorId = null;
     21:
     22:         try {
     23:             // 1. Input validation (CWE-20: Improper Input Validation)
     24:             if (userInput == null || !userInput.matches(USERNAME_REGEX)) {
     25:                 logger.warning("Invalid username format: " + userInput);
     26:                 response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid input");
     27:                 return;
     28:             }
     29:
     30:             // 2. Use PreparedStatement to prevent SQL Injection (CWE-89)
     31:             try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
     32:                  PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE username = ?")) {
     33:
     34:                 stmt.setString(1, userInput);
     35:                 ResultSet rs = stmt.executeQuery();
     36:
     37:                 // 3. Process result securely
     38:                 if (rs.next()) {
     39:                     // Example: Return a generic success response
     40:                     response.getWriter().write("User found");
     41:                 } else {
     42:                     response.sendError(HttpServletResponse.SC_NOT_FOUND, "User not found");
     43:                 }
     44:             }
     45:         } catch (SQLException e) {
     46:             // 4. Secure error handling (CWE-209, CWE-778)
     47:             errorId = "ERR-" + System.currentTimeMillis() + "-" + java.util.UUID.randomUUID();
     48:             logger.severe("Database error: " + errorId + ". Details: " + e.getMessage());
     49:             response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "An error occurred");
     50:         } catch (Exception e) {
     51:             // 5. Catch-all for unexpected errors
     52:             errorId = "ERR-" + System.currentTimeMillis() + "-" + java.util.UUID.randomUUID();
     53:             logger.severe("Unexpected error: " + errorId + ". Details: " + e.getMessage());
     54:             response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "An error occurred");
     55:         }
     56:     }
     57: }
  ```
- [2] Scanner=horusec, CWE-79, Lines=L19-19
  Reason: (1/1) * Possible vulnerability detected: Potential XSS in Servlet
A potential XSS was found. It could be used to execute unwanted Script in a client's browser. For more information checkout the CWE-79 (https://cwe.mitre.org/data/definitions/79.html) advisory
  Code snippet:
  ```
     16:
     17:     protected void doPost(HttpServletRequest request, HttpServletResponse response)
     18:             throws ServletException, IOException {
     19:         String userInput = request.getParameter("userInput");
     20:         String errorId = null;
     21:
     22:         try {
  ```
Case #417
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L178-178
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    175:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    176:             System.out.println("Command output:");
    177:             System.out.println(result);
    178:         } catch (Exception e) {
    179:             // In production, log errorId to secure error collector
    180:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    181:         }
  ```
Case #424
- Before: 2
- After:  2
- Status: SAME

False Positives:
- generic FP: potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:     public static void main(String[] args) {
     23:         // Simulated user input (in real app, these would come from a secure form)
     24:         String username = "testUser";
     25:         String password = "secureP@ssw0rd";
     26:
     27:         // Validate inputs before use (OWASP Input Validation Cheat Sheet)
     28:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L94-94
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     91:     private static String hashPassword(String password) {
     92:         // TODO: Implement proper password hashing (e.g., using BCrypt or Argon2)
     93:         // This is a placeholder for demonstration purposes only
     94:         return "$2a$10$" + java.util.Base64.getEncoder().encodeToString(password.getBytes());
     95:     }
     96: }
  ```
Case #422
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L244-244
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    241:             // Example usage - should be externalized in production
    242:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    243:             System.out.println("Command result: " + result);
    244:         } catch (Exception e) {
    245:             // In production, log errorId to secure error collector
    246:             String errorId = UUID.randomUUID().toString();
    247:             System.err.println("ERROR [" + errorId + "]: An error occurred");
  ```
Case #413
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L95-95
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     92:                     // In production, send errorId to secure error collector
     93:                 }
     94:             }
     95:         } catch (Exception e) {
     96:             String errorId = "ERR-" + System.currentTimeMillis();
     97:             System.err.println("Server initialization failed: " + errorId);
     98:             // In production, send errorId and stack trace to secure error collector
  ```
- [2] Scanner=semgrep, CWE-326, Lines=L29-29
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     26:     public static void main(String[] args) {
     27:         try {
     28:             // Initialize SSLContext with secure defaults
     29:             SSLContext sslContext = SSLContext.getInstance("TLS");
     30:             sslContext.init(null, null, null); // Use default TrustManager and KeyManager
     31:
     32:             // Create SSLServerSocketFactory with secure defaults
  ```
Summary
=====
Total:    424
Clean:    216
Improved: 43
Same:     29
Worse:    136
