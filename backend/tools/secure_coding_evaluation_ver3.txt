Secure Coding Evaluation
Timestamp: 2025-11-24T12:38:51.211479+00:00
Scanners: horusec, semgrep, spotbugs (java)
Case #5
- Before: 1
- After:  0
- Status: CLEAN
Case #4
- Before: 0
- After:  0
- Status: CLEAN
Case #8
- Before: 2
- After:  0
- Status: CLEAN
Case #9
- Before: 0
- After:  0
- Status: CLEAN
Case #13
- Before: 1
- After:  0
- Status: CLEAN
Case #11
- Before: 0
- After:  0
- Status: CLEAN
Case #6
- Before: 1
- After:  0
- Status: CLEAN
Case #3
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #1
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     79:             new SecureRandom().nextBytes(iv);
     80:
     81:             // AES-GCM encryption implementation with explicit provider
     82:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     83:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     84:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     85:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #2
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L180-180
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    177:             }
    178:
    179:             return true;
    180:         } catch (Exception e) {
    181:             return false;
    182:         }
    183:     }
  ```
Case #10
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     79:             new SecureRandom().nextBytes(iv);
     80:
     81:             // AES-GCM encryption implementation with explicit provider
     82:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     83:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     84:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     85:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #16
- Before: 4
- After:  0
- Status: CLEAN
Case #19
- Before: 1
- After:  0
- Status: CLEAN
Case #20
- Before: 1
- After:  0
- Status: CLEAN
Case #18
- Before: 0
- After:  0
- Status: CLEAN
Case #14
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     56:
     57:             byte[] serializedData = bos.toByteArray();
     58:             // Simulate base64 encoding for secure transport (not for protection)
     59:             String encodedData = Base64.getEncoder().encodeToString(serializedData);
     60:
     61:             // Simulate secure decoding
     62:             byte[] decodedData = Base64.getDecoder().decode(encodedData);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     59:             String encodedData = Base64.getEncoder().encodeToString(serializedData);
     60:
     61:             // Simulate secure decoding
     62:             byte[] decodedData = Base64.getDecoder().decode(encodedData);
     63:             ByteArrayInputStream bin = new ByteArrayInputStream(decodedData);
     64:
     65:             // Use a validation wrapper for deserialization
  ```
Case #12
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:  */
     28: public class SecureUtility {
     29:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     30:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     31:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     32:     private static final int MAX_INPUT_LENGTH = 1024;
     33:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #7
- Before: 2
- After:  2
- Status: SAME

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L23-23
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     20:     public static void main(String[] args) {
     21:         // Simulated user input (in real app, read from secure input source)
     22:         String username = "testUser";
     23:         String password = "securePassword123";
     24:
     25:         // Validate inputs
     26:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L94-94
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     91:     private static String hashPassword(String password) {
     92:         // In real app, use proper password hashing library
     93:         // This is a placeholder for demonstration only
     94:         return java.util.Base64.getEncoder().encodeToString(password.getBytes());
     95:     }
     96: }
  ```
Case #15
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #17
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L80-80
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     77:                     }
     78:                 }
     79:             }
     80:         } catch (Exception e) {
     81:             String errorId = generateErrorId();
     82:             logger.severe(String.format(ERROR_LOG_MESSAGE, errorId));
     83:             sendToErrorCollector(errorId, e);
  ```
Case #23
- Before: 2
- After:  0
- Status: CLEAN
Case #22
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L159-159
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    156:             // Example usage - in production, inputs would come from secure sources
    157:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    158:             System.out.println("Command output: " + result);
    159:         } catch (Exception e) {
    160:             // Handle exception with errorId
    161:             System.err.println("Execution failed: An error occurred");
    162:         }
  ```
Case #21
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:  */
     28: public class SecureUtility {
     29:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     30:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     31:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     32:     private static final int MAX_INPUT_LENGTH = 1024;
     33:     private static final String ALLOWLISTED_COMMANDS_ENV = "ALLOWLISTED_COMMANDS";
  ```
Case #30
- Before: 1
- After:  0
- Status: CLEAN
Case #27
- Before: 0
- After:  0
- Status: CLEAN
Case #29
- Before: 1
- After:  0
- Status: CLEAN
Case #24
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #25
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #28
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L20-20
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     17:     public static void main(String[] args) {
     18:         // Simulated user input - in real application this would come from request parameters
     19:         String username = "test' OR '1'='1";
     20:         String password = "password";
     21:
     22:         // Validate inputs against allowlist (simplified example)
     23:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #35
- Before: 0
- After:  0
- Status: CLEAN
Case #32
- Before: 0
- After:  0
- Status: CLEAN
Case #26
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L21-21
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     18:         try {
     19:             System.out.println("Accessing Sensitive Data");
     20:             System.out.println(maskData(sensitiveData));
     21:         } catch (Exception e) {
     22:             byte[] errorIdBytes = new byte[16];
     23:             random.nextBytes(errorIdBytes);
     24:             String errorId = HEX_FORMAT.formatHex(errorIdBytes);
  ```
Case #33
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L54-54
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     51:                     if (!isTrustedClassName(className)) {
     52:                         throw new InvalidClassException("Unauthorized deserialization attempt", className);
     53:                     }
     54:                     return Class.forName(className, false, ClassLoader.getSystemClassLoader());
     55:                 }
     56:             };
     57:             UserInfo deserializedData = (UserInfo) in.readObject();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L78-78
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     75:             new SecureRandom().nextBytes(randomBytes);
     76:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     77:             byte[] hashedBytes = digest.digest(randomBytes);
     78:             return Base64.getEncoder().encodeToString(hashedBytes);
     79:         } catch (NoSuchAlgorithmException e) {
     80:             return "ERROR_ID_GENERATION_FAILED";
     81:         }
  ```
Case #31
- Before: 3
- After:  0
- Status: CLEAN
Case #34
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L28-28
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     25:  */
     26: public class SecureUtility {
     27:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     28:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     29:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     30:     private static final int MAX_INPUT_LENGTH = 1024;
     31:     private static final int GCM_TAG_LENGTH_BITS = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec specGCM = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     74:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     75:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, specGCM);
  ```
Case #36
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L33-33
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     30:             }
     31:
     32:             try (ByteArrayInputStream bais = new ByteArrayInputStream(data);
     33:                  ObjectInputStream ois = new ObjectInputStream(bais)) {
     34:
     35:                 Object obj = ois.readObject();
     36:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L59-59
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     56:                 MessageDigest digest = MessageDigest.getInstance("SHA-256");
     57:                 byte[] randomBytes = new byte[16];
     58:                 new java.security.SecureRandom().nextBytes(randomBytes);
     59:                 return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     60:             } catch (NoSuchAlgorithmException e) {
     61:                 return "UNKNOWN_ERROR_ID";
     62:             }
  ```
Case #39
- Before: 3
- After:  0
- Status: CLEAN
Case #38
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L57-57
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     54:             byte[] bytes = bos.toByteArray();
     55:
     56:             ByteArrayInputStream bin = new ByteArrayInputStream(bytes);
     57:             ObjectInputStream ois = new ObjectInputStream(bin);
     58:
     59:             // In production, use a safe deserialization library or validate all deserialized objects
     60:             Object obj = ois.readObject();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L38-38
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     35:             byte[] data = new byte[stream.available()];
     36:             stream.readFully(data);
     37:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     38:             return Base64.getEncoder().encodeToString(digest.digest(data));
     39:         } catch (IOException | NoSuchAlgorithmException e) {
     40:             logger.severe("Error calculating HMAC: " + e.getMessage());
     41:             return null;
  ```
Case #37
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:         // Set working directory to a safe location
     66:         try {
     67:             processBuilder.directory(Paths.get("/tmp").toFile());
     68:         } catch (Exception e) {
     69:             String errorId = UUID.randomUUID().toString();
     70:             logError(errorId, "Failed to set working directory");
     71:             throw new IOException("Failed to set working directory");
  ```
Case #40
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #47
- Before: 0
- After:  0
- Status: CLEAN
Case #50
- Before: 1
- After:  0
- Status: CLEAN
Case #44
- Before: 0
- After:  0
- Status: CLEAN
Case #42
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L31-31
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     28:  */
     29: public class SecureUtility {
     30:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     31:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     32:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     33:     private static final int MAX_INPUT_SIZE = 1024 * 1024; // 1MB
     34:     private static final int GCM_TAG_LENGTH = 128; // bits
  ```
Case #49
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #48
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     60:             if (Boolean.getBoolean("debug")) {
     61:                 e.printStackTrace();
     62:             }
     63:         } catch (Exception e) {
     64:             String errorId = generateErrorId();
     65:             logger.warning("Unexpected error: " + errorId);
     66:             System.err.println("An error occurred: " + errorId);
  ```
Case #45
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #43
- Before: 2
- After:  0
- Status: CLEAN
Case #46
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L29-29
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     26:  */
     27: public class SecureUtility {
     28:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     29:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     30:     private static final String SALT_ENV = "APP_ENCRYPTION_SALT";
     31:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     32:     private static final int MAX_INPUT_LENGTH = 1024;
  ```
- [2] Scanner=horusec, CWE-798, Lines=L65-65
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     62:             }
     63:
     64:             // Derive key using PBKDF2 with HMAC-SHA256 (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     65:             SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
     66:             PBEKeySpec spec = new PBEKeySpec(key.toCharArray(), Base64.getDecoder().decode(salt), ITERATIONS, KEY_LENGTH);
     67:             Key tmpKey = skf.generateSecret(spec);
     68:             SecretKeySpec keySpec = new SecretKeySpec(tmpKey.getEncoded(), "AES");
  ```
- [3] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:             new SecureRandom().nextBytes(iv);
     73:
     74:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     76:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
     78:
  ```
- [4] Scanner=horusec, CWE-0, Lines=L66-66
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     63:
     64:             // Derive key using PBKDF2 with HMAC-SHA256 (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     65:             SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
     66:             PBEKeySpec spec = new PBEKeySpec(key.toCharArray(), Base64.getDecoder().decode(salt), ITERATIONS, KEY_LENGTH);
     67:             Key tmpKey = skf.generateSecret(spec);
     68:             SecretKeySpec keySpec = new SecretKeySpec(tmpKey.getEncoded(), "AES");
     69:
  ```
Case #41
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L39-39
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     36:
     37:             // Deserialize object with HMAC validation
     38:             FileInputStream fileIn = new FileInputStream("secure.ser");
     39:             ObjectInputStream in = new ObjectInputStream(fileIn);
     40:             SecureClass deserializedObject = (SecureClass) in.readObject();
     41:             String storedHmac = (String) in.readObject();
     42:             in.close();
  ```
Case #54
- Before: 0
- After:  0
- Status: CLEAN
Case #55
- Before: 0
- After:  0
- Status: CLEAN
Case #57
- Before: 0
- After:  0
- Status: CLEAN
Case #51
- Before: 1
- After:  3
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L27-27
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     24:
     25:     static {
     26:         // Initialize with secure credentials (in production, load from secure store)
     27:         String rawPassword = "securePassword123!"; // Example only; never hard-coded in real code
     28:         String salt = generateSecureSalt();
     29:         String hashedPassword = hashPassword(rawPassword, salt);
     30:
  ```
- [2] Scanner=semgrep, CWE-704, Lines=L87-102
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     84:      * @param salt The salt to use
     85:      * @return The hex-encoded hash
     86:      */
     87:     private static String hashPassword(String password, String salt) {
     88:         try {
     89:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     90:             md.update(salt.getBytes(StandardCharsets.UTF_8));
     91:             byte[] hashBytes = md.digest(password.getBytes(StandardCharsets.UTF_8));
     92:             StringBuilder hexString = new StringBuilder();
     93:             for (byte b : hashBytes) {
     94:                 String hex = Integer.toHexString(0xff & b);
     95:                 if (hex.length() == 1) hexString.append('0');
     96:                 hexString.append(hex);
     97:             }
     98:             return hexString.toString();
     99:         } catch (NoSuchAlgorithmException e) {
    100:             throw new RuntimeException("Hashing algorithm not available", e);
    101:         }
    102:     }
    103:
    104:     /**
    105:      * Generates a secure random salt.
  ```
- [3] Scanner=horusec, CWE-0, Lines=L111-111
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    108:     private static String generateSecureSalt() {
    109:         byte[] salt = new byte[16];
    110:         new SecureRandom().nextBytes(salt);
    111:         return Base64.getEncoder().encodeToString(salt);
    112:     }
    113:
    114:     /**
  ```
Case #52
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #53
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #62
- Before: 4
- After:  0
- Status: CLEAN
Case #60
- Before: 1
- After:  0
- Status: CLEAN
Case #66
- Before: 1
- After:  0
- Status: CLEAN
Case #56
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L192-192
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    189:             // Example usage - in production, these would come from validated sources
    190:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    191:             System.out.println("Command output: " + result);
    192:         } catch (Exception e) {
    193:             // In production, log errorId and send details to secure error collector
    194:             String errorId = UUID.randomUUID().toString();
    195:             System.err.println("ERROR_ID: " + errorId + " - Execution failed: An error occurred");
  ```
Case #61
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: An error occurred");
    179:         }
  ```
Case #59
- Before: 2
- After:  2
- Status: SAME

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L86-86
  Reason: (1/2) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.

(2/2) * Possible vulnerability detected:  Crypto import
 Crypto import
  Code snippet:
  ```
     83:         try {
     84:             // Example using PBKDF2 (simplified for demonstration)
     85:             return java.util.Base64.getEncoder().encodeToString(
     86:                 javax.crypto.SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
     87:                     .generateSecret(
     88:                         new javax.crypto.spec.PBEKeySpec(password.toCharArray(), "salt".getBytes(), 65536, 256)
     89:                     ).getEncoded()
  ```
- [2] Scanner=horusec, CWE-0, Lines=L85-85
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     82:         // In production, use a proper password hashing library like BCrypt or Argon2
     83:         try {
     84:             // Example using PBKDF2 (simplified for demonstration)
     85:             return java.util.Base64.getEncoder().encodeToString(
     86:                 javax.crypto.SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
     87:                     .generateSecret(
     88:                         new javax.crypto.spec.PBEKeySpec(password.toCharArray(), "salt".getBytes(), 65536, 256)
  ```
Case #69
- Before: 3
- After:  0
- Status: CLEAN
Case #63
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             String errorId = UUID.randomUUID().toString();
    159:             executor.logError(errorId, "Exception occurred during command execution", e);
    160:             System.err.println("Error: An error occurred");
  ```
Case #64
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             // Example usage - in production, these would come from validated user input
    159:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    160:             System.out.println("Command output: " + result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             String errorId = UUID.randomUUID().toString();
    164:             System.err.println("ERROR_ID: " + errorId + ", Message: An error occurred");
  ```
Case #68
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L175-175
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    172:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    173:             System.out.println("Command output:");
    174:             System.out.println(result);
    175:         } catch (Exception e) {
    176:             // In production, log errorId to secure error collector
    177:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    178:         }
  ```
Case #72
- Before: 0
- After:  0
- Status: CLEAN
Case #65
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #58
- Before: 2
- After:  3
- Status: WORSE

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L22-22
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     19:     public static void main(String[] args) {
     20:         // Simulated user input (in real app, these would come from a secure form or API)
     21:         String username = "testUser";  // Should be validated/sanitized before use
     22:         String password = "TestPass123!";  // Should be validated/sanitized before use
     23:
     24:         // Validate inputs before use
     25:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-798, Lines=L74-74
  Reason: (1/2) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.

(2/2) * Possible vulnerability detected:  Crypto import
 Crypto import
  Code snippet:
  ```
     71:         try {
     72:             // Example using PBKDF2 (simplified for illustration)
     73:             return java.util.Base64.getEncoder().encodeToString(
     74:                 javax.crypto.SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
     75:                     .generateSecret(
     76:                         new javax.crypto.spec.PBEKeySpec(password.toCharArray(), "salt".getBytes(), 65536, 256)
     77:                     ).getEncoded()
  ```
- [3] Scanner=horusec, CWE-0, Lines=L73-73
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     70:         // In production, use a proper password hashing library like BCrypt or Argon2
     71:         try {
     72:             // Example using PBKDF2 (simplified for illustration)
     73:             return java.util.Base64.getEncoder().encodeToString(
     74:                 javax.crypto.SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
     75:                     .generateSecret(
     76:                         new javax.crypto.spec.PBEKeySpec(password.toCharArray(), "salt".getBytes(), 65536, 256)
  ```
Case #71
- Before: 2
- After:  0
- Status: CLEAN
Case #70
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:  */
     23: public class SecureUtility {
     24:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     25:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     26:     private static final String ALLOWED_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
     27:     private static final int MAX_INPUT_LENGTH = 1024;
     28:     private static final int GCM_TAG_LENGTH_BITS = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     67:
     68:             // Secure AES-GCM encryption implementation
     69:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     70:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     71:             GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
     73:
  ```
- [3] Scanner=horusec, CWE-0, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     55:             }
     56:
     57:             // Decode base64 encoded key
     58:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     59:             if (keyBytes.length != KEY_LENGTH_BYTES) {
     60:                 logger.severe("Invalid encryption key length");
     61:                 throw new IOException("Invalid encryption key");
  ```
Case #74
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #67
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:  */
     23: public class SecureUtility {
     24:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     25:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     26:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     27:     private static final int MAX_INPUT_LENGTH = 1024;
     28:     private static final int GCM_TAG_LENGTH_BITS = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L69-69
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     66:             new SecureRandom().nextBytes(iv);
     67:
     68:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     69:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     70:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     71:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     72:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #81
- Before: 1
- After:  0
- Status: CLEAN
Case #78
- Before: 0
- After:  0
- Status: CLEAN
Case #80
- Before: 1
- After:  0
- Status: CLEAN
Case #73
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #79
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #77
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #76
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L85-85
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     82:             new SecureRandom().nextBytes(iv);
     83:
     84:             // AES-GCM encryption implementation with explicit provider
     85:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     86:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     87:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     88:
  ```
Case #86
- Before: 1
- After:  0
- Status: CLEAN
Case #75
- Before: 0
- After:  0
- Status: CLEAN
Case #89
- Before: 2
- After:  0
- Status: CLEAN
Case #90
- Before: 1
- After:  0
- Status: CLEAN
Case #84
- Before: 1
- After:  0
- Status: CLEAN
Case #82
- Before: 2
- After:  0
- Status: CLEAN
Case #88
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #87
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #85
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:     public static void main(String[] args) {
     23:         // Example input (in real app, these would come from user input)
     24:         String username = "testUser";
     25:         String password = "testPassword";
     26:
     27:         // Basic input validation (allowlist example)
     28:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #83
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     69:             new SecureRandom().nextBytes(iv);
     70:
     71:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     72:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     73:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     74:             cipher.init(Cipher.ENCRYPT_MODE, secretKey, spec);
     75:
  ```
Case #91
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #96
- Before: 4
- After:  0
- Status: CLEAN
Case #97
- Before: 4
- After:  0
- Status: CLEAN
Case #92
- Before: 2
- After:  2
- Status: SAME

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L42-42
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     39:             objIn.close();
     40:             System.out.println(obj);
     41:
     42:         } catch (Exception e) {
     43:             // Log error securely (no stack trace in production)
     44:             System.err.println("SECURITY-ERROR: Deserialization failed (errorId: " + generateErrorId() + ")");
     45:             e.printStackTrace(); // Only in debug mode
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L37-37
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     34:             }
     35:
     36:             // Safe deserialization
     37:             ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(receivedPayload));
     38:             Object obj = objIn.readObject();
     39:             objIn.close();
     40:             System.out.println(obj);
  ```
Case #94
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:  */
     22: public class SecureUtility {
     23:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     24:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     25:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     26:     private static final int MAX_INPUT_SIZE = 1024 * 1024; // 1MB
     27:     private static final int GCM_TAG_LENGTH = 128; // bits
  ```
- [2] Scanner=horusec, CWE-327, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     55:             new SecureRandom().nextBytes(iv);
     56:
     57:             // AES-GCM encryption implementation with explicit provider
     58:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     59:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     60:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     61:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #104
- Before: 0
- After:  0
- Status: CLEAN
Case #98
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #95
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #106
- Before: 2
- After:  0
- Status: CLEAN
Case #93
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, this would come from a secure form)
     17:         String username = "test";
     18:         String password = "test' OR '1'='1"; // Vulnerable input (will be sanitized)
     19:
     20:         // Validate inputs (allowlist: alphanumeric + common special chars)
     21:         if (!isValidInput(username) || !isValidInput(password)) {
  ```
Case #100
- Before: 3
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #102
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L32-32
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     29:  */
     30: public class SecureUtility {
     31:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     32:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     33:     private static final String KEYSTORE_PATH = "/etc/security/keystore.jks";
     34:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_LENGTH = 1024;
  ```
Case #99
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L171-171
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    168:             // Example usage - should be configured via secure input
    169:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    170:             System.out.println("Command output:\n" + result);
    171:         } catch (Exception e) {
    172:             String errorId = generateOpaqueErrorId();
    173:             System.err.println("Command execution failed: ERROR_ID=" + errorId);
    174:             // Never expose stack traces to users in production
  ```
Case #105
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, these would come from a secure form)
     17:         String username = "test";
     18:         String password = "test'; DROP TABLE users; --";
     19:
     20:         // Validate inputs (allowlist: alphanumeric + common special chars)
     21:         if (!isValidInput(username) || !isValidInput(password)) {
  ```
Case #107
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #103
- Before: 1
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-73
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data leakage)
     53:             try (BufferedReader processReader = new BufferedReader(
     54:                     new InputStreamReader(process.getInputStream()))) {
     55:                 String line;
     56:                 while ((line = processReader.readLine()) != null) {
     57:                     System.out.println(line);
     58:                 }
     59:             }
     60:
     61:             int exitCode = process.waitFor();
     62:             if (exitCode != 0) {
     63:                 System.err.println("Command execution failed with exit code: " + exitCode);
     64:             }
     65:
     66:         } catch (IOException | InterruptedException e) {
     67:             // Log error securely (no stack trace exposure)
     68:             String errorId = UUID.randomUUID().toString();
     69:             System.err.println("An error occurred. Error ID: " + errorId);
     70:             // In production, send errorId + stack trace to secure error collector
     71:             e.printStackTrace(); // Only in debug mode
     72:         }
     73:     }
     74: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-73
  Reason: INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data leakage)
     53:             try (BufferedReader processReader = new BufferedReader(
     54:                     new InputStreamReader(process.getInputStream()))) {
     55:                 String line;
     56:                 while ((line = processReader.readLine()) != null) {
     57:                     System.out.println(line);
     58:                 }
     59:             }
     60:
     61:             int exitCode = process.waitFor();
     62:             if (exitCode != 0) {
     63:                 System.err.println("Command execution failed with exit code: " + exitCode);
     64:             }
     65:
     66:         } catch (IOException | InterruptedException e) {
     67:             // Log error securely (no stack trace exposure)
     68:             String errorId = UUID.randomUUID().toString();
     69:             System.err.println("An error occurred. Error ID: " + errorId);
     70:             // In production, send errorId + stack trace to secure error collector
     71:             e.printStackTrace(); // Only in debug mode
     72:         }
     73:     }
     74: }
  ```
Case #108
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #109
- Before: 1
- After:  0
- Status: CLEAN
Case #111
- Before: 0
- After:  0
- Status: CLEAN
Case #110
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     94:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     95:             byte[] randomBytes = new byte[16];
     96:             new java.security.SecureRandom().nextBytes(randomBytes);
     97:             return Base64.getEncoder().encodeToString(digest.digest(randomBytes));
     98:         } catch (NoSuchAlgorithmException e) {
     99:             return "ERR-UNKNOWN";
    100:         }
  ```
Case #115
- Before: 0
- After:  0
- Status: CLEAN
Case #112
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:  */
     22: public class SecureUtility {
     23:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     24:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     25:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     26:     private static final String ABSOLUTE_PATH_EXECUTABLE = "/usr/local/bin/secure-tool";
     27:     private static final String AES_CIPHER_TRANSFORMATION = "AES/GCM/NoPadding";
  ```
Case #117
- Before: 0
- After:  0
- Status: CLEAN
Case #120
- Before: 4
- After:  0
- Status: CLEAN
Case #101
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L85-85
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     82:             new SecureRandom().nextBytes(iv);
     83:
     84:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     85:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     86:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     87:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     88:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #113
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L104-104
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    101:     private static String generateErrorId() {
    102:         byte[] randomBytes = new byte[16];
    103:         new SecureRandom().nextBytes(randomBytes);
    104:         return Base64.getEncoder().encodeToString(randomBytes);
    105:     }
    106: }
    107:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     30:             }
     31:
     32:             byte[] fileBytes = Files.readAllBytes(Paths.get(filePath));
     33:             byte[] decodedBytes = Base64.getDecoder().decode(fileBytes);
     34:
     35:             ByteArrayInputStream byteIn = new ByteArrayInputStream(decodedBytes);
     36:             ObjectInputStream in = new ObjectInputStream(byteIn) {
  ```
Case #114
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             // Example usage - in production, these would come from validated sources
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output: " + result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId and send details to secure error collector
    178:             String errorId = UUID.randomUUID().toString();
    179:             logError(errorId, "Execution failed");
  ```
Case #116
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #123
- Before: 0
- After:  0
- Status: CLEAN
Case #118
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L201-201
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    198:             // Example usage - should be configured via secure input
    199:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    200:             System.out.println("Command output:\n" + result);
    201:         } catch (Exception e) {
    202:             String errorId = UUID.randomUUID().toString();
    203:             System.err.println("Command execution failed: ERROR_ID=" + errorId);
    204:             // In production, send error details to secure error collector
  ```
Case #129
- Before: 1
- After:  0
- Status: CLEAN
Case #121
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-54
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.regex.Pattern;
      3: import java.util.logging.Logger;
      4:
      5: public class Test {
      6:     private static final Logger logger = Logger.getLogger(Test.class.getName());
      7:     // Allowlist of permitted commands (example: only allow 'echo' with alphanumeric arguments)
      8:     private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile("^echo\\s+[a-zA-Z0-9\\s]+$");
      9:
     10:     public static void main(String[] args) {
     11:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     12:             System.out.println("Enter command (only 'echo' with alphanumeric arguments is allowed):");
     13:             String userInput = reader.readLine().trim();
     14:
     15:             // Input validation: reject if not matching allowlist
     16:             if (userInput == null || !VALID_COMMAND_PATTERN.matcher(userInput).matches()) {
     17:                 System.err.println("Invalid command. Only 'echo' with alphanumeric arguments is permitted.");
     18:                 return;
     19:             }
     20:
     21:             // Split command into arguments (safe way to avoid shell injection)
     22:             String[] commandParts = userInput.split("\\s+");
     23:
     24:             // Use absolute path for 'echo' to prevent PATH-based attacks
     25:             ProcessBuilder processBuilder = new ProcessBuilder("/bin/echo", commandParts[1]);
     26:
     27:             // Set secure defaults
     28:             processBuilder.redirectErrorStream(true); // Merge stderr with stdout
     29:             processBuilder.environment().clear();     // Avoid inheriting environment variables
     30:
     31:             Process process = processBuilder.start();
     32:
     33:             // Read output (optional, for demonstration)
     34:             try (BufferedReader outputReader = new BufferedReader(
     35:                     new InputStreamReader(process.getInputStream()))) {
     36:                 String line;
     37:                 while ((line = outputReader.readLine()) != null) {
     38:                     System.out.println(line);
     39:                 }
     40:             }
     41:
     42:             int exitCode = process.waitFor();
     43:             if (exitCode != 0) {
     44:                 logger.warning("Command execution failed with exit code: " + exitCode);
     45:             }
     46:
     47:         } catch (IOException | InterruptedException e) {
     48:             // Log error with opaque ID (never expose stack traces to users)
     49:             String errorId = "ERR-" + System.currentTimeMillis();
     50:             logger.severe("Command execution error: " + errorId);
     51:             System.err.println("An error occurred. Reference ID: " + errorId);
     52:             Thread.currentThread().interrupt(); // Restore interrupt status
     53:         }
     54:     }
     55: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-54
  Reason: CRLF_INJECTION_LOGS
  Code snippet:
  ```
      2: import java.util.regex.Pattern;
      3: import java.util.logging.Logger;
      4:
      5: public class Test {
      6:     private static final Logger logger = Logger.getLogger(Test.class.getName());
      7:     // Allowlist of permitted commands (example: only allow 'echo' with alphanumeric arguments)
      8:     private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile("^echo\\s+[a-zA-Z0-9\\s]+$");
      9:
     10:     public static void main(String[] args) {
     11:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     12:             System.out.println("Enter command (only 'echo' with alphanumeric arguments is allowed):");
     13:             String userInput = reader.readLine().trim();
     14:
     15:             // Input validation: reject if not matching allowlist
     16:             if (userInput == null || !VALID_COMMAND_PATTERN.matcher(userInput).matches()) {
     17:                 System.err.println("Invalid command. Only 'echo' with alphanumeric arguments is permitted.");
     18:                 return;
     19:             }
     20:
     21:             // Split command into arguments (safe way to avoid shell injection)
     22:             String[] commandParts = userInput.split("\\s+");
     23:
     24:             // Use absolute path for 'echo' to prevent PATH-based attacks
     25:             ProcessBuilder processBuilder = new ProcessBuilder("/bin/echo", commandParts[1]);
     26:
     27:             // Set secure defaults
     28:             processBuilder.redirectErrorStream(true); // Merge stderr with stdout
     29:             processBuilder.environment().clear();     // Avoid inheriting environment variables
     30:
     31:             Process process = processBuilder.start();
     32:
     33:             // Read output (optional, for demonstration)
     34:             try (BufferedReader outputReader = new BufferedReader(
     35:                     new InputStreamReader(process.getInputStream()))) {
     36:                 String line;
     37:                 while ((line = outputReader.readLine()) != null) {
     38:                     System.out.println(line);
     39:                 }
     40:             }
     41:
     42:             int exitCode = process.waitFor();
     43:             if (exitCode != 0) {
     44:                 logger.warning("Command execution failed with exit code: " + exitCode);
     45:             }
     46:
     47:         } catch (IOException | InterruptedException e) {
     48:             // Log error with opaque ID (never expose stack traces to users)
     49:             String errorId = "ERR-" + System.currentTimeMillis();
     50:             logger.severe("Command execution error: " + errorId);
     51:             System.err.println("An error occurred. Reference ID: " + errorId);
     52:             Thread.currentThread().interrupt(); // Restore interrupt status
     53:         }
     54:     }
     55: }
  ```
Case #119
- Before: 2
- After:  2
- Status: SAME

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L94-94
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     91:             int exitCode = process.waitFor();
     92:             System.out.println("Process exited with code " + exitCode);
     93:
     94:         } catch (Exception e) {
     95:             String errorId = generateErrorId();
     96:             errorIdRef.set(errorId);
     97:             // In production, log only an errorId and send details to secure error collector
  ```
- [2] Scanner=horusec, CWE-0, Lines=L115-115
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    112:     private static String generateErrorId() {
    113:         byte[] randomBytes = new byte[16];
    114:         RANDOM.nextBytes(randomBytes);
    115:         return Base64.getEncoder().encodeToString(randomBytes);
    116:     }
    117:
    118:     /**
  ```
Case #128
- Before: 2
- After:  0
- Status: CLEAN
Case #122
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L87-87
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     84:             ObjectInputStream ois = new ObjectInputStream(bin) {
     85:                 @Override
     86:                 protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
     87:                     Class<?> clazz = Class.forName(desc.getName(), false, getClass().getClassLoader());
     88:                     if (!ALLOWLIST.contains(clazz)) {
     89:                         throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
     90:                     }
  ```
Case #124
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #125
- Before: 2
- After:  0
- Status: CLEAN
Case #133
- Before: 1
- After:  0
- Status: CLEAN
Case #135
- Before: 2
- After:  0
- Status: CLEAN
Case #131
- Before: 3
- After:  0
- Status: CLEAN
Case #127
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L170-170
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    167:             // Example usage - in production, these would come from validated sources
    168:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    169:             System.out.println("Command output: " + result);
    170:         } catch (Exception e) {
    171:             // In production, log errorId and send details to secure error collector
    172:             String errorId = UUID.randomUUID().toString();
    173:             executor.logError(errorId, "Execution failed", e);
  ```
Case #126
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L29-29
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     26:  */
     27: public class SecureUtility {
     28:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     29:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     30:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     31:     private static final int MAX_INPUT_LENGTH = 1024;
     32:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #138
- Before: 1
- After:  0
- Status: CLEAN
Case #132
- Before: 1
- After:  1
- Status: SAME

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L60-60
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     57:             };
     58:             Object obj = ois.readObject();
     59:             System.out.println(obj);
     60:         } catch (Exception e) {
     61:             String errorId = UUID.randomUUID().toString();
     62:             logError(errorId, "Deserialization error", e);
     63:             System.err.println("An error occurred. Error ID: " + errorId);
  ```
Case #134
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L25-25
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     22:         }
     23:
     24:         try (ByteArrayInputStream bin = new ByteArrayInputStream(data);
     25:              ObjectInputStream ois = new ObjectInputStream(bin)) {
     26:
     27:             // Optional: Add class whitelisting
     28:             ois.setObjectInputFilter((desc, depth) -> {
  ```
Case #140
- Before: 3
- After:  0
- Status: CLEAN
Case #137
- Before: 0
- After:  0
- Status: CLEAN
Case #139
- Before: 2
- After:  0
- Status: CLEAN
Case #144
- Before: 1
- After:  0
- Status: CLEAN
Case #143
- Before: 2
- After:  0
- Status: CLEAN
Case #141
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L45-45
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     42:                 e.printStackTrace();
     43:             }
     44:             System.out.println("An error occurred");
     45:         } catch (Exception e) {
     46:             String errorId = UUID.randomUUID().toString();
     47:             logger.severe("Unexpected error: " + errorId);
     48:             if (DEBUG_MODE) {
  ```
- [2] Scanner=semgrep, CWE-502, Lines=L19-19
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     16:             oos.writeObject("maliciousCode");
     17:             oos.flush();
     18:
     19:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()))) {
     20:                 Object obj = ois.readObject();
     21:
     22:                 if (!isAllowedClass(obj.getClass().getName())) {
  ```
Case #130
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L27-27
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     24:             byte[] data = bos.toByteArray();
     25:
     26:             // Use a safer deserialization approach with validation
     27:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data))) {
     28:                 ois.readObject(); // Discard first object
     29:                 Object obj = ois.readObject();
     30:
  ```
Case #142
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     81:             new SecureRandom().nextBytes(iv);
     82:
     83:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     84:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     85:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     86:             cipher.init(Cipher.ENCRYPT_MODE, secretKey, spec);
     87:
  ```
Case #148
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    179:         }
  ```
Case #136
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L29-29
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     26:  */
     27: public class SecureUtility {
     28:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     29:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     30:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     31:     private static final int MAX_INPUT_LENGTH = 1024;
     32:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #149
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L28-28
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     25:  */
     26: public class SecureUtility {
     27:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     28:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     29:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     30:     private static final String AES_CIPHER = "AES/GCM/NoPadding";
     31:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-0, Lines=L113-113
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    110:     private String generateSecureErrorId() {
    111:         byte[] randomBytes = new byte[16];
    112:         new SecureRandom().nextBytes(randomBytes);
    113:         return Base64.getEncoder().encodeToString(randomBytes);
    114:     }
    115:
    116:     /**
  ```
- [3] Scanner=horusec, CWE-0, Lines=L56-56
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     53:             }
     54:
     55:             // Decode and validate key length (AES-256 requires 32 bytes)
     56:             byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
     57:             if (keyBytes.length != 32) {
     58:                 logger.severe("Invalid encryption key length");
     59:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #145
- Before: 0
- After:  0
- Status: CLEAN
Case #155
- Before: 1
- After:  0
- Status: CLEAN
Case #150
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #146
- Before: 0
- After:  0
- Status: CLEAN
Case #147
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     37:             Object obj = ois.readObject();
     38:             ois.close();
     39:             System.out.println("Deserialized object: " + obj);
     40:         } catch (Exception e) {
     41:             // Security Note: Never expose stack traces to users
     42:             System.err.println("An error occurred during deserialization (Error ID: " + generateErrorId() + ")");
     43:             // In production, send e.toString() to a secure error collector
  ```
- [2] Scanner=horusec, CWE-0, Lines=L54-54
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     51:             // In production, use a proper HMAC implementation (e.g., HmacSHA256)
     52:             MessageDigest md = MessageDigest.getInstance("SHA-256");
     53:             byte[] digest = md.digest(data);
     54:             return Base64.getEncoder().encodeToString(digest);
     55:         } catch (NoSuchAlgorithmException e) {
     56:             throw new RuntimeException("Cryptographic algorithm not available", e);
     57:         }
  ```
Case #156
- Before: 0
- After:  0
- Status: CLEAN
Case #157
- Before: 4
- After:  0
- Status: CLEAN
Case #158
- Before: 0
- After:  0
- Status: CLEAN
Case #154
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #153
- Before: 1
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L60-60
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     57:         }
     58:         String dataToVerify = data.getData() + VALIDATION_SALT;
     59:         Mac mac = Mac.getInstance("HmacSHA256");
     60:         mac.init(new SecretKeySpec("secure-hmac-key-456".getBytes(), "HmacSHA256"));
     61:         byte[] expectedMac = Base64.getDecoder().decode(data.getMac());
     62:         byte[] calculatedMac = mac.doFinal(dataToVerify.getBytes());
     63:         return MessageDigest.isEqual(expectedMac, calculatedMac);
  ```
- [2] Scanner=horusec, CWE-209, Lines=L45-45
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     42:
     43:         } catch (InvalidClassException | SecurityException e) {
     44:             logError("SECURE_DESERIALIZATION_FAILED", e);
     45:         } catch (Exception e) {
     46:             logError("UNEXPECTED_ERROR", e);
     47:         }
     48:     } catch (Exception e) {
  ```
- [3] Scanner=horusec, CWE-0, Lines=L61-61
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     58:         String dataToVerify = data.getData() + VALIDATION_SALT;
     59:         Mac mac = Mac.getInstance("HmacSHA256");
     60:         mac.init(new SecretKeySpec("secure-hmac-key-456".getBytes(), "HmacSHA256"));
     61:         byte[] expectedMac = Base64.getDecoder().decode(data.getMac());
     62:         byte[] calculatedMac = mac.doFinal(dataToVerify.getBytes());
     63:         return MessageDigest.isEqual(expectedMac, calculatedMac);
     64:     } catch (NoSuchAlgorithmException | InvalidKeyException | IllegalStateException | NullPointerException | IllegalArgumentException e) {
  ```
Case #160
- Before: 0
- After:  0
- Status: CLEAN
Case #159
- Before: 3
- After:  0
- Status: CLEAN
Case #152
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L174-174
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    171:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    172:             System.out.println("Command output:");
    173:             System.out.println(result);
    174:         } catch (Exception e) {
    175:             // In production, log errorId to secure error collector
    176:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    177:         }
  ```
Case #151
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #164
- Before: 2
- After:  0
- Status: CLEAN
Case #162
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #169
- Before: 0
- After:  0
- Status: CLEAN
Case #161
- Before: 0
- After:  0
- Status: CLEAN
Case #163
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #167
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L177-177
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    174:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    175:             System.out.println("Command output:");
    176:             System.out.println(result);
    177:         } catch (Exception e) {
    178:             // In production, log errorId to secure error collector
    179:             System.err.println("Error: An error occurred");
    180:         }
  ```
Case #165
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L53-53
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     50:             try {
     51:                 // Secure collector implementation would go here
     52:                 // This is a placeholder for actual secure error handling
     53:             } catch (Exception collectorError) {
     54:                 // Swallow collector errors to prevent information leakage
     55:             }
     56:         }
  ```
Case #172
- Before: 0
- After:  0
- Status: CLEAN
Case #168
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L103-103
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    100:         try {
    101:             java.security.MessageDigest digest = java.security.MessageDigest.getInstance("SHA-256");
    102:             byte[] hash = digest.digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
    103:             return java.util.Base64.getEncoder().encodeToString(hash);
    104:         } catch (Exception e) {
    105:             throw new RuntimeException("Password hashing failed", e);
    106:         }
  ```
Case #175
- Before: 1
- After:  0
- Status: CLEAN
Case #170
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #171
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L26-26
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     23:                 return;
     24:             }
     25:
     26:             try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data))) {
     27:                 Object obj = ois.readObject();
     28:                 if (!ALLOWED_CLASS.equals(obj.getClass().getName())) {
     29:                     logger.warning("Unexpected class deserialized: " + ERROR_ID);
  ```
Case #173
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L46-46
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     43:             if (Boolean.getBoolean("debug")) {
     44:                 e.printStackTrace();
     45:             }
     46:         } catch (Exception e) {
     47:             // Log general errors with opaque error ID
     48:             String errorId = "DESERIAL-002";
     49:             System.err.println("Deserialization error [ERRORID: " + errorId + "]");
  ```
Case #174
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-76
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:     // Allowlist of permitted commands (secure default: empty)
      7:     private static final Set<String> ALLOWLISTED_COMMANDS = Set.of(
      8:         "echo", "date", "whoami"  // Example safe commands
      9:     );
     10:
     11:     // Absolute path to shell (never use PATH lookup)
     12:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     13:
     14:     // Pattern to detect dangerous command injection patterns
     15:     private static final Pattern SAFE_COMMAND_PATTERN = Pattern.compile("^[a-zA-Z0-9_\\-./]+$");
     16:
     17:     public static void main(String[] args) {
     18:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     19:             System.out.println("Enter your command (only basic commands like 'echo', 'date', or 'whoami' are allowed):");
     20:             String input = reader.readLine().trim();
     21:
     22:             // Input validation: reject empty or null
     23:             if (input == null || input.isEmpty()) {
     24:                 System.err.println("Error: Command cannot be empty.");
     25:                 return;
     26:             }
     27:
     28:             // Input sanitization: reject dangerous characters
     29:             if (!SAFE_COMMAND_PATTERN.matcher(input).matches()) {
     30:                 System.err.println("Error: Invalid command format.");
     31:                 return;
     32:             }
     33:
     34:             // Command allowlisting: only permit predefined safe commands
     35:             String[] parts = input.split("\\s+", 2);
     36:             String command = parts[0];
     37:             String arguments = parts.length > 1 ? parts[1] : "";
     38:
     39:             if (!ALLOWLISTED_COMMANDS.contains(command)) {
     40:                 System.err.println("Error: Command not allowed.");
     41:                 return;
     42:             }
     43:
     44:             // Safe execution using absolute path and argument array
     45:             ProcessBuilder processBuilder = new ProcessBuilder(
     46:                 ABSOLUTE_SHELL_PATH, "sh", "-c", command + " " + arguments
     47:             );
     48:
     49:             // Disable shell inheritance (security hardening)
     50:             processBuilder.environment().clear();  // Isolate from parent environment
     51:             processBuilder.redirectErrorStream(true);  // Merge stderr into stdout
     52:
     53:             Process process = processBuilder.start();
     54:
     55:             // Read output with timeout (defense-in-depth)
     56:             try (BufferedReader outputReader = new BufferedReader(
     57:                     new InputStreamReader(process.getInputStream()))) {
     58:                 String line;
     59:                 while ((line = outputReader.readLine()) != null) {
     60:                     System.out.println(line);
     61:                 }
     62:             }
     63:
     64:             int exitCode = process.waitFor();
     65:             if (exitCode != 0) {
     66:                 System.err.println("Command failed with exit code: " + exitCode);
     67:             }
     68:
     69:         } catch (IOException | InterruptedException e) {
     70:             // Log error securely (never expose stack traces to users)
     71:             String errorId = UUID.randomUUID().toString();
     72:             System.err.println("An error occurred. Error ID: " + errorId);
     73:             // In production, send errorId + e.toString() to secure error collector
     74:             Thread.currentThread().interrupt();  // Restore interrupt status
     75:         }
     76:     }
     77: }
  ```
Case #166
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L167-167
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    164:             System.err.println("Error occurred: " + errorId);
    165:             // Log detailed error to secure error collector with errorId
    166:             logErrorToCollector(errorId, e);
    167:         } catch (Exception e) {
    168:             // Catch-all for unexpected exceptions
    169:             String errorId = java.util.UUID.randomUUID().toString();
    170:             System.err.println("Unexpected error occurred: " + errorId);
  ```
Case #182
- Before: 3
- After:  0
- Status: CLEAN
Case #181
- Before: 2
- After:  0
- Status: CLEAN
Case #178
- Before: 2
- After:  4
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-704, Lines=L80-96
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     77:      * Generates an opaque error ID for logging
     78:      * @return SHA-256 hash as hex string
     79:      */
     80:     private static String generateOpaqueErrorId() {
     81:         try {
     82:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     83:             byte[] randomBytes = new byte[16];
     84:             new java.security.SecureRandom().nextBytes(randomBytes);
     85:             byte[] hash = digest.digest(randomBytes);
     86:             StringBuilder hexString = new StringBuilder();
     87:             for (byte b : hash) {
     88:                 String hex = Integer.toHexString(0xff & b);
     89:                 if (hex.length() == 1) hexString.append('0');
     90:                 hexString.append(hex);
     91:             }
     92:             return hexString.toString();
     93:         } catch (NoSuchAlgorithmException e) {
     94:             return "unknown-error";
     95:         }
     96:     }
     97:
     98:     /**
     99:      * Retrieves secrets from secure storage (e.g., environment variables, secret manager)
  ```
- [2] Scanner=semgrep, CWE-470, Lines=L126-126
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
    123:
    124:     @Override
    125:     protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
    126:         if (!ALLOWED_CLASSES.contains(Class.forName(desc.getName(), false, ClassLoader.getSystemClassLoader()))) {
    127:             throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
    128:         }
    129:         return super.resolveClass(desc);
  ```
- [3] Scanner=horusec, CWE-502, Lines=L17-17
  Reason: (1/1) * Possible vulnerability detected: Object deserialization is used
Object deserialization of untrusted data can lead to remote code execution, if there is a class in classpath that allows the trigger of malicious operation. For more information checkout the CWE-502 (https://cwe.mitre.org/data/definitions/502.html) advisory.
  Code snippet:
  ```
     14:  * 4. Uses logging framework with opaque error IDs
     15:  * 5. Restricts deserialization to known safe types
     16:  */
     17: public class SecureMain {
     18:     private static final Logger logger = Logger.getLogger(SecureMain.class.getName());
     19:     private static final String HMAC_SECRET = retrieveSecret("DESERIALIZATION_HMAC_SECRET"); // Externalized secret
     20:     private static final String EXPECTED_HMAC = "expected-hmac-signature"; // Should be dynamically generated in real use
  ```
- [4] Scanner=horusec, CWE-0, Lines=L69-69
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     66:         try {
     67:             MessageDigest digest = MessageDigest.getInstance("SHA256");
     68:             byte[] hash = digest.digest(data);
     69:             String actualHmac = Base64.getEncoder().encodeToString(hash);
     70:             return MessageDigest.isEqual(actualHmac.getBytes(), expectedHmac.getBytes());
     71:         } catch (NoSuchAlgorithmException e) {
     72:             return false;
  ```
Case #177
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #176
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L25-25
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     22:  */
     23: public class SecureUtility {
     24:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     25:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     26:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     27:     private static final int MAX_INPUT_LENGTH = 1024;
     28:     private static final int GCM_TAG_LENGTH_BITS = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L60-60
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     57:             new SecureRandom().nextBytes(iv);
     58:
     59:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     60:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     61:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     62:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     63:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [3] Scanner=horusec, CWE-330, Lines=L97-97
  Reason: (1/1) * Possible vulnerability detected: Insecure Random Number Generator
The App uses an insecure Random Number Generator. For more information checkout the CWE-330 (https://cwe.mitre.org/data/definitions/330.html) advisory.
  Code snippet:
  ```
     94:         } catch (Exception e) {
     95:             // Fallback to non-cryptographic random in case of failure
     96:             // This fallback is only for catastrophic failure scenarios
     97:             String errorId = String.format("%08x", (new java.util.Random()).nextLong());
     98:             logger.severe("Cryptographic random number generator failed. Using fallback: " + errorId);
     99:             return errorId;
    100:         }
  ```
- [4] Scanner=semgrep, CWE-330, Lines=L97-97
  Reason: Detected use of the functions `Math.random()` or `java.util.Random()`. These are both not cryptographically strong random number generators (RNGs). If you are using these RNGs to create passwords or secret tokens, use `java.security.SecureRandom` instead.
  Code snippet:
  ```
     94:         } catch (Exception e) {
     95:             // Fallback to non-cryptographic random in case of failure
     96:             // This fallback is only for catastrophic failure scenarios
     97:             String errorId = String.format("%08x", (new java.util.Random()).nextLong());
     98:             logger.severe("Cryptographic random number generator failed. Using fallback: " + errorId);
     99:             return errorId;
    100:         }
  ```
Case #179
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L27-27
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     24:  */
     25: public class SecureUtility {
     26:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     27:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     28:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     29:     private static final int MAX_INPUT_LENGTH = 1024;
     30:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #187
- Before: 1
- After:  0
- Status: CLEAN
Case #180
- Before: 0
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L137-137
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    134:
    135:             // Verify decoding was successful by re-encoding with same URL-safe settings
    136:             Base64.Encoder encoder = Base64.getEncoder();
    137:             String reEncoded = encoder.encodeToString(decodedBytes);
    138:
    139:             // Compare only the non-padding parts to handle different padding scenarios
    140:             String strNoPadding = str.replaceAll("=", "");
  ```
- [2] Scanner=horusec, CWE-0, Lines=L133-133
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
    130:         try {
    131:             // Attempt decoding with strict validation
    132:             Base64.Decoder decoder = Base64.getDecoder();
    133:             byte[] decodedBytes = decoder.decode(str);
    134:
    135:             // Verify decoding was successful by re-encoding with same URL-safe settings
    136:             Base64.Encoder encoder = Base64.getEncoder();
  ```
Case #188
- Before: 0
- After:  0
- Status: CLEAN
Case #192
- Before: 0
- After:  0
- Status: CLEAN
Case #183
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L23-23
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     20:     public static void main(String[] args) {
     21:         // Simulated user input (in real application, this would come from a trusted source)
     22:         String username = "testUser";
     23:         String password = "secureP@ssw0rd";
     24:
     25:         // Validate inputs against allowlists
     26:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #189
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #193
- Before: 4
- After:  0
- Status: CLEAN
Case #194
- Before: 0
- After:  0
- Status: CLEAN
Case #184
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:  */
     28: public class SecureUtility {
     29:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
  ```
- [2] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     34:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_LENGTH = 1024;
     36:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [3] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation with explicit provider
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #190
- Before: 0
- After:  0
- Status: CLEAN
Case #191
- Before: 0
- After:  0
- Status: CLEAN
Case #196
- Before: 2
- After:  0
- Status: CLEAN
Case #185
- Before: 0
- After:  0
- Status: CLEAN
Case #198
- Before: 2
- After:  0
- Status: CLEAN
Case #201
- Before: 1
- After:  0
- Status: CLEAN
Case #199
- Before: 3
- After:  0
- Status: CLEAN
Case #195
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L171-171
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    168:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    169:             System.out.println("Command output:");
    170:             System.out.println(result);
    171:         } catch (Exception e) {
    172:             // In production, log errorId to secure error collector
    173:             System.err.println("Error: An error occurred");
    174:         }
  ```
Case #204
- Before: 4
- After:  0
- Status: CLEAN
Case #200
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L56-56
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     53:             random.nextBytes(randomBytes);
     54:             MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);
     55:             byte[] hash = digest.digest(randomBytes);
     56:             return ERROR_LOG_PREFIX + Base64.getEncoder().encodeToString(hash).replace('+', '-').replace('/', '_').replace('=', '');
     57:         } catch (NoSuchAlgorithmException e) {
     58:             // This should never happen as SHA-256 is a standard algorithm
     59:             return ERROR_LOG_PREFIX + "FALLBACK-" + System.currentTimeMillis();
  ```
Case #197
- Before: 0
- After:  4
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L29-29
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     26:  */
     27: public class SecureUtility {
     28:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     29:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     30:     private static final String SALT_ENV = "APP_ENCRYPTION_SALT";
     31:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     32:     private static final int MAX_INPUT_LENGTH = 1024;
  ```
- [2] Scanner=horusec, CWE-798, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     65:
     66:             // Derive key using PBKDF2 with HMAC-SHA-256
     67:             KeySpec spec = new PBEKeySpec(key.toCharArray(), salt, PBKDF2_ITERATIONS, KEY_LENGTH);
     68:             SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
     69:             Key tmpKey = factory.generateSecret(spec);
     70:             byte[] encryptionKey = Arrays.copyOf(tmpKey.getEncoded(), 32);
     71:
  ```
- [3] Scanner=horusec, CWE-327, Lines=L77-77
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     74:             new SecureRandom().nextBytes(iv);
     75:
     76:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     77:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     78:             GCMParameterSpec specGCM = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     79:             SecretKeySpec keySpec = new SecretKeySpec(encryptionKey, "AES");
     80:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, specGCM);
  ```
- [4] Scanner=horusec, CWE-0, Lines=L64-64
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     61:             }
     62:
     63:             // Generate salt
     64:             byte[] salt = Base64.getDecoder().decode(saltStr);
     65:
     66:             // Derive key using PBKDF2 with HMAC-SHA-256
     67:             KeySpec spec = new PBEKeySpec(key.toCharArray(), salt, PBKDF2_ITERATIONS, KEY_LENGTH);
  ```
Case #209
- Before: 4
- After:  0
- Status: CLEAN
Case #203
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L178-178
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    175:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    176:             System.out.println("Command output:");
    177:             System.out.println(result);
    178:         } catch (Exception e) {
    179:             // In production, log errorId to secure error collector
    180:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    181:         }
  ```
Case #206
- Before: 0
- After:  0
- Status: CLEAN
Case #205
- Before: 1
- After:  0
- Status: CLEAN
Case #207
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L26-26
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     23:  */
     24: public class SecureUtility {
     25:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     26:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     27:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     28:     private static final int MAX_INPUT_LENGTH = 1024;
     29:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #208
- Before: 2
- After:  3
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:         byte[] saltedHash = new byte[salt.length + hash.length];
     79:         System.arraycopy(salt, 0, saltedHash, 0, salt.length);
     80:         System.arraycopy(hash, 0, saltedHash, salt.length, hash.length);
     81:         return Base64.getEncoder().encodeToString(saltedHash);
     82:     }
     83:
     84:     private static boolean verifyHash(String storedHash, String input) throws NoSuchAlgorithmException {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L103-103
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    100:     private static String generateErrorId() {
    101:         byte[] randomBytes = new byte[16];
    102:         new SecureRandom().nextBytes(randomBytes);
    103:         return Base64.getEncoder().encodeToString(randomBytes).replace('+', 'a').replace('/', 'b').replace('=', 'c').substring(0, 16);
    104:     }
    105: }
  ```
- [3] Scanner=horusec, CWE-0, Lines=L85-85
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     82:     }
     83:
     84:     private static boolean verifyHash(String storedHash, String input) throws NoSuchAlgorithmException {
     85:         byte[] storedBytes = Base64.getDecoder().decode(storedHash);
     86:         byte[] salt = new byte[16];
     87:         System.arraycopy(storedBytes, 0, salt, 0, salt.length);
     88:         byte[] storedHashBytes = new byte[storedBytes.length - salt.length];
  ```
Case #213
- Before: 0
- After:  0
- Status: CLEAN
Case #211
- Before: 4
- After:  0
- Status: CLEAN
Case #215
- Before: 0
- After:  0
- Status: CLEAN
Case #212
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #202
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #210
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L146-146
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    143:             // Example usage - should be replaced with actual use case
    144:             String result = executor.executeSecureCommand("/bin/ls", new String[]{"-l", "/tmp"});
    145:             System.out.println("Command output:\n" + result);
    146:         } catch (Exception e) {
    147:             // In production, log errorId to secure error collector
    148:             String errorId = "SECURE_ERROR_001";
    149:             System.err.println("Error occurred: " + errorId);
  ```
Case #186
- Before: 1
- After:  1
- Status: SAME

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-704, Lines=L158-172
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
    155:         }
    156:     }
    157:
    158:     private static String hashInput(String input) {
    159:         try {
    160:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    161:             byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
    162:             StringBuilder hexString = new StringBuilder();
    163:             for (byte b : hash) {
    164:                 String hex = Integer.toHexString(0xff & b);
    165:                 if (hex.length() == 1) hexString.append('0');
    166:                 hexString.append(hex);
    167:             }
    168:             return hexString.toString();
    169:         } catch (Exception ex) {
    170:             return "HASHING_ERROR";
    171:         }
    172:     }
    173: }
  ```
Case #214
- Before: 0
- After:  0
- Status: CLEAN
Case #218
- Before: 0
- After:  0
- Status: CLEAN
Case #219
- Before: 1
- After:  0
- Status: CLEAN
Case #220
- Before: 4
- After:  0
- Status: CLEAN
Case #225
- Before: 0
- After:  0
- Status: CLEAN
Case #216
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L23-23
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     20:
     21:     public static void main(String[] args) {
     22:         String username = "testUser";
     23:         String password = "testPassword";
     24:
     25:         // Input validation (CWE-89 mitigation)
     26:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L103-103
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    100:         try {
    101:             java.security.MessageDigest digest = java.security.MessageDigest.getInstance("SHA-256");
    102:             byte[] hash = digest.digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8));
    103:             return java.util.Base64.getEncoder().encodeToString(hash);
    104:         } catch (Exception e) {
    105:             throw new RuntimeException("Password hashing failed", e);
    106:         }
  ```
Case #222
- Before: 3
- After:  0
- Status: CLEAN
Case #217
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L46-46
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     43:             } else {
     44:                 System.err.println("An error occurred");
     45:             }
     46:         } catch (Exception e) {
     47:             String errorId = "ERR-" + UUID.nameUUIDFromBytes(RANDOM.generateSeed(16));
     48:             logger.log(Level.SEVERE, "Unexpected error: {0}", errorId);
     49:             sendToErrorCollector(errorId, e);
  ```
Case #223
- Before: 3
- After:  0
- Status: CLEAN
Case #221
- Before: 0
- After:  0
- Status: CLEAN
Case #224
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     60:                     }
     61:                 } catch (IOException | InterruptedException e) {
     62:                     logger.severe("Error handling client: " + e.getMessage());
     63:                     String errorId = Base64.getEncoder().encodeToString(e.getStackTrace()[0].toString().getBytes());
     64:                     logger.fine("Stack trace: " + errorId);
     65:                 }
     66:             }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L69-69
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     66:             }
     67:         } catch (IOException e) {
     68:             logger.severe("Failed to start secure server: " + e.getMessage());
     69:             String errorId = Base64.getEncoder().encodeToString(e.getStackTrace()[0].toString().getBytes());
     70:             logger.fine("Stack trace: " + errorId);
     71:         }
     72:     }
  ```
Case #228
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L100-100
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     97:         MessageDigest md = MessageDigest.getInstance("SHA-256");
     98:         md.update(key.getBytes());
     99:         byte[] digest = md.digest(data);
    100:         return Base64.getEncoder().encodeToString(digest);
    101:     }
    102:
    103:     // Simplified HMAC verification
  ```
Case #226
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L120-120
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    117:             String errorId = UUID.randomUUID().toString();
    118:             logError(errorId, "IO error during command execution", e);
    119:             throw new IOException("IO error during command execution", e);
    120:         } catch (Exception e) {
    121:             String errorId = UUID.randomUUID().toString();
    122:             logError(errorId, "Unexpected error during command execution", e);
    123:             throw new IOException("Command execution failed", e);
  ```
Case #231
- Before: 2
- After:  0
- Status: CLEAN
Case #232
- Before: 0
- After:  0
- Status: CLEAN
Case #229
- Before: 0
- After:  0
- Status: CLEAN
Case #233
- Before: 3
- After:  0
- Status: CLEAN
Case #240
- Before: 0
- After:  0
- Status: CLEAN
Case #237
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L15-15
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     12:             User user = new User("admin", "123456"); // Note: In real code, use secure credential handling
     13:             // Simulate a successful operation (no exception should be thrown here)
     14:             System.out.println("User created successfully");
     15:         } catch (Exception e) {
     16:             // Generate an opaque error ID for logging and tracking
     17:             String errorId = UUID.randomUUID().toString();
     18:
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-28
  Reason: CRLF_INJECTION_LOGS
  Code snippet:
  ```
      2: import java.util.UUID;
      3:
      4: // Security-focused class for user management
      5: public class Test {
      6:     // Use a secure logging framework instead of printStackTrace()
      7:     private static final Logger logger = Logger.getLogger(Test.class.getName());
      8:
      9:     public static void main(String[] args) {
     10:         try {
     11:             // Simulate user creation (in real applications, credentials should be hashed)
     12:             User user = new User("admin", "123456"); // Note: In real code, use secure credential handling
     13:             // Simulate a successful operation (no exception should be thrown here)
     14:             System.out.println("User created successfully");
     15:         } catch (Exception e) {
     16:             // Generate an opaque error ID for logging and tracking
     17:             String errorId = UUID.randomUUID().toString();
     18:
     19:             // Log only the error ID and generic message; never log stack traces in production
     20:             logger.severe("Error occurred: " + errorId);
     21:
     22:             // In a real application, send the full exception details to a secure error collector
     23:             // SecureErrorCollector.report(errorId, e);
     24:
     25:             // Return a generic error message to the user
     26:             System.err.println("An error occurred. Please try again later.");
     27:         }
     28:     }
     29: }
     30:
     31: // Simplified User class for demonstration purposes
  ```
Case #238
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    179:         }
  ```
Case #239
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
Case #236
- Before: 1
- After:  7
- Status: WORSE

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L22-22
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     19:     public static void main(String[] args) {
     20:         try {
     21:             // In production, these should come from a secure secrets manager
     22:             String adminHash = hashPassword("secureAdminPass123!".toCharArray());
     23:             String user1Hash = hashPassword("secureUser1Pass456!".toCharArray());
     24:             String user2Hash = hashPassword("secureUser2Pass789!".toCharArray());
     25:             userPasswordHashes.put("admin", adminHash);
  ```
- [2] Scanner=horusec, CWE-798, Lines=L23-23
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     20:         try {
     21:             // In production, these should come from a secure secrets manager
     22:             String adminHash = hashPassword("secureAdminPass123!".toCharArray());
     23:             String user1Hash = hashPassword("secureUser1Pass456!".toCharArray());
     24:             String user2Hash = hashPassword("secureUser2Pass789!".toCharArray());
     25:             userPasswordHashes.put("admin", adminHash);
     26:             userPasswordHashes.put("user1", user1Hash);
  ```
- [3] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:             // In production, these should come from a secure secrets manager
     22:             String adminHash = hashPassword("secureAdminPass123!".toCharArray());
     23:             String user1Hash = hashPassword("secureUser1Pass456!".toCharArray());
     24:             String user2Hash = hashPassword("secureUser2Pass789!".toCharArray());
     25:             userPasswordHashes.put("admin", adminHash);
     26:             userPasswordHashes.put("user1", user1Hash);
     27:             userPasswordHashes.put("user2", user2Hash);
  ```
- [4] Scanner=horusec, CWE-798, Lines=L37-37
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     34:
     35:         // In production, these should come from authenticated user input
     36:         String username = "admin";
     37:         String password = "secureAdminPass123!";
     38:
     39:         if (userPasswordHashes.containsKey(username)) {
     40:             try {
  ```
- [5] Scanner=horusec, CWE-0, Lines=L70-70
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     67:         byte[] hashPlusSalt = new byte[salt.length + hash.length];
     68:         System.arraycopy(salt, 0, hashPlusSalt, 0, salt.length);
     69:         System.arraycopy(hash, 0, hashPlusSalt, salt.length, hash.length);
     70:         return Base64.getEncoder().encodeToString(hashPlusSalt);
     71:     }
     72:
     73:     private static boolean verifyPassword(char[] password, String storedHash)
  ```
- [6] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:     private static String generateOpaqueErrorId() {
     97:         byte[] randomBytes = new byte[16];
     98:         new SecureRandom().nextBytes(randomBytes);
     99:         return Base64.getEncoder().encodeToString(randomBytes);
    100:     }
    101:
    102:     private static void sendToSecureCollector(String errorId, Exception e) {
  ```
- [7] Scanner=horusec, CWE-0, Lines=L79-79
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     76:             return false;
     77:         }
     78:
     79:         byte[] hashPlusSalt = Base64.getDecoder().decode(storedHash);
     80:         if (hashPlusSalt.length < SALT_LENGTH) {
     81:             return false;
     82:         }
  ```
Case #234
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L28-28
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     25:  */
     26: public class SecureUtility {
     27:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     28:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     29:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     30:     private static final int MAX_INPUT_LENGTH = 1024;
     31:     private static final int GCM_TAG_LENGTH_BITS = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L63-63
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     60:             new SecureRandom().nextBytes(iv);
     61:
     62:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     63:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     64:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     65:             SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     66:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L101-101
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     98:         } catch (Exception e) {
     99:             // Fallback to non-cryptographic random in case of failure
    100:             long randomValue = System.nanoTime() ^ System.currentTimeMillis();
    101:             return Base64.getUrlEncoder().withoutPadding().encodeToString(
    102:                 java.util.HexFormat.of().formatHex(randomValue)
    103:                     .getBytes(java.nio.charset.StandardCharsets.UTF_8));
    104:         }
  ```
Case #230
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-470, Lines=L60-60
  Reason: If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.
  Code snippet:
  ```
     57:                 }
     58:                 try {
     59:                     ClassLoader classLoader = ClassLoader.getSystemClassLoader();
     60:                     return Class.forName(className, false, classLoader);
     61:                 } catch (ClassNotFoundException e) {
     62:                     String errorId = "ERR-CLASS-LOADING-003";
     63:                     secureErrorCollector.report(errorId, e);
  ```
Case #227
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #241
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     27:             // Example of a cryptographic operation instead of command execution
     28:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     29:             byte[] hash = digest.digest(input.getBytes(java.nio.charset.StandardCharsets.UTF_8));
     30:             return Base64.getEncoder().encodeToString(hash);
     31:         } catch (NoSuchAlgorithmException e) {
     32:             String errorId = generateErrorId(e);
     33:             logger.severe(String.format(ERROR_MESSAGE, errorId));
  ```
- [2] Scanner=horusec, CWE-0, Lines=L43-43
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     40:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     41:             digest.update(e.getClass().getName().getBytes());
     42:             digest.update(e.getMessage().getBytes());
     43:             return Base64.getEncoder().encodeToString(digest.digest());
     44:         } catch (NoSuchAlgorithmException ex) {
     45:             return "UNKNOWN_ERROR";
     46:         }
  ```
Case #235
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #246
- Before: 0
- After:  0
- Status: CLEAN
Case #244
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L178-178
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    175:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    176:             System.out.println("Command output:");
    177:             System.out.println(result);
    178:         } catch (Exception e) {
    179:             // In production, log errorId to secure error collector
    180:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    181:         }
  ```
Case #242
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             // Example usage - in production, these would come from validated user input
    162:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    163:             System.out.println("Command output: " + result);
    164:         } catch (Exception e) {
    165:             String errorId = UUID.randomUUID().toString();
    166:             logError(errorId, "Exception occurred during command execution", e);
    167:             System.err.println("Error: An error occurred");
  ```
Case #243
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L110-110
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    107:                 String safeLine = line.replaceAll("[^\\p{Print}]", "");
    108:                 byte[] hashedBytes = java.security.MessageDigest.getInstance("SHA-256")
    109:                     .digest(safeLine.getBytes(java.nio.charset.StandardCharsets.UTF_8));
    110:                 logError(generateErrorId(), "Command error: " + Base64.getEncoder().encodeToString(hashedBytes));
    111:             }
    112:         }
    113:
  ```
Case #245
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L24-24
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     21:     public static void main(String[] args) {
     22:         // Simulate user input (in real app, read from secure input source)
     23:         String username = "admin";  // Should come from user input
     24:         String password = "secureP@ss123";  // Should come from user input
     25:
     26:         // Validate inputs
     27:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
Case #250
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L176-176
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    173:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    174:             System.out.println("Command output:");
    175:             System.out.println(result);
    176:         } catch (Exception e) {
    177:             // In production, log errorId to secure error collector
    178:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    179:         }
  ```
Case #247
- Before: 3
- After:  1
- Status: IMPROVED

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L99-99
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     96:             System.arraycopy(saltHash, 0, hashPlusSaltHash, 0, saltHash.length);
     97:             System.arraycopy(hash, 0, hashPlusSaltHash, saltHash.length, hash.length);
     98:
     99:             return Base64.getEncoder().encodeToString(hashPlusSaltHash);
    100:         } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
    101:             String errorId = "ERR-" + System.currentTimeMillis();
    102:             logger.severe("Password hashing error: " + errorId);
  ```
Case #252
- Before: 0
- After:  0
- Status: CLEAN
Case #249
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:  */
     28: public class SecureUtility {
     29:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
  ```
- [2] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     34:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_LENGTH = 1024;
     36:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [3] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation with explicit provider
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #255
- Before: 0
- After:  0
- Status: CLEAN
Case #251
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L38-38
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     35:                 e.printStackTrace();
     36:             }
     37:             sendToErrorCollector(e, ERROR_ID);
     38:         } catch (Exception e) {
     39:             String errorId = "ERR-209-002";
     40:             logger.severe(errorId);
     41:             if (Boolean.getBoolean("debug")) {
  ```
Case #253
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #248
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #254
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     72:         MessageDigest md = MessageDigest.getInstance("SHA-256");
     73:         md.update(key.getBytes());
     74:         byte[] digest = md.digest(data);
     75:         return Base64.getEncoder().encodeToString(digest);
     76:     }
     77:
     78:     // HMAC verification
  ```
Case #261
- Before: 0
- After:  0
- Status: CLEAN
Case #262
- Before: 2
- After:  0
- Status: CLEAN
Case #256
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-326, Lines=L21-21
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     18:     public static void main(String[] args) {
     19:         try {
     20:             // Initialize SSLContext with default settings (can be customized)
     21:             SSLContext sslContext = SSLContext.getInstance("TLS");
     22:
     23:             // Initialize KeyManagerFactory with keystore (server certificate)
     24:             KeyManagerFactory kmf = KeyManagerFactory
  ```
Case #258
- Before: 0
- After:  0
- Status: CLEAN
Case #265
- Before: 0
- After:  0
- Status: CLEAN
Case #266
- Before: 1
- After:  0
- Status: CLEAN
Case #257
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L32-32
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     29:  */
     30: public class SecureUtility {
     31:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     32:     private static final String SECRET_KEY_PROP = "APP_ENCRYPTION_KEY";
     33:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     34:     private static final int MAX_INPUT_LENGTH = 1024;
     35:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #268
- Before: 1
- After:  0
- Status: CLEAN
Case #260
- Before: 3
- After:  2
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L31-31
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     28:                 return;
     29:             }
     30:             System.out.println("Deserialized object: " + ((SafeClass) deserializedObj).getData());
     31:         } catch (Exception e) {
     32:             String errorId = generateErrorId();
     33:             System.err.println("Error occurred: " + errorId);
     34:             sendToSecureErrorCollector(errorId, e);
  ```
- [2] Scanner=horusec, CWE-502, Lines=L8-8
  Reason: (1/1) * Possible vulnerability detected: Object deserialization is used
Object deserialization of untrusted data can lead to remote code execution, if there is a class in classpath that allows the trigger of malicious operation. For more information checkout the CWE-502 (https://cwe.mitre.org/data/definitions/502.html) advisory.
  Code snippet:
  ```
      5: import java.util.Base64;
      6: import java.util.HexFormat;
      7:
      8: public class Main {
      9:     private static final SecureRandom random = new SecureRandom();
     10:     private static final String ERROR_LOG_PREFIX = "ERR-";
     11:     private static final String ALLOWED_CLASS = "com.example.SafeClass";
  ```
Case #259
- Before: 2
- After:  0
- Status: CLEAN
Case #264
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L168-168
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    165:             SecureProcessExecutor executor = new SecureProcessExecutor();
    166:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    167:             System.out.println("Command output:\n" + result);
    168:         } catch (Exception e) {
    169:             System.err.println("Error executing command: An error occurred");
    170:         }
    171:     }
  ```
Case #263
- Before: 0
- After:  0
- Status: CLEAN
Case #273
- Before: 1
- After:  0
- Status: CLEAN
Case #274
- Before: 1
- After:  0
- Status: CLEAN
Case #270
- Before: 0
- After:  0
- Status: CLEAN
Case #271
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: No Default  Hash
This App uses  Hash Code. It"s a weak hash function and should never be used in Secure Crypto Implementation. For more information checkout the CWE-327 (https://cwe.mitre.org/data/definitions/327.html) advisory.
  Code snippet:
  ```
     71:     }
     72:
     73:     @Override
     74:     public int hashCode() {
     75:         return Objects.hash(firstName, lastName);
     76:     }
     77: }
  ```
Case #272
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #277
- Before: 2
- After:  0
- Status: CLEAN
Case #267
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:  */
     28: public class SecureUtility {
     29:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     30:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     31:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     32:     private static final int MAX_INPUT_LENGTH = 1024;
     33:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             new SecureRandom().nextBytes(iv);
     72:
     73:             // AES-GCM encryption implementation
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     77:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #276
- Before: 1
- After:  0
- Status: CLEAN
Case #278
- Before: 0
- After:  0
- Status: CLEAN
Case #269
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L16-16
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     13:     public static void main(String[] args) {
     14:         // Simulated user input - in real application would come from validated source
     15:         String username = "test'; DROP TABLE users; --"; // Vulnerable input (demonstration only)
     16:         String password = "password";
     17:
     18:         // Validate and sanitize inputs
     19:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-209, Lines=L50-50
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     47:             }
     48:             // In production, send error details to secure error collector
     49:             sendErrorToCollector(errorId, e);
     50:         } catch (Exception e) {
     51:             String errorId = "ERR-" + System.currentTimeMillis();
     52:             logger.severe("Application error: " + errorId);
     53:             if (DEBUG_MODE) {
  ```
Case #275
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #279
- Before: 0
- After:  0
- Status: CLEAN
Case #287
- Before: 0
- After:  0
- Status: CLEAN
Case #280
- Before: 0
- After:  0
- Status: CLEAN
Case #281
- Before: 0
- After:  0
- Status: CLEAN
Case #284
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    162:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    163:             System.out.println("Command output:");
    164:             System.out.println(result);
    165:         } catch (Exception e) {
    166:             // In production, log errorId to secure error collector
    167:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    168:             // Stack traces only in debug mode
  ```
Case #283
- Before: 0
- After:  0
- Status: CLEAN
Case #285
- Before: 0
- After:  0
- Status: CLEAN
Case #289
- Before: 0
- After:  0
- Status: CLEAN
Case #286
- Before: 0
- After:  0
- Status: CLEAN
Case #288
- Before: 0
- After:  0
- Status: CLEAN
Case #293
- Before: 1
- After:  0
- Status: CLEAN
Case #282
- Before: 1
- After:  0
- Status: CLEAN
Case #295
- Before: 0
- After:  0
- Status: CLEAN
Case #297
- Before: 0
- After:  0
- Status: CLEAN
Case #300
- Before: 1
- After:  0
- Status: CLEAN
Case #292
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #291
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L28-28
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     25:  */
     26: public class SecureUtility {
     27:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     28:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     29:     private static final String ALLOWED_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
     30:     private static final int MAX_INPUT_LENGTH = 1024;
     31:     private static final int GCM_TAG_LENGTH_BITS = 128;
  ```
- [2] Scanner=horusec, CWE-327, Lines=L62-62
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     59:             new SecureRandom().nextBytes(iv);
     60:
     61:             // Secure AES-GCM encryption implementation
     62:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     63:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
     64:             Key keySpec = new SecretKeySpec(key.getBytes(java.nio.charset.StandardCharsets.UTF_8), "AES");
     65:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #294
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L79-79
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     76:             new SecureRandom().nextBytes(randomBytes);
     77:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     78:             byte[] hash = digest.digest(randomBytes);
     79:             return Base64.getEncoder().encodeToString(hash).replace('+', '-').replace('/', '_').replaceAll("=+$", "");
     80:         } catch (NoSuchAlgorithmException e) {
     81:             throw new RuntimeException("Error generating error ID", e);
     82:         }
  ```
Case #304
- Before: 0
- After:  0
- Status: CLEAN
Case #296
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:                         if (exitCode != 0) {
     66:                             logger.warning("Command failed with exit code: " + exitCode);
     67:                         }
     68:                     } catch (Exception e) {
     69:                         String errorId = "SEC-002";
     70:                         logger.throwing(SecureServer.class.getName(), "main", e);
     71:                         out.println("Error: " + errorId);
  ```
Case #299
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #298
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L255-255
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    252:             // Example usage - should be replaced with actual inputs
    253:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    254:             System.out.println("Command output: " + result);
    255:         } catch (Exception e) {
    256:             // In production, log errorId and send details to secure error collector
    257:             String errorId = UUID.randomUUID().toString();
    258:             System.err.println("ERROR_ID: " + errorId + " - Execution failed");
  ```
- [2] Scanner=semgrep, CWE-704, Lines=L189-205
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
    186:      * @param data data to hash
    187:      * @return SHA-256 hash of the data
    188:      */
    189:     private String hashSensitiveData(String data) {
    190:         try {
    191:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    192:             byte[] hash = digest.digest(data.getBytes());
    193:             StringBuilder hexString = new StringBuilder();
    194:             for (byte b : hash) {
    195:                 String hex = Integer.toHexString(0xff & b);
    196:                 if (hex.length() == 1) hexString.append('0');
    197:                 hexString.append(hex);
    198:             }
    199:             return hexString.toString();
    200:         } catch (NoSuchAlgorithmException e) {
    201:             String errorId = generateErrorId();
    202:             logError(errorId, "Hashing algorithm not found", e);
    203:             return "HASHING_ERROR";
    204:         }
    205:     }
    206:
    207:     /**
    208:      * Secure error logging method
  ```
Case #303
- Before: 0
- After:  0
- Status: CLEAN
Case #302
- Before: 1
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-56
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (case-insensitive, no arguments)
      8:     private static final Set<String> ALLOWLISTED_COMMANDS = Set.of(
      9:         "echo", "date", "whoami"
     10:     );
     11:
     12:     // Absolute path to the shell interpreter (OS-specific)
     13:     private static final String SHELL_PATH = System.getProperty("os.name").toLowerCase().contains("windows")
     14:         ? "C:\\Windows\\System32\\cmd.exe"
     15:         : "/bin/sh";
     16:
     17:     public static void main(String[] args) {
     18:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     19:             System.out.println("Enter a command (allowed: echo, date, whoami): ");
     20:             String userInput = reader.readLine().trim();
     21:
     22:             // Validate input against allowlist
     23:             if (userInput == null || userInput.isEmpty() || !ALLOWLISTED_COMMANDS.contains(userInput.toLowerCase())) {
     24:                 System.err.println("Error: Command not allowed.");
     25:                 return;
     26:             }
     27:
     28:             // Use ProcessBuilder with absolute path and argument array
     29:             ProcessBuilder processBuilder = new ProcessBuilder(SHELL_PATH, "-c", userInput);
     30:
     31:             // Disable shell inheritance (security hardening)
     32:             Map<String, String> env = processBuilder.environment();
     33:             env.remove("IFS"); // Prevent command injection via environment variables
     34:             env.put("SHELL", SHELL_PATH); // Explicitly set shell path
     35:
     36:             // Set secure process properties
     37:             processBuilder.redirectErrorStream(true);
     38:             processBuilder.redirectOutput(new File("command_output.log")); // Log output securely
     39:
     40:             Process process = processBuilder.start();
     41:             int exitCode = process.waitFor();
     42:
     43:             if (exitCode != 0) {
     44:                 System.err.println("Command failed with exit code: " + exitCode);
     45:             } else {
     46:                 System.out.println("Command executed successfully.");
     47:             }
     48:
     49:         } catch (IOException | InterruptedException e) {
     50:             // Log error securely (no stack traces in production)
     51:             String errorId = UUID.randomUUID().toString();
     52:             System.err.println("An error occurred. Error ID: " + errorId);
     53:             // In production, send errorId + stack trace to secure error collector
     54:             e.printStackTrace(); // Only in debug mode
     55:         }
     56:     }
     57: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-56
  Reason: INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (case-insensitive, no arguments)
      8:     private static final Set<String> ALLOWLISTED_COMMANDS = Set.of(
      9:         "echo", "date", "whoami"
     10:     );
     11:
     12:     // Absolute path to the shell interpreter (OS-specific)
     13:     private static final String SHELL_PATH = System.getProperty("os.name").toLowerCase().contains("windows")
     14:         ? "C:\\Windows\\System32\\cmd.exe"
     15:         : "/bin/sh";
     16:
     17:     public static void main(String[] args) {
     18:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     19:             System.out.println("Enter a command (allowed: echo, date, whoami): ");
     20:             String userInput = reader.readLine().trim();
     21:
     22:             // Validate input against allowlist
     23:             if (userInput == null || userInput.isEmpty() || !ALLOWLISTED_COMMANDS.contains(userInput.toLowerCase())) {
     24:                 System.err.println("Error: Command not allowed.");
     25:                 return;
     26:             }
     27:
     28:             // Use ProcessBuilder with absolute path and argument array
     29:             ProcessBuilder processBuilder = new ProcessBuilder(SHELL_PATH, "-c", userInput);
     30:
     31:             // Disable shell inheritance (security hardening)
     32:             Map<String, String> env = processBuilder.environment();
     33:             env.remove("IFS"); // Prevent command injection via environment variables
     34:             env.put("SHELL", SHELL_PATH); // Explicitly set shell path
     35:
     36:             // Set secure process properties
     37:             processBuilder.redirectErrorStream(true);
     38:             processBuilder.redirectOutput(new File("command_output.log")); // Log output securely
     39:
     40:             Process process = processBuilder.start();
     41:             int exitCode = process.waitFor();
     42:
     43:             if (exitCode != 0) {
     44:                 System.err.println("Command failed with exit code: " + exitCode);
     45:             } else {
     46:                 System.out.println("Command executed successfully.");
     47:             }
     48:
     49:         } catch (IOException | InterruptedException e) {
     50:             // Log error securely (no stack traces in production)
     51:             String errorId = UUID.randomUUID().toString();
     52:             System.err.println("An error occurred. Error ID: " + errorId);
     53:             // In production, send errorId + stack trace to secure error collector
     54:             e.printStackTrace(); // Only in debug mode
     55:         }
     56:     }
     57: }
  ```
Case #301
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L195-195
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    192:             // Example usage - should be replaced with actual use case
    193:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    194:             System.out.println("Command output:\n" + result);
    195:         } catch (Exception e) {
    196:             // In production, log errorId and send details to secure error collector
    197:             String errorId = UUID.randomUUID().toString();
    198:             System.err.println("ErrorId: " + errorId + ", Message: An error occurred");
  ```
Case #311
- Before: 1
- After:  0
- Status: CLEAN
Case #290
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L190-190
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    187:         try {
    188:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    189:             System.out.println("Command output: " + result);
    190:         } catch (Exception e) {
    191:             // In production, errorId would be passed from the exception
    192:             System.err.println("Execution failed: " + e.getClass().getSimpleName());
    193:         }
  ```
Case #307
- Before: 0
- After:  0
- Status: CLEAN
Case #308
- Before: 0
- After:  0
- Status: CLEAN
Case #305
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             // Example usage - should be replaced with actual inputs in production
    179:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    180:             System.out.println("Command output: " + result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             String errorId = UUID.randomUUID().toString();
    184:             System.err.println("ERROR_ID: " + errorId + ", Message: An error occurred");
  ```
Case #310
- Before: 0
- After:  0
- Status: CLEAN
Case #309
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L26-26
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     23:  */
     24: public class SecureUtility {
     25:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     26:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     27:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     28:     private static final String AES_CIPHER = "AES/GCM/NoPadding";
     29:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-0, Lines=L60-60
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     57:             }
     58:
     59:             // Decode base64 encoded key
     60:             byte[] decodedKey = Base64.getDecoder().decode(keyBase64);
     61:             if (decodedKey.length != AES_KEY_SIZE / 8) {
     62:                 logger.severe("Encryption key has invalid length");
     63:                 throw new SecurityException("Invalid encryption key length");
  ```
Case #313
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             String errorId = UUID.randomUUID().toString();
    159:             // In production, log errorId to secure error collector
    160:             System.err.println("ERROR_ID: " + errorId + ", Message: An error occurred");
  ```
Case #312
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L71-71
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     68:         // Set working directory to a safe location (CWE-36: Weak Randomness)
     69:         try {
     70:             processBuilder.directory(Paths.get("/tmp").toFile());
     71:         } catch (Exception e) {
     72:             String errorId = UUID.randomUUID().toString();
     73:             logError(errorId, "Failed to set working directory");
     74:             throw new IOException("Failed to set working directory");
  ```
Case #318
- Before: 1
- After:  0
- Status: CLEAN
Case #315
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L169-169
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    166:             // Example usage - in production, these would come from validated user input
    167:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    168:             System.out.println("Command output: " + result);
    169:         } catch (Exception e) {
    170:             // In production, log errorId to secure error collector
    171:             String errorId = UUID.randomUUID().toString();
    172:             System.err.println("ERROR_ID: " + errorId + ", Message: An error occurred");
  ```
Case #314
- Before: 0
- After:  0
- Status: CLEAN
Case #320
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
Case #316
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #317
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L27-27
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     24:  */
     25: public class SecureUtility {
     26:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     27:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     28:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     29:     private static final int MAX_INPUT_LENGTH = 1024;
     30:     private static final int GCM_TAG_LENGTH = 128;
  ```
Case #319
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L75-75
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     72:             new SecureRandom().nextBytes(iv);
     73:
     74:             // AES-GCM encryption implementation (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)
     75:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     76:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     77:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     78:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #323
- Before: 0
- After:  0
- Status: CLEAN
Case #322
- Before: 3
- After:  3
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L58-58
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     55:                 }
     56:                 return null;
     57:             });
     58:         } catch (Exception e) {
     59:             String errorId = UUID.randomUUID().toString().replace("-", "").substring(0, 8).toUpperCase();
     60:             logger.severe("UNEXPECTED_ERROR_" + errorId);
     61:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L32-32
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     29:                     oos.writeObject(obj);
     30:                     oos.flush();
     31:
     32:                     String encodedBytes = Base64.getEncoder().encodeToString(bos.toByteArray());
     33:
     34:                     byte[] decodedBytes = Base64.getDecoder().decode(encodedBytes);
     35:                     try (ByteArrayInputStream bin = new ByteArrayInputStream(decodedBytes);
  ```
- [3] Scanner=horusec, CWE-0, Lines=L34-34
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     31:
     32:                     String encodedBytes = Base64.getEncoder().encodeToString(bos.toByteArray());
     33:
     34:                     byte[] decodedBytes = Base64.getDecoder().decode(encodedBytes);
     35:                     try (ByteArrayInputStream bin = new ByteArrayInputStream(decodedBytes);
     36:                          ObjectInputStream ois = new ObjectInputStream(bin) {
     37:                         @Override
  ```
Case #321
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-89, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: SQL Injection
The input values included in SQL queries need to be passed in safely. Bind variables in prepared statements can be used to easily mitigate the risk of SQL injection. Alternatively to prepare statements, each parameter can be escaped manually. For more information checkout the CWE-89 (https://cwe.mitre.org/data/definitions/89.html) advisory.
  Code snippet:
  ```
     80:     private static String generateHMAC(byte[] data, String key) throws NoSuchAlgorithmException {
     81:         // In production, use a proper HMAC implementation with secure key handling
     82:         MessageDigest md = MessageDigest.getInstance("SHA-256");
     83:         md.update(key.getBytes());
     84:         return Base64.getEncoder().encodeToString(md.digest(data));
     85:     }
     86:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:         // In production, use a proper HMAC implementation with secure key handling
     82:         MessageDigest md = MessageDigest.getInstance("SHA-256");
     83:         md.update(key.getBytes());
     84:         return Base64.getEncoder().encodeToString(md.digest(data));
     85:     }
     86:
     87:     /**
  ```
Case #324
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #331
- Before: 4
- After:  0
- Status: CLEAN
Case #327
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L36-37
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     33:
     34:             byte[] serializedData = bos.toByteArray();
     35:
     36:             try (ObjectInputStream ois = new ObjectInputStream(
     37:                     new ByteArrayInputStream(serializedData))) {
     38:                 ois.setObjectInputFilter((desc, depth) -> {
     39:                     if (desc == null) {
     40:                         return ObjectInputFilter.Status.REJECTED;
  ```
Case #325
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L26-26
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     23:
     24:         // Use a safe deserialization approach
     25:         try (ByteArrayInputStream bin = new ByteArrayInputStream(serializedData);
     26:              ObjectInputStream ois = new ObjectInputStream(bin)) {
     27:
     28:             // Consider using a whitelist of allowed classes
     29:             ois.setObjectInputFilter((desc, depth) -> {
  ```
Case #328
- Before: 0
- After:  0
- Status: CLEAN
Case #326
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L77-77
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     74:             new SecureRandom().nextBytes(iv);
     75:
     76:             // AES-GCM encryption implementation with explicit provider
     77:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     78:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     79:
     80:             // Retrieve key from keystore
  ```
- [2] Scanner=horusec, CWE-0, Lines=L120-120
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    117:         } catch (Exception e) {
    118:             // Fallback to non-cryptographic random in case of failure
    119:             long randomValue = System.nanoTime() ^ System.currentTimeMillis();
    120:             return Base64.getUrlEncoder().withoutPadding().encodeToString(
    121:                 Long.toString(randomValue).getBytes(java.nio.charset.StandardCharsets.UTF_8)
    122:             );
    123:         }
  ```
Case #306
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L191-191
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    188:             // Example secret retrieval
    189:             String apiKey = executor.getSecureSecret("API_KEY_SECURE");
    190:             System.out.println("API Key retrieved successfully");
    191:         } catch (Exception e) {
    192:             // In production, log errorId to secure error collector
    193:             String errorId = UUID.randomUUID().toString();
    194:             System.err.println("Error ID: " + errorId);
  ```
Case #334
- Before: 1
- After:  0
- Status: CLEAN
Case #335
- Before: 2
- After:  0
- Status: CLEAN
Case #329
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L23-23
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     20:
     21:             // Use a safer deserialization approach with validation
     22:             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
     23:             try (ObjectInputStream ois = new ObjectInputStream(bais)) {
     24:                 // Enable strict class validation during deserialization
     25:                 ois.setObjectInputFilter((desc, depth) -> {
     26:                     if (desc.getClassType() == ObjectInputStream.ClassDesc.Type.CLASS) {
  ```
Case #333
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #336
- Before: 1
- After:  0
- Status: CLEAN
Case #338
- Before: 2
- After:  0
- Status: CLEAN
Case #340
- Before: 1
- After:  0
- Status: CLEAN
Case #337
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #330
- Before: 2
- After:  1
- Status: IMPROVED

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L45-45
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     42:         try {
     43:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     44:             byte[] hash = digest.digest(data);
     45:             String actualHmac = Base64.getEncoder().encodeToString(hash);
     46:             return actualHmac.equals(expectedHmac);
     47:         } catch (NoSuchAlgorithmException e) {
     48:             // In production, log securely and fail closed
  ```
Case #343
- Before: 3
- After:  2
- Status: IMPROVED

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L40-40
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     37:             }
     38:
     39:             // 2. Decode and validate key size
     40:             byte[] decodedKey = Base64.getDecoder().decode(secretKeyBase64);
     41:             if (decodedKey.length != KEY_SIZE_BYTES) {
     42:                 logger.severe("Invalid key size. Expected " + KEY_SIZE_BYTES + " bytes");
     43:                 System.err.println("An error occurred");
  ```
- [2] Scanner=horusec, CWE-0, Lines=L83-83
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     80:      */
     81:     private static boolean isValidBase64(String base64) {
     82:         try {
     83:             Base64.getDecoder().decode(base64);
     84:             return true;
     85:         } catch (IllegalArgumentException e) {
     86:             return false;
  ```
Case #347
- Before: 0
- After:  0
- Status: CLEAN
Case #341
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:         // Set working directory to a safe location
     66:         try {
     67:             processBuilder.directory(Paths.get("/tmp").toFile());
     68:         } catch (Exception e) {
     69:             String errorId = UUID.randomUUID().toString();
     70:             logError(errorId, "Failed to set working directory");
     71:             throw new IOException("Failed to set working directory");
  ```
Case #332
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:  */
     28: public class SecureUtility {
     29:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     30:     private static final String SECRET_KEY_ENV = "APP_ENCRYPTION_KEY";
     31:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
     32:     private static final int MAX_INPUT_LENGTH = 1024;
     33:     private static final int GCM_TAG_LENGTH = 128;
  ```
- [2] Scanner=horusec, CWE-0, Lines=L101-101
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     98:     private String generateOpaqueErrorId() {
     99:         byte[] randomBytes = new byte[16];
    100:         new SecureRandom().nextBytes(randomBytes);
    101:         return URL_SAFE_BASE64.encodeToString(randomBytes);
    102:     }
    103:
    104:     /**
  ```
Case #339
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #344
- Before: 0
- After:  0
- Status: CLEAN
Case #349
- Before: 0
- After:  0
- Status: CLEAN
Case #350
- Before: 3
- After:  0
- Status: CLEAN
Case #345
- Before: 0
- After:  0
- Status: CLEAN
Case #354
- Before: 0
- After:  0
- Status: CLEAN
Case #346
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     79:             new SecureRandom().nextBytes(iv);
     80:
     81:             // AES-GCM encryption implementation with explicit provider
     82:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     83:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     84:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     85:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #342
- Before: 0
- After:  0
- Status: CLEAN
Case #348
- Before: 2
- After:  0
- Status: CLEAN
Case #357
- Before: 0
- After:  0
- Status: CLEAN
Case #352
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #355
- Before: 3
- After:  0
- Status: CLEAN
Case #351
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #353
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L165-165
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    162:             // Example secret retrieval
    163:             String apiKey = executor.getSecureSecret("PRODUCTION_API_KEY");
    164:             System.out.println("API Key retrieved successfully");
    165:         } catch (Exception e) {
    166:             // In production, log errorId to secure error collector
    167:             String errorId = UUID.randomUUID().toString();
    168:             System.err.println("Error occurred: " + errorId);
  ```
Case #360
- Before: 0
- After:  0
- Status: CLEAN
Case #364
- Before: 3
- After:  0
- Status: CLEAN
Case #356
- Before: 0
- After:  2
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L174-174
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    171:             // Example usage - should be externalized in production
    172:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    173:             System.out.println("Command output:\n" + result);
    174:         } catch (Exception e) {
    175:             // Use instance variables instead of creating new instances
    176:             String errorId = executor.generateOpaqueErrorId();
    177:             executor.logError(errorId, "Execution failed", e);
  ```
- [2] Scanner=horusec, CWE-0, Lines=L135-135
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    132:         // Use secure random generator with Base64 encoding for compactness
    133:         byte[] randomBytes = new byte[32]; // Increased from 16 to 32 bytes for better entropy
    134:         new SecureRandom().nextBytes(randomBytes);
    135:         return Base64.getEncoder().withoutPadding().encodeToString(randomBytes);
    136:     }
    137:
    138:     /**
  ```
Case #358
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     30:             String errorId = generateErrorId();
     31:             logError(errorId, e);
     32:             System.err.println("An error occurred: " + errorId);
     33:         } catch (Exception e) {
     34:             // Catch-all for unexpected exceptions
     35:             String errorId = generateErrorId();
     36:             logError(errorId, e);
  ```
Case #359
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L136-136
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    133:         try {
    134:             byte[] randomBytes = new byte[16];
    135:             new SecureRandom().nextBytes(randomBytes);
    136:             return "ERR-" + Base64.getEncoder().encodeToString(randomBytes).replace('+', '-').replace('/', '_').replace('=', '');
    137:         } catch (Exception e) {
    138:             return "ERR-" + UUID.randomUUID().toString().replace('-', '_');
    139:         }
  ```
Case #365
- Before: 0
- After:  0
- Status: CLEAN
Case #366
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #367
- Before: 1
- After:  0
- Status: CLEAN
Case #361
- Before: 0
- After:  0
- Status: CLEAN
Case #363
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #371
- Before: 2
- After:  0
- Status: CLEAN
Case #369
- Before: 0
- After:  0
- Status: CLEAN
Case #368
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #370
- Before: 0
- After:  0
- Status: CLEAN
Case #362
- Before: 5
- After:  0
- Status: CLEAN
Case #378
- Before: 4
- After:  0
- Status: CLEAN
Case #379
- Before: 0
- After:  0
- Status: CLEAN
Case #374
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L179-179
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    176:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    177:             System.out.println("Command output:");
    178:             System.out.println(result);
    179:         } catch (Exception e) {
    180:             // In production, log errorId to secure error collector
    181:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    182:         }
  ```
Case #376
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L81-81
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     78:             new SecureRandom().nextBytes(randomBytes);
     79:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     80:             byte[] hash = digest.digest(randomBytes);
     81:             byte[] encodedHash = Base64.getEncoder().encode(hash);
     82:             // Limit to 22 characters to match UUID format while maintaining security
     83:             return new String(encodedHash, 0, Math.min(encodedHash.length, 22)) + UUID.randomUUID().toString().substring(22);
     84:         } catch (NoSuchAlgorithmException e) {
  ```
Case #372
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L82-82
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     79:             new SecureRandom().nextBytes(iv);
     80:
     81:             // AES-GCM encryption implementation with explicit provider
     82:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     83:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     84:             SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     85:             cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #375
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L203-203
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    200:             // Example usage - in production, inputs would come from secure sources
    201:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    202:             System.out.println("Command output: " + result);
    203:         } catch (Exception e) {
    204:             // In production, log errorId and send details to secure error collector
    205:             String errorId = UUID.randomUUID().toString();
    206:             System.err.println("An error occurred [" + errorId + "]");
  ```
Case #384
- Before: 2
- After:  0
- Status: CLEAN
Case #386
- Before: 0
- After:  0
- Status: CLEAN
Case #373
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L181-181
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output:");
    180:             System.out.println(result);
    181:         } catch (Exception e) {
    182:             // In production, log errorId to secure error collector
    183:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    184:         }
  ```
Case #381
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #385
- Before: 0
- After:  0
- Status: CLEAN
Case #383
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #390
- Before: 1
- After:  0
- Status: CLEAN
Case #380
- Before: 0
- After:  0
- Status: CLEAN
Case #377
- Before: 0
- After:  0
- Status: CLEAN
Case #389
- Before: 1
- After:  0
- Status: CLEAN
Case #382
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:  */
     28: public class SecureUtility {
     29:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
  ```
- [2] Scanner=horusec, CWE-798, Lines=L33-33
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     30:     private static final String SECRET_KEY_ALIAS = "APP_ENCRYPTION_KEY";
     31:     private static final String KEYSTORE_PATH = "/etc/security/app.keystore";
     32:     private static final String KEYSTORE_TYPE = "JKS";
     33:     private static final String KEYSTORE_PASSWORD = "keystore_password";
     34:     private static final String ALLOWED_CHARS = "^[a-zA-Z0-9_-]{1,128}$";
     35:     private static final int MAX_INPUT_SIZE = 1024 * 1024; // 1MB
     36:     private static final int GCM_TAG_LENGTH = 128; // bits
  ```
Case #387
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L157-157
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    154:             // Example usage - in production, these would come from validated user input
    155:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    156:             System.out.println("Command output: " + result);
    157:         } catch (Exception e) {
    158:             String errorId = UUID.randomUUID().toString();
    159:             executor.logError(errorId, "Exception occurred during command execution", e);
    160:             System.err.println("Error: An error occurred");
  ```
Case #388
- Before: 1
- After:  0
- Status: CLEAN

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #392
- Before: 0
- After:  0
- Status: CLEAN
Case #395
- Before: 0
- After:  0
- Status: CLEAN
Case #391
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L18-18
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     15:     public static void main(String[] args) {
     16:         // Simulated user input (in real app, read from secure input handler)
     17:         String username = "test' OR '1'='1"; // Example of malicious input
     18:         String password = "P@ssw0rd";       // Example of strong password
     19:
     20:         // Validate inputs (CWE-89 mitigation)
     21:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=horusec, CWE-0, Lines=L72-72
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     69:     // Simulated secure password hashing (OWASP Password Storage Cheat Sheet)
     70:     private static String hashPassword(String password) {
     71:         // In production, use a proper password hashing library like BCrypt
     72:         return java.util.Base64.getEncoder().encodeToString(
     73:             java.security.MessageDigest.getInstance("SHA-256")
     74:                 .digest(password.getBytes(java.nio.charset.StandardCharsets.UTF_8))
     75:         );
  ```
Case #397
- Before: 2
- After:  3
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-502, Lines=L94-94
  Reason: Found object deserialization using ObjectInputStream. Deserializing entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences. Ensure that the objects being deserialized are not user-controlled. If this must be done, consider using HMACs to sign the data stream to make sure it is not tampered with, or consider only transmitting object fields and populating a new object.
  Code snippet:
  ```
     91:         oos.writeObject(payload);
     92:         oos.close();
     93:
     94:         try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()))) {
     95:             Class<?> resolvedClass = ois.readClassDescriptor().resolveClass(null);
     96:             if (!isClassAllowed(resolvedClass)) {
     97:                 String errorId = generateErrorId();
  ```
- [2] Scanner=horusec, CWE-0, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     65:     private String generateErrorId() {
     66:         byte[] randomBytes = new byte[16];
     67:         new SecureRandom().nextBytes(randomBytes);
     68:         return Base64.getEncoder().encodeToString(randomBytes);
     69:     }
     70:
     71:     private void sendToSecureErrorCollector(String errorId, Throwable throwable) {
  ```
- [3] Scanner=horusec, CWE-0, Lines=L122-122
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    119:     private static String generateErrorId() {
    120:         byte[] randomBytes = new byte[16];
    121:         new SecureRandom().nextBytes(randomBytes);
    122:         return Base64.getEncoder().encodeToString(randomBytes);
    123:     }
    124: }
  ```
Case #394
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L47-47
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     44:             if (Boolean.getBoolean("debug")) {
     45:                 e.printStackTrace();
     46:             }
     47:         } catch (Exception e) {
     48:             String errorId = String.format("%040x", random.nextLong());
     49:             System.err.println("Error occurred: " + errorId);
     50:             // Send errorId and sanitized info to secure error collector
  ```
Case #400
- Before: 2
- After:  0
- Status: CLEAN
Case #393
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L79-79
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     76:             byte[] randomBytes = new byte[16];
     77:             new SecureRandom().nextBytes(randomBytes);
     78:             byte[] hash = MessageDigest.getInstance("SHA-256").digest(randomBytes);
     79:             return Base64.getEncoder().encodeToString(hash);
     80:         } catch (NoSuchAlgorithmException e) {
     81:             // This should never happen with SHA-256
     82:             byte[] fallback = new byte[32];
  ```
- [2] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             // This should never happen with SHA-256
     82:             byte[] fallback = new byte[32];
     83:             new SecureRandom().nextBytes(fallback);
     84:             return Base64.getEncoder().encodeToString(fallback);
     85:         }
     86:     }
     87: }
  ```
Case #399
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #398
- Before: 0
- After:  3
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L180-180
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    177:             // Example usage - in production, inputs should come from secure sources
    178:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    179:             System.out.println("Command output: " + result);
    180:         } catch (Exception e) {
    181:             String errorId = generateErrorId();
    182:             System.err.println("Error ID: " + errorId + ", Message: An error occurred");
    183:         }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L151-151
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    148:             new SecureRandom().nextBytes(randomBytes);
    149:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    150:             byte[] hash = digest.digest(randomBytes);
    151:             return Base64.getUrlEncoder().encodeToString(hash);
    152:         } catch (NoSuchAlgorithmException e) {
    153:             // This should never happen with SHA-256
    154:             String errorId = UUID.randomUUID().toString();
  ```
- [3] Scanner=horusec, CWE-0, Lines=L193-193
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
    190:             new SecureRandom().nextBytes(randomBytes);
    191:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
    192:             byte[] hash = digest.digest(randomBytes);
    193:             return Base64.getUrlEncoder().encodeToString(hash);
    194:         } catch (NoSuchAlgorithmException e) {
    195:             // This should never happen with SHA-256
    196:             String errorId = UUID.randomUUID().toString();
  ```
Case #405
- Before: 1
- After:  0
- Status: CLEAN
Case #402
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-326, Lines=L15-15
  Reason: An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions are considered weak encryption and are deprecated. Use SSLContext.getInstance("TLSv1.2") for the best security.
  Code snippet:
  ```
     12:     public static void main(String[] args) {
     13:         try {
     14:             // Load SSLContext with default truststore (can be replaced with custom keystore)
     15:             SSLContext sslContext = SSLContext.getInstance("TLS");
     16:             sslContext.init(null, null, null); // Uses default truststore
     17:
     18:             SSLServerSocketFactory factory = sslContext.getServerSocketFactory();
  ```
Case #403
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    162:             System.out.println("Command output:");
    163:             System.out.println(result);
    164:         } catch (Exception e) {
    165:             // In production, log errorId to secure error collector
    166:             System.err.println("Error occurred: " + e.getClass().getSimpleName());
    167:         }
  ```
Case #404
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L161-161
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    158:             String result = executor.executeCommand("ping", new String[]{"-c", "4", "example.com"});
    159:             System.out.println("Command output:");
    160:             System.out.println(result);
    161:         } catch (Exception e) {
    162:             // In production, log errorId to secure error collector
    163:             System.err.println("Error: An error occurred");
    164:         }
  ```
Case #401
- Before: 2
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L31-31
  Reason: (1/1) * Possible vulnerability detected: Base64 Decode
Base64 Decode
  Code snippet:
  ```
     28:             // Use Base64 decoder with strict validation
     29:             byte[] data;
     30:             try {
     31:                 data = Base64.getDecoder().decode(encodedData);
     32:             } catch (IllegalArgumentException e) {
     33:                 throw new IllegalArgumentException("Invalid Base64 encoding", e);
     34:             }
  ```
Case #407
- Before: 2
- After:  0
- Status: CLEAN
Case #408
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-0, Lines=L78-78
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     75:         try {
     76:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     77:             byte[] hashBytes = digest.digest(data);
     78:             return "SHA256:" + Base64.getEncoder().encodeToString(hashBytes);
     79:         } catch (NoSuchAlgorithmException e) {
     80:             throw new RuntimeException("SHA-256 algorithm not available", e);
     81:         }
  ```
- [2] Scanner=horusec, CWE-0, Lines=L93-93
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     90:         try {
     91:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     92:             byte[] hashBytes = digest.digest(message.getBytes());
     93:             return Base64.getEncoder().encodeToString(hashBytes).substring(0, 10);
     94:         } catch (NoSuchAlgorithmException e) {
     95:             return "ERRORID_GEN_FAILED";
     96:         }
  ```
Case #406
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L68-68
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
     65:         // Set working directory to a safe location
     66:         try {
     67:             processBuilder.directory(Paths.get("/tmp").toFile());
     68:         } catch (Exception e) {
     69:             String errorId = UUID.randomUUID().toString();
     70:             logError(errorId, "Failed to set working directory");
     71:             throw new IOException("Failed to set working directory");
  ```
Case #411
- Before: 2
- After:  0
- Status: CLEAN
Case #396
- Before: 0
- After:  0
- Status: CLEAN
Case #415
- Before: 3
- After:  0
- Status: CLEAN
Case #412
- Before: 0
- After:  0
- Status: CLEAN
Case #414
- Before: 2
- After:  0
- Status: CLEAN

False Positives:
- generic FP (env/args): potential hard-coded credential rule=HorusecEngine
Case #418
- Before: 0
- After:  0
- Status: CLEAN
Case #413
- Before: 2
- After:  0
- Status: CLEAN
Case #409
- Before: 0
- After:  0
- Status: CLEAN

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
Case #421
- Before: 2
- After:  0
- Status: CLEAN
Case #419
- Before: 3
- After:  1
- Status: IMPROVED

Remaining vulnerabilities:
- [1] Scanner=semgrep, CWE-704, Lines=L75-96
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
     72:         }
     73:     }
     74:
     75:     private static String generateSecureErrorId() {
     76:         byte[] randomBytes = new byte[16];
     77:         new SecureRandom().nextBytes(randomBytes);
     78:         // Use SHA-256 hashing for security
     79:         try {
     80:             MessageDigest digest = MessageDigest.getInstance("SHA-256");
     81:             byte[] hashedBytes = digest.digest(randomBytes);
     82:             // Return hex string instead of Base64 to avoid encoding confusion
     83:             StringBuilder hexString = new StringBuilder();
     84:             for (byte b : hashedBytes) {
     85:                 String hex = Integer.toHexString(0xff & b);
     86:                 if (hex.length() == 1) hexString.append('0');
     87:                 hexString.append(hex);
     88:             }
     89:             return hexString.toString();
     90:         } catch (NoSuchAlgorithmException e) {
     91:             // This should never happen in Java 8+ as SHA-256 is guaranteed to be available
     92:             // In production, this would be handled by a secure error collector
     93:             // Returning a fixed error ID as a last resort
     94:             return "FIXED_ERROR_ID";
     95:         }
     96:     }
     97: }
  ```
Case #420
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L30-30
  Reason: (1/1) * Possible vulnerability detected: Potential Hard-coded credential
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     27:     private static final Logger logger = Logger.getLogger(SecureUtility.class.getName());
     28:     private static final String KEYSTORE_PROP = "APP_KEYSTORE_PATH";
     29:     private static final String KEYSTORE_TYPE_PROP = "APP_KEYSTORE_TYPE";
     30:     private static final String KEYSTORE_SECRET_KEY_ALIAS_PROP = "APP_KEYSTORE_SECRET_KEY_ALIAS";
     31:     private static final String KEYSTORE_PASSWORD_PROP = "APP_KEYSTORE_PASSWORD";
     32:     private static final String KEY_PASSWORD_PROP = "APP_KEY_PASSWORD";
     33:     private static final String ALLOWED_CHARS = "^[A-Za-z0-9_-]{1,128}$";
  ```
- [2] Scanner=horusec, CWE-327, Lines=L87-87
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     84:                 new SecureRandom().nextBytes(iv);
     85:
     86:                 // AES-GCM encryption implementation
     87:                 Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
     88:                 GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     89:                 SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
     90:                 cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
  ```
Case #416
- Before: 1
- After:  2
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=spotbugs, CWE-0, Lines=L5-73
  Reason: COMMAND_INJECTION
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data leakage)
     53:             try (BufferedReader processReader = new BufferedReader(
     54:                     new InputStreamReader(process.getInputStream()))) {
     55:                 String line;
     56:                 while ((line = processReader.readLine()) != null) {
     57:                     System.out.println(line);
     58:                 }
     59:             }
     60:
     61:             int exitCode = process.waitFor();
     62:             if (exitCode != 0) {
     63:                 System.err.println("Command execution failed with exit code: " + exitCode);
     64:             }
     65:
     66:         } catch (IOException | InterruptedException e) {
     67:             // Log error securely (no stack trace exposure)
     68:             String errorId = UUID.randomUUID().toString();
     69:             System.err.println("An error occurred. Error ID: " + errorId);
     70:             // In production, send errorId + stack trace to secure error collector
     71:             e.printStackTrace(); // Only in debug mode
     72:         }
     73:     }
     74: }
  ```
- [2] Scanner=spotbugs, CWE-0, Lines=L5-73
  Reason: INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE
  Code snippet:
  ```
      2: import java.util.*;
      3: import java.util.regex.Pattern;
      4:
      5: public class Test {
      6:
      7:     // Allowlist of permitted commands (secure default)
      8:     private static final Set<String> ALLOWED_COMMANDS = Set.of("echo", "date", "whoami");
      9:
     10:     // Absolute path to shell (secure default, platform-specific)
     11:     private static final String ABSOLUTE_SHELL_PATH = "/usr/bin/env";
     12:
     13:     // Secure command arguments (never concatenate user input directly)
     14:     private static final List<String> SHELL_ARGUMENTS = List.of("sh", "-c");
     15:
     16:     public static void main(String[] args) {
     17:         try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
     18:             System.out.println("Enter command (allowed: echo, date, whoami):");
     19:             String input = reader.readLine().trim();
     20:
     21:             // Input validation: reject empty or null input
     22:             if (input == null || input.isBlank()) {
     23:                 System.err.println("Error: Empty input is not allowed.");
     24:                 return;
     25:             }
     26:
     27:             // Input sanitization: reject dangerous characters
     28:             if (Pattern.compile("[^a-zA-Z0-9\\s\\-_:.]").matcher(input).find()) {
     29:                 System.err.println("Error: Invalid characters detected in input.");
     30:                 return;
     31:             }
     32:
     33:             // Command allowlisting: split input and validate first token
     34:             String[] tokens = input.split("\\s+", 2);
     35:             String command = tokens[0];
     36:
     37:             if (!ALLOWED_COMMANDS.contains(command)) {
     38:                 System.err.println("Error: Command not allowed.");
     39:                 return;
     40:             }
     41:
     42:             // Construct safe command array (no shell interpolation)
     43:             List<String> commandArray = new ArrayList<>();
     44:             commandArray.addAll(SHELL_ARGUMENTS);
     45:             commandArray.add(input);
     46:
     47:             // Execute command safely using absolute path
     48:             Process process = new ProcessBuilder(commandArray)
     49:                     .redirectErrorStream(true)
     50:                     .start();
     51:
     52:             // Read and log output (no sensitive data leakage)
     53:             try (BufferedReader processReader = new BufferedReader(
     54:                     new InputStreamReader(process.getInputStream()))) {
     55:                 String line;
     56:                 while ((line = processReader.readLine()) != null) {
     57:                     System.out.println(line);
     58:                 }
     59:             }
     60:
     61:             int exitCode = process.waitFor();
     62:             if (exitCode != 0) {
     63:                 System.err.println("Command execution failed with exit code: " + exitCode);
     64:             }
     65:
     66:         } catch (IOException | InterruptedException e) {
     67:             // Log error securely (no stack trace exposure)
     68:             String errorId = UUID.randomUUID().toString();
     69:             System.err.println("An error occurred. Error ID: " + errorId);
     70:             // In production, send errorId + stack trace to secure error collector
     71:             e.printStackTrace(); // Only in debug mode
     72:         }
     73:     }
     74: }
  ```
Case #410
- Before: 0
- After:  1
- Status: WORSE

False Positives:
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L164-164
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    161:             // Example usage - should be configured via secure input
    162:             String result = executor.executeCommand("ping", new String[]{"8.8.8.8", "-c", "4"});
    163:             System.out.println("Command output:\n" + result);
    164:         } catch (Exception e) {
    165:             String errorId = "CMD_EXEC_FAILURE";
    166:             if (Boolean.getBoolean("debug")) {
    167:                 e.printStackTrace();
  ```
Case #423
- Before: 1
- After:  1
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-79, Lines=L32-32
  Reason: (1/1) * Possible vulnerability detected: Potential XSS in Servlet
A potential XSS was found. It could be used to execute unwanted Script in a client's browser. For more information checkout the CWE-79 (https://cwe.mitre.org/data/definitions/79.html) advisory
  Code snippet:
  ```
     29:     @Override
     30:     protected void doPost(HttpServletRequest request, HttpServletResponse response)
     31:             throws ServletException, IOException {
     32:         String userInput = request.getParameter("userInput");
     33:         String errorId = "ERR-" + System.currentTimeMillis();
     34:
     35:         if (userInput == null || !userInput.matches(ALLOWLIST_PATTERN) ||
  ```
Case #422
- Before: 0
- After:  1
- Status: WORSE

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-209, Lines=L120-120
  Reason: (1/1) * Possible vulnerability detected: Information Exposure Through An Error Message
The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. For more information checkout the CWE-209 (https://cwe.mitre.org/data/definitions/209.html) advisory.
  Code snippet:
  ```
    117:             String errorId = UUID.randomUUID().toString();
    118:             logError(errorId, "IO error during command execution", e);
    119:             throw new IOException("IO error during command execution", e);
    120:         } catch (Exception e) {
    121:             String errorId = UUID.randomUUID().toString();
    122:             logError(errorId, "Unexpected error during command execution", e);
    123:             throw new IOException("Command execution failed", e);
  ```
Case #424
- Before: 2
- After:  2
- Status: SAME

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-798, Lines=L34-34
  Reason: (1/1) * Possible vulnerability detected: Hard-coded password
The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data. For more information checkout the CWE-798 (https://cwe.mitre.org/data/definitions/798.html) advisory.
  Code snippet:
  ```
     31:
     32:         // Simulated user input (in real application, these would come from request parameters)
     33:         String username = "testUser";
     34:         String password = "securePassword123";
     35:
     36:         // Validate inputs
     37:         if (!isValidUsername(username) || !isValidPassword(password)) {
  ```
- [2] Scanner=semgrep, CWE-704, Lines=L105-120
  Reason: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format("%02X", ...)' instead.
  Code snippet:
  ```
    102:      * Hashes password using secure algorithm (in production, use BCrypt or similar)
    103:      * Note: This is a simplified example - real applications should use proper password hashing
    104:      */
    105:     private static String hashPassword(String password) {
    106:         try {
    107:             // In production, use BCrypt or Argon2
    108:             MessageDigest md = MessageDigest.getInstance("SHA-256");
    109:             byte[] hashBytes = md.digest(password.getBytes(StandardCharsets.UTF_8));
    110:             StringBuilder hexString = new StringBuilder();
    111:             for (byte b : hashBytes) {
    112:                 String hex = Integer.toHexString(0xff & b);
    113:                 if (hex.length() == 1) hexString.append('0');
    114:                 hexString.append(hex);
    115:             }
    116:             return hexString.toString();
    117:         } catch (NoSuchAlgorithmException e) {
    118:             throw new RuntimeException("Hashing algorithm not available", e);
    119:         }
    120:     }
    121: }
  ```
Case #417
- Before: 0
- After:  2
- Status: WORSE

False Positives:
- horusec CWE-0 base64 acceptable pattern rule=HorusecEngine
- horusec CWE-0 javax.crypto rule=HorusecEngine
- semgrep CWE-78 rule=java.lang.security.audit.command-injection-process-builder.command-injection-process-builder

Remaining vulnerabilities:
- [1] Scanner=horusec, CWE-327, Lines=L74-74
  Reason: (1/1) * Possible vulnerability detected: Weak block mode for Cryptographic Hash Function
A weak ECB, (a.k.a 'block mode') was found in one of your Ciphers. Always use a strong, high entropy hash, for example the SHA-512 with salt options. For more information check CWE-327 (https://cwe.mitre.org/data/definitions/327.html), CWE-719 (https://cwe.mitre.org/data/definitions/719.html), CWE-326 (https://cwe.mitre.org/data/definitions/326.html) and CWE-780 (https://cwe.mitre.org/data/definitions/780.html) for deeper details on how to fix it.
  Code snippet:
  ```
     71:             byte[] iv = new byte[GCM_IV_LENGTH];
     72:             new SecureRandom().nextBytes(iv);
     73:
     74:             Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
     75:             GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
     76:             cipher.init(Cipher.ENCRYPT_MODE, key, spec);
     77:
  ```
- [2] Scanner=horusec, CWE-0, Lines=L84-84
  Reason: (1/1) * Possible vulnerability detected: Base64 Encode
Basic authentication's only means of obfuscation is Base64 encoding. Since Base64 encoding is easily recognized and reversed, it offers only the thinnest veil of protection to your users, and should not be used.
  Code snippet:
  ```
     81:             System.arraycopy(iv, 0, encryptedData, 0, iv.length);
     82:             System.arraycopy(cipherText, 0, encryptedData, iv.length, cipherText.length);
     83:
     84:             return Base64.getEncoder().encodeToString(encryptedData);
     85:         } catch (KeyStoreException | NoSuchAlgorithmException | CertificateException |
     86:                  IOException | UnrecoverableKeyException | NoSuchPaddingException | InvalidKeySpecException |
     87:                  java.security.InvalidKeyException | javax.crypto.IllegalBlockSizeException |
  ```
Summary
=====
Total:    424
Clean:    236
Improved: 42
Same:     24
Worse:    122
